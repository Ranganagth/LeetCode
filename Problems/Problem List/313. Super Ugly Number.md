[313. Super Ugly Number](https://leetcode.com/problems/super-ugly-number/)

# Intuition
To find the nth super ugly number, we can use a similar approach to the one used for generating ugly numbers. The idea is to use a min-heap (or priority queue) to keep track of the next possible super ugly numbers and to generate them in increasing order. By multiplying the existing super ugly numbers by the given primes, we can ensure that all generated numbers are super ugly numbers.

# Approach
1. **Initialize a Min-Heap**:
   - Start with a min-heap containing the first super ugly number, which is 1.
   - Use an array to keep track of the super ugly numbers in increasing order.

2. **Generate Super Ugly Numbers**:
   - Extract the smallest number from the heap and add it to the list of super ugly numbers.
   - For each prime, multiply it by the extracted number and add the result back into the heap if it is not already in the heap.
   - Use a set to avoid duplicate entries in the heap.

3. **Repeat Until nth Super Ugly Number**:
   - Continue the above process until you generate the nth super ugly number.

# Complexity
- **Time Complexity**: ***O(n * k log(n * k))***, where `n` is the number of super ugly numbers to generate and `k` is the number of primes. Each insertion and extraction operation in the heap takes *O(log(n * k))*.
- **Space Complexity**: ***O(n * k)*** for storing the super ugly numbers and the heap.

# Code
```typescript
function nthSuperUglyNumber(n: number, primes: number[]): number {
    const uglyNumbers: number[] = [1];
    const heap = new MinHeap();
    const seen = new Set<number>();

    for (const prime of primes) {
        heap.insert(prime);
        seen.add(prime);
    }

    while (uglyNumbers.length < n) {
        const minUgly = heap.extractMin();
        uglyNumbers.push(minUgly);

        for (const prime of primes) {
            const newUgly = minUgly * prime;
            if (!seen.has(newUgly)) {
                heap.insert(newUgly);
                seen.add(newUgly);
            }
        }
    }

    return uglyNumbers[n - 1];
}

class MinHeap {
    private heap: number[];

    constructor() {
        this.heap = [];
    }

    insert(val: number) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }

    extractMin(): number {
        if (this.heap.length === 1) return this.heap.pop()!;
        const minVal = this.heap[0];
        this.heap[0] = this.heap.pop()!;
        this.bubbleDown(0);
        return minVal;
    }

    private bubbleUp(index: number) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index] >= this.heap[parentIndex]) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    private bubbleDown(index: number) {
        const length = this.heap.length;
        while (true) {
            const left = 2 * index + 1;
            const right = 2 * index + 2;
            let smallest = index;

            if (left < length && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < length && this.heap[right] < this.heap[smallest]) smallest = right;

            if (smallest === index) break;
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
};

```

### Explanation
1. **Initialization**:
   - The `uglyNumbers` array starts with the first super ugly number, which is 1.
   - The `heap` is a custom MinHeap used to keep track of the next super ugly numbers.
   - The `seen` set is used to avoid inserting duplicate numbers into the heap.

2. **Generating Super Ugly Numbers**:
   - The while loop continues until the length of `uglyNumbers` reaches `n`.
   - The smallest number from the heap is extracted and added to `uglyNumbers`.
   - For each prime, the new possible super ugly number is generated by multiplying the extracted number by the prime, and if it is not already seen, it is added to the heap and marked as seen.

3. **Heap Operations**:
   - `insert` adds a number to the heap and ensures the heap property is maintained by bubbling up.
   - `extractMin` removes and returns the smallest number from the heap and ensures the heap property is maintained by bubbling down.