[38. Count and Say](https://leetcode.com/problems/count-and-say/)

# Intuition
The "count-and-say" sequence is a sequence of strings where each term is generated based on the previous term using a specific pattern. The sequence starts with "1" and each subsequent term is generated by describing the previous term in terms of consecutive digits. The key to solving this problem is understanding how to describe each term and how to iterate to generate the next term.

# Approach
1. **Base Case**: The sequence starts with "1".
2. **Iterative Generation**:
   - For each term from 2 to n, generate the next term by iterating through the current term and counting consecutive digits.
   - Use a while loop to traverse through the string, count the number of consecutive identical digits, and then append the count followed by the digit to the result.
   - Continue this process until the nth term is generated.

# Explanation
1. Initialize the sequence with "1" as the first term.
2. For each subsequent term up to n:
   - Initialize an empty result string.
   - Traverse the current term string, counting consecutive identical digits.
   - Append the count and the digit to the result string.
   - Update the current term to the newly generated result string.
3. Return the result string after generating the nth term.

# Complexity
- **Time complexity**: ***O(m * n)*** where ***m*** is the maximum length of the term and ***n*** is the number of terms to generate. Each term generation involves traversing the current term which can be up to length ***m***.
- **Space complexity**: ***O(m)*** for storing the current term.

# Code
```typescript
function countAndSay(n: number): string {
    let currentTerm = "1";
    
    for (let i = 1; i < n; i++) {
        let nextTerm = "";
        let count = 1;
        
        for (let j = 1; j < currentTerm.length; j++) {
            if (currentTerm[j] === currentTerm[j - 1]) {
                count++;
            } else {
                nextTerm += count.toString() + currentTerm[j - 1];
                count = 1;
            }
        }
        
        nextTerm += count.toString() + currentTerm[currentTerm.length - 1];
        currentTerm = nextTerm;
    }
    
    return currentTerm;
};

```