[837. New 21 Game](https://leetcode.com/problems/new-21-game/)

# Intuition

* Alice starts from **0 points** and keeps drawing until she reaches at least `k`.
* Each draw gives her a number between `1` and `maxPts`, uniformly random.
* Once Alice’s score is `>= k`, she **stops drawing**.
* We need the probability that her **final score ≤ n**.

So essentially, this is about **stopping at some point `s ≥ k`** and checking if `s ≤ n`.

---

# Approach

We’ll solve this with **DP and sliding window optimization**.
### 1. Define State
Let `dp[i]` = probability that Alice’s score ends up being **exactly `i`**.

* Base case: `dp[0] = 1` (she starts with 0).
* Transition: To get `dp[i]`, Alice could have come from any score `j` where
  `i - maxPts ≤ j < i` and `j < k` (since she only draws while < k).

So:

$$
dp[i] = \frac{dp[i-1] + dp[i-2] + \dots + dp[i-maxPts]}{maxPts}
$$

This is like averaging probabilities from the previous `maxPts` states, but only from those where Alice was still drawing.

### 2. Sliding Window Optimization
Instead of recalculating the sum each time:
* Maintain a **window sum** of the last `maxPts` valid probabilities.
* Update it as we move forward.

### 3. Final Answer
* Alice **stops once score ≥ k**.
* So we only care about scores `i` in the range `[k, n]`.
* Answer = sum of `dp[k] + dp[k+1] + ... + dp[n]`.

---

# Complexity

* **Time:** `O(n)` (we iterate up to `n` once, using sliding window updates).
* **Space:** `O(n)` (dp array), can be optimized to `O(1)` with rolling window.

---

# Code

```typescript
function new21Game(n: number, k: number, maxPts: number): number {
    if (k === 0 || n >= k + maxPts) return 1.0;

    const dp: number[] = new Array(n + 1).fill(0);
    dp[0] = 1.0;

    let windowSum = 1.0; // running sum of probabilities
    let result = 0.0;

    for (let i = 1; i <= n; i++) {
        dp[i] = windowSum / maxPts;

        if (i < k) {
            windowSum += dp[i]; // still can draw more
        } else {
            result += dp[i]; // stop at i
        }

        if (i - maxPts >= 0) {
            windowSum -= dp[i - maxPts]; // remove old value
        }
    }

    return result;
};

```

---

## Example Walkthrough

### Example: `n = 6, k = 1, maxPts = 10`

* Alice draws only **once** since `k = 1`.

* Each number from `1..10` is equally likely.

* If she draws `1,2,3,4,5,6` → she ends ≤ `6` (valid).

* If she draws `7,8,9,10` → she ends > `6` (invalid).

So probability = `6/10 = 0.6`. 

---

### Example: `n = 21, k = 17, maxPts = 10`

Here it’s trickier:

* Alice keeps drawing until at least `17`.
* Using DP:

  * Compute probabilities for each score.
  * Add up results for `[17..21]`.
* Answer ≈ `0.73278`. 

---

