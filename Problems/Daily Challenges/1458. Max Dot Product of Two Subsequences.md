[1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/)

# Intuition

You must pick **at least one pair** and the subsequences must have the **same length**. This blocks the usual “empty subsequence = 0” shortcut.
The decision at each position pair `(i, j)` is binary: either pair `nums1[i]` with `nums2[j]`, or skip one side. This is a classic 2D dynamic programming problem with a forced non-empty constraint.

**Key idea:**

Let `dp[i][j]` be the **maximum dot product** using subsequences from `nums1[0..i-1]` and `nums2[0..j-1]`, **with at least one pair chosen**.

---

# Approach

For each `(i, j)`:

1. Pair `nums1[i-1]` and `nums2[j-1]`

   * Either start fresh with just this pair
   * Or extend a previous subsequence

   ```
   take = nums1[i-1] * nums2[j-1] + max(0, dp[i-1][j-1])
   ```

2. Skip `nums1[i-1]`

   ```
   dp[i-1][j]
   ```

3. Skip `nums2[j-1]`

   ```
   dp[i][j-1]
   ```

**Transition:**

```
dp[i][j] = max(take, dp[i-1][j], dp[i][j-1])
```

**Initialization:**

All `dp` values start at `-∞` to enforce the “non-empty subsequence” rule.

The answer is `dp[n][m]`.

---

# Complexity

- **Time:** `O(n * m)`
- **Space:** `O(n * m)` (can be optimized to `O(m)` if needed)

---

# Code

```ts
function maxDotProduct(nums1: number[], nums2: number[]): number {
    const n = nums1.length;
    const m = nums2.length;

    const NEG_INF = -1e18;
    const dp: number[][] = Array.from({ length: n + 1 }, () =>
        Array(m + 1).fill(NEG_INF)
    );

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            const product = nums1[i - 1] * nums2[j - 1];

            const take = product + Math.max(0, dp[i - 1][j - 1]);
            const skip1 = dp[i - 1][j];
            const skip2 = dp[i][j - 1];

            dp[i][j] = Math.max(take, skip1, skip2);
        }
    }

    return dp[n][m];
};

```

---

# Example Walkthrough

**Example 1**

```
nums1 = [2,1,-2,5]
nums2 = [3,0,-6]
```

**Key matches:**

* Pair 2 × 3 = 6
* Pair -2 × -6 = 12

**DP evolution captures:**

* First positive pair gives 6
* Later pairing with (-2, -6) adds 12
* Total = 18

## Example 3 (edge case)

```
nums1 = [-1,-1]
nums2 = [1,1]
```

All products are negative.

DP forces at least one pairing:
* Best is -1 × 1 = -1

**Output:** `-1`

---

## This DP correctly handles:

* Mixed signs
* Forced non-empty subsequences
* Skipping vs pairing tradeoffs
