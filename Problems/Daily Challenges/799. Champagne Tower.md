[799. Champagne Tower](https://leetcode.com/problems/champagne-tower/)

# Intuition

Each glass can contain at most **1 cup**.
Any overflow from a glass is split **equally** to the two glasses directly below it.

Therefore the pyramid behaves like a **flow simulation** where:

```
overflow = max(0, amount_in_glass − 1)
left_child += overflow / 2
right_child += overflow / 2
```

Only rows up to `query_row` must be simulated because deeper rows do not affect the queried glass.

---

# Approach

1. Create a 2-D array `dp[row][glass]` storing the champagne amount reaching each glass.
2. Initialize:

   ```
   dp[0][0] = poured
   ```
3. For each row `r` from `0` to `query_row − 1`:

   * For each glass `c`:

     * If `dp[r][c] > 1`, compute overflow and distribute to next row.
4. The answer is:

   ```
   min(1, dp[query_row][query_glass])
   ```

Only up to 100 rows exist, so direct simulation is efficient.

---

# Complexity

- **Time:**  O(100^2) ≈ O(1)
- **Space:** O(100^2)

---

# Code

```ts
function champagneTower(
    poured: number,
    query_row: number,
    query_glass: number
): number {

    const dp: number[][] = Array.from({ length: 101 }, () =>
        new Array(101).fill(0)
    );

    dp[0][0] = poured;

    for (let r = 0; r < query_row; r++) {
        for (let c = 0; c <= r; c++) {

            if (dp[r][c] > 1) {
                const overflow = (dp[r][c] - 1) / 2;
                dp[r + 1][c] += overflow;
                dp[r + 1][c + 1] += overflow;
            }
        }
    }

    return Math.min(1, dp[query_row][query_glass]);
};

```

---

# Example Walkthrough

**Input:**

```
poured = 2
query_row = 1
query_glass = 1
```

Row 0:

```
[2]
```

Overflow:

```
(2−1)/2 = 0.5
```

Row 1 receives:

```
[0.5, 0.5]
```

Glass `(1,1)` contains `0.5`.

**Output:**

```
0.5
```

---
