[966. Vowel Spellchecker](https://leetcode.com/problems/vowel-spellchecker/)

# Intuition

We need to implement a spellchecker with 3 levels of matching priority:

1. **Exact match** (case-sensitive) → return directly.
2. **Case-insensitive match** → return the *first* matching word from the wordlist with original casing preserved.
3. **Vowel error match** → treat vowels as wildcards (all vowels considered the same, e.g., "a" → "e" → "i" → "o" → "u"). Match ignoring case, and return the *first* occurrence from the wordlist.

If none match, return `""`.

To do this efficiently, we can **preprocess the wordlist** into three hash maps:

* **Exact set** → for direct lookup.
* **Case-insensitive map** → lowercase word → first original word.
* **Vowel-error map** → lowercase word with vowels replaced by `"*"` → first original word.

---

# Approach

1. **Preprocessing** wordlist:

   * Store exact words in a `Set`.
   * Store lowercase → original mapping in a `Map` (if first occurrence).
   * Convert word to its *devoweled* version (replace all vowels with `*`), store in a `Map` (if first occurrence).

2. **Processing each query**:

   * If query exists in `exact set`, return it directly.
   * Else if lowercase(query) exists in `case map`, return mapped word.
   * Else if devoweled(lowercase(query)) exists in `vowel map`, return mapped word.
   * Otherwise return `""`.

3. Return results as an array.

---

# Complexity

* **Preprocessing:**

  * O(W \* L), where W = number of words in `wordlist`, L = average word length.
* **Query Processing:**

  * O(Q \* L), where Q = number of queries.
* Hash lookups are O(1).
* Overall: **O((W + Q) \* L)**, efficient for given constraints.

---

# Code

```typescript
function spellchecker(wordlist: string[], queries: string[]): string[] {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
    
    // Helper: replace all vowels with '*'
    const devowel = (word: string): string => {
        return word.toLowerCase().replace(/[aeiou]/g, '*');
    };

    // Preprocessing
    const exactWords = new Set(wordlist);  // exact match
    const caseMap = new Map<string, string>();  // lowercase → first original
    const vowelMap = new Map<string, string>(); // devoweled → first original

    for (const word of wordlist) {
        const lower = word.toLowerCase();
        const dev = devowel(word);

        if (!caseMap.has(lower)) {
            caseMap.set(lower, word);
        }
        if (!vowelMap.has(dev)) {
            vowelMap.set(dev, word);
        }
    }

    // Answer queries
    const result: string[] = [];
    for (const query of queries) {
        if (exactWords.has(query)) {
            result.push(query);
        } else {
            const lower = query.toLowerCase();
            const dev = devowel(query);

            if (caseMap.has(lower)) {
                result.push(caseMap.get(lower)!);
            } else if (vowelMap.has(dev)) {
                result.push(vowelMap.get(dev)!);
            } else {
                result.push("");
            }
        }
    }

    return result;
};

```

---

## Example Walkthrough

### Example 1

```
wordlist = ["KiTe","kite","hare","Hare"]
queries  = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]
```

* **Preprocessing**

  * exactWords = { "KiTe", "kite", "hare", "Hare" }
  * caseMap = { "kite" → "KiTe", "hare" → "hare" }  (first occurrence stored)
  * vowelMap = { "k*t*" → "KiTe", "h*r*" → "hare" }

* **Queries**

  * "kite" → exact match? no, lowercase "kite" in caseMap → "KiTe"
  * "Kite" → lowercase "kite" → "KiTe"
  * "KiTe" → exact match → "KiTe"
  * "Hare" → exact match → "Hare"
  * "HARE" → lowercase "hare" → "hare"
  * "Hear" → devowel "h\*\*r" not in vowelMap → ""
  * "hear" → same as above → ""
  * "keti" → devowel "k*t*" → "KiTe"
  * "keet" → devowel "k\*\*t" → ""
  * "keto" → devowel "k*t*" → "KiTe"

Output:
`["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]`

---
