[3186. Maximum Total Damage With Spell Casting](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/)

# Intuition

Each spell has a **damage value** `power[i]`.

If you choose to **cast** a spell with damage `x`,
you **cannot** cast any spell with damage:

```
x - 2, x - 1, x + 1, x + 2
```

So choosing damage `x` **blocks** a range of 5 consecutive damage values (`x-2` to `x+2`).

We want to **maximize total damage**.

## Key Observation

* The actual indices do **not** matter.
* Only **unique damage values** and their **total contribution** matter.

Let’s group spells by their damage values.

Example:

```
power = [1,1,3,4]
→ damageMap = {1: 2, 3: 3, 4: 4}
```

If we choose all spells with damage = 3, total contribution = `3 * 1 = 3`.

Now it becomes a **dynamic programming over sorted damage values** problem.

---

# Approach

### Step 1: Build damage-to-total map

Count total contribution for each damage value:

```
damageMap[x] = sum of all x's in power = count[x] * x
```

### Step 2: Sort unique damage values

Let `vals` be the sorted unique damages.

### Step 3: Dynamic Programming Transition

We define:

```
dp[i] = maximum total damage considering up to vals[i]
```

For each damage value `vals[i]`:

* If `vals[i]` is within **2** of `vals[i-1]`, then we can’t take both.
  → skip `vals[i-1]` or take `vals[i]`.

* If they’re **more than 2 apart**, no conflict — we can take both.

Transition:

```
if vals[i] - vals[i-1] <= 2:
    dp[i] = max(dp[i-1], (dp[i-2] if i>=2 else 0) + damageMap[vals[i]])
else:
    dp[i] = dp[i-1] + damageMap[vals[i]]
```

Finally, `dp[n-1]` gives the answer.

---

# Time and Space Complexity

* **Time:** O(n log n) (sorting)
* **Space:** O(n) (map + dp)

---

# Code

```typescript
function maxTotalDamage(power: number[]): number {
    const damageMap = new Map<number, number>();

    // Step 1: Build total contribution per damage
    for (const p of power) {
        damageMap.set(p, (damageMap.get(p) || 0) + p);
    }

    // Step 2: Sort unique damage values
    const vals = Array.from(damageMap.keys()).sort((a, b) => a - b);
    const n = vals.length;
    if (n === 0) return 0;

    // Step 3: DP
    const dp = new Array(n).fill(0);
    dp[0] = damageMap.get(vals[0])!;

    for (let i = 1; i < n; i++) {
        const curDamage = damageMap.get(vals[i])!;
        if (vals[i] - vals[i - 1] <= 2) {
            dp[i] = Math.max(dp[i - 1], (i >= 2 ? dp[i - 2] : 0) + curDamage);
        } else {
            dp[i] = dp[i - 1] + curDamage;
        }
    }

    return dp[n - 1];
};

```

---

## Example Walkthrough

### Example 1

```
power = [1,1,3,4]
```

Step 1: `damageMap = {1: 2, 3: 3, 4: 4}`
Step 2: `vals = [1,3,4]`

| i | vals[i] | damageMap[vals[i]] | Relation             | dp[i] Calculation         |
| - | ------- | ------------------ | -------------------- | ------------------------- |
| 0 | 1       | 2                  | -                    | dp[0] = 2                 |
| 1 | 3       | 3                  | 3 - 1 = 2 (conflict) | dp[1] = max(2, 0 + 3) = 3 |
| 2 | 4       | 4                  | 4 - 3 = 1 (conflict) | dp[2] = max(3, 2 + 4) = 6 |

**Answer = 6**

Matches expected.


### Example 2

```
power = [7,1,6,6]
```

Step 1: `damageMap = {1: 1, 6: 12, 7: 7}`
Step 2: `vals = [1,6,7]`

| i | vals[i] | damageMap | Relation            | dp[i]               |
| - | ------- | --------- | ------------------- | ------------------- |
| 0 | 1       | 1         | -                   | 1                   |
| 1 | 6       | 12        | 6-1=5 (no conflict) | 1 + 12 = 13         |
| 2 | 7       | 7         | 7-6=1 (conflict)    | max(13, 1 + 7) = 13 |

**Answer = 13**
