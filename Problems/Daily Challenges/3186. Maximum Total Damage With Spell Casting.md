[3186. Maximum Total Damage With Spell Casting](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/)

# Intuition

Group spells by their damage value and consider the **total contribution** for each damage value:

```
contrib[x] = x * (count of spells with damage x)
```

Sort the unique damage values into `vals[]`. Choosing damage `vals[i]` forbids choosing any `vals[j]` with `|vals[i] - vals[j]| ≤ 2`. So if we choose `vals[i]`, we may combine it only with the best solution that uses damage values strictly `< vals[i] - 2`. That means we must look back to the last index `p` where `vals[p] ≤ vals[i] - 3`.

Then:

```
dp[i] = max(dp[i-1], (p >= 0 ? dp[p] : 0) + contrib[vals[i]])
```

This guarantees we never include forbidden values.

---
# Approach

### Step 1: Build damage-to-total map

Count total contribution for each damage value:

`damageMap[x] = sum of all x's in power = count[x] * x`

### Step 2: Sort unique damage values

Let `vals` be the sorted unique damages.

### Step 3: Dynamic Programming Transition

We define:
`dp[i] = maximum total damage considering up to vals[i]`

For each damage value `vals[i]`:

- If `vals[i]` is within **2** of `vals[i-1]`, then we can’t take both.  
    → skip `vals[i-1]` or take `vals[i]`.
    
- If they’re **more than 2 apart**, no conflict — we can take both.
    

Transition:

`if vals[i] - vals[i-1] <= 2:     dp[i] = max(dp[i-1], (dp[i-2] if i>=2 else 0) + damageMap[vals[i]]) else:     dp[i] = dp[i-1] + damageMap[vals[i]]`

Finally, `dp[n-1]` gives the answer.

---

# Complexity

* Sorting unique damage values: `O(U log U)` where `U` is number of unique damage values (≤ `power.length`).
* Building `contrib` map: `O(n)`.
* DP with binary search for previous compatible index: overall `O(U log U)` (binary search per `i`).
* Space: `O(U)`.

---

# Code

```ts
function maxTotalDamage(power: number[]): number {
    // Build total contribution per damage value
    const contrib = new Map<number, number>();
    for (const p of power) {
        contrib.set(p, (contrib.get(p) || 0) + p);
    }

    // Sorted unique damage values
    const vals = Array.from(contrib.keys()).sort((a, b) => a - b);
    const m = vals.length;
    if (m === 0) return 0;

    const dp = new Array<number>(m).fill(0);
    dp[0] = contrib.get(vals[0])!;

    for (let i = 1; i < m; i++) {
        const v = vals[i];
        const take = contrib.get(v)!;

        // Find the largest index p < i such that vals[p] <= v - 3
        // i.e., vals[i] - vals[p] > 2 => no conflict
        let l = 0, r = i - 1, p = -1;
        while (l <= r) {
            const mid = (l + r) >> 1;
            if (vals[mid] <= v - 3) {
                p = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        const takeVal = (p >= 0 ? dp[p] : 0) + take;
        dp[i] = Math.max(dp[i - 1], takeVal);
    }

    return dp[m - 1];
};

```

---
## Example Walkthrough

Using the corrected approach:

vals and contrib:

```
vals:    [2, 3, 5, 7, 8, 9, 10]
contrib: [4, 3, 5, 7, 8, 18, 20]
```

Compute dp:

* i=0 (2): dp0 = 4
* i=1 (3): p = index ≤ 0? 3-3=0 so vals[0]=2 >0? wait find vals[mid] ≤ 0 -> none => p=-1 => take=3 dp1=max(4,3)=4
* i=2 (5): find p with vals[p] ≤ 2 => p=0 => take = dp0 + 5 = 4+5 =9 => dp2 = max(dp1=4,9)=9
* i=3 (7): find p with vals[p] ≤ 4 => p=1? vals[1]=3 ≤4 -> p=1 => take = dp1 + 7 = 4+7=11 => dp3 = max(9,11)=11
* i=4 (8): find p with vals[p] ≤ 5 => p=2 => take = dp2 + 8 = 9+8 =17 => dp4 = max(11,17)=17
* i=5 (9): find p with vals[p] ≤ 6 => p=2 (vals[2]=5) => take = dp2 + 18 = 9+18=27 => dp5=max(17,27)=27
* i=6 (10): find p with vals[p] ≤ 7 => p=3 => take = dp3 + 20 = 11+20=31 => dp6 = max(27,31)=31

Answer = 31.

---

