[2211. Count Collisions on a Road](https://leetcode.com/problems/count-collisions-on-a-road/)

## Problem Understanding

**Trimming the problem down:** only cars that are inside the interaction zone matter. Leading `'L'` cars and trailing `'R'` cars never collide. Everything between them ends up stopped after collisions.

## Key observation:
Inside the trimmed segment, every `'R'` and `'L'` will contribute collisions. `'R'` meets `'L'` → both become stationary → count `2` for that encounter. Any later `'R'` or `'L'` that hits a stationary car contributes `1`.

**Reformulated rule:**

1. Remove leading `'L'` characters.
2. Remove trailing `'R'` characters.
3. Count every remaining character that isn’t `'S'`.

**Justification:** after trimming, every `'R'` will eventually collide, and every `'L'` will eventually collide. `'S'` cars just act as sinks and don’t increase the count themselves, but turn future movements into single collisions.

---

# Approach

1. Find first index `i` where `directions[i] != 'L'`.
2. Find last index `j` where `directions[j] != 'R'`.
3. If `i > j`, return `0`.
4. Count characters from index `i` to `j` that are `'R'` or `'L'`.

---

# Complexity

* Time: `O(n)`
* Space: `O(1)`

---

# Code

```ts
function countCollisions(directions: string): number {
    const n = directions.length;
    let left = 0;
    let right = n - 1;

    while (left < n && directions[left] === 'L') left++;
    while (right >= 0 && directions[right] === 'R') right--;

    if (left > right) return 0;

    let collisions = 0;
    for (let i = left; i <= right; i++) {
        if (directions[i] !== 'S') collisions++;
    }

    return collisions;
}
```

---

# Example Walkthrough

Input:

```
"RLRSLL"
```

Trim:

* Left side: no leading `'L'`.
* Right side: last char `'L'`, no trimming.

Count non‐stationary between full range:

```
R L R S L L
^ ^ ^   ^ ^
5 moving cars → all eventually collide.
```

Output:

```
5
```
