[1912. Design Movie Rental System](https://leetcode.com/problems/design-movie-rental-system/)

# Intuition

We need to simulate a renting system with **efficient operations**:

1. **Search(movie):**

   * Find up to 5 shops with an *unrented copy* of a given movie.
   * Shops sorted by `(price ASC, shop ASC)`.

2. **Rent(shop, movie):**

   * Mark the movie at that shop as rented.

3. **Drop(shop, movie):**

   * Mark the movie as unrented again.

4. **Report():**

   * Find up to 5 cheapest *currently rented* movies, sorted by `(price ASC, shop ASC, movie ASC)`.

Constraints are large: up to `10^5` entries and operations.
We need data structures that allow:

* Fast lookups (`O(log n)` or better).
* Efficient maintenance of sorted order for both unrented and rented states.

---

# Approach

We’ll use a mix of **maps, sets, and sorted arrays**:

1. **Price Map**

   * `Map<string, number>`: maps `"shop#movie"` → price.
   * Used to quickly lookup the price for any (shop, movie) pair.

2. **Movie → Shops**

   * `Map<number, Array<[price, shop]>>`: for each movie, store all its shops sorted by `(price, shop)`.
   * Used in `search(movie)` to return the first 5 unrented shops.
   * We don’t modify this array (kept static, since availability changes with a rented set check).

3. **Rented Set**

   * `Set<string>` of rented keys `"shop#movie"`.
   * Used to check availability (for both search and drop).

4. **Report()**

   * Gather all rented movies into an array `[price, shop, movie]`.
   * Sort by `(price, shop, movie)` and take top 5.
   * This is `O(r log r)` in the worst case, but given constraints (`10^5`), this is acceptable.

---

# Complexity

* **Initialization:** `O(E log E)` where `E` is number of entries (sorting per movie).
* **Search(movie):** `O(k)` where `k` is number of shops for that movie (we break after 5, so effectively `O(5)` worst-case).
* **Rent/Drop:** `O(1)` (just update set).
* **Report:** `O(R log R)` where `R` is number of currently rented movies. At most `10^5`, which is fine since calls are limited.

---

# Code

```ts
class MovieRentingSystem {
    private price: Map<string, number>;                     // (shop#movie) -> price
    private movieShops: Map<number, Array<[number, number]>>; // movie -> [price, shop] sorted
    private rented: Set<string>;                            // rented movies

    private encode(shop: number, movie: number): string {
        return `${shop}#${movie}`;
    }

    constructor(n: number, entries: number[][]) {
        this.price = new Map();
        this.movieShops = new Map();
        this.rented = new Set();

        // Populate price map & movie->shops
        for (const [shop, movie, p] of entries) {
            const key = this.encode(shop, movie);
            this.price.set(key, p);
            if (!this.movieShops.has(movie)) this.movieShops.set(movie, []);
            this.movieShops.get(movie)!.push([p, shop]);
        }

        // Sort each movie’s shops list by (price, shop)
        for (const arr of this.movieShops.values()) {
            arr.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));
        }
    }

    search(movie: number): number[] {
        const res: number[] = [];
        const arr = this.movieShops.get(movie) || [];
        for (const [p, shop] of arr) {
            if (!this.rented.has(this.encode(shop, movie))) {
                res.push(shop);
                if (res.length === 5) break;
            }
        }
        return res;
    }

    rent(shop: number, movie: number): void {
        this.rented.add(this.encode(shop, movie));
    }

    drop(shop: number, movie: number): void {
        this.rented.delete(this.encode(shop, movie));
    }

    report(): number[][] {
        const tmp: Array<[number, number, number]> = []; // [price, shop, movie]
        for (const key of this.rented) {
            const [shopStr, movieStr] = key.split('#');
            const shop = Number(shopStr);
            const movie = Number(movieStr);
            const p = this.price.get(key)!;
            tmp.push([p, shop, movie]);
        }
        tmp.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]) || (a[2] - b[2]));

        const res: number[][] = [];
        for (let i = 0; i < tmp.length && i < 5; i++) {
            res.push([tmp[i][1], tmp[i][2]]);
        }
        return res;
    }
}

```

---

## Example Walkthrough

Input:

```ts
["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
```

1. `MovieRentingSystem(3, entries)`
   Initialize with 3 shops and given movie prices.

2. `search(1)` → `[1, 0, 2]`

   * Movie 1 is at shops (1, 4), (0, 5), (2, 5). Sorted → `[1, 0, 2]`.

3. `rent(0, 1)`

   * Mark movie 1 at shop 0 as rented.

4. `rent(1, 2)`

   * Mark movie 2 at shop 1 as rented.

5. `report()` → `[[0, 1], [1, 2]]`

   * Currently rented: (0,1 price=5), (1,2 price=7). Sorted by price → `[[0, 1], [1, 2]]`.

6. `drop(1, 2)`

   * Movie 2 at shop 1 is no longer rented.

7. `search(2)` → `[0, 1]`

   * Movie 2 is at shops 0 (price=6) and 1 (price=7). Both available now.

Output:

```
[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]
```

---

