[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)

# Intuition

This is a **0/1 Knapsack** variant with **two constraints** — count of `0`s (`m`) and count of `1`s (`n`).
Each string consumes a certain number of `0`s and `1`s, and gives a profit of `+1` if we include it.
We want to find the **maximum number of strings** (max subset size) such that:

* total zeros used ≤ `m`
* total ones used ≤ `n`.

We can solve it using **Dynamic Programming (DP)** similar to a 2D knapsack table.

---

# Approach

1. **Count zeros and ones per string.**

   * For each string `s`, calculate `(zeros, ones)`.

2. **2D DP array definition**

   * Let `dp[i][j]` represent the **maximum subset size** we can form with at most `i` zeros and `j` ones.
   * Initialize all `dp[i][j] = 0`.

3. **Transition**

   * For each string `(zeroCount, oneCount)`, update the DP table **in reverse order** (to avoid reuse of same item):

     ```
     for i from m down to zeroCount:
       for j from n down to oneCount:
         dp[i][j] = max(dp[i][j], dp[i - zeroCount][j - oneCount] + 1)
     ```

4. **Answer**

   * The final result is `dp[m][n]`.

---

# Complexity Analysis 

* **Time Complexity** `O(len(strs) * m * n)`
  → For each string, we update a DP table of size `m × n`.

- **Space Complexity:** `O(m * n)`

---

# Code

```typescript
function findMaxForm(strs: string[], m: number, n: number): number {
    // Initialize DP table
    const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    for (const str of strs) {
        // Count zeros and ones in current string
        let zeros = 0, ones = 0;
        for (const ch of str) {
            if (ch === '0') zeros++;
            else ones++;
        }

        // Traverse DP table in reverse order to avoid overwriting previous state
        for (let i = m; i >= zeros; i--) {
            for (let j = n; j >= ones; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }

    return dp[m][n];
};

```

---

## Example Walkthrough

**Input:**
`strs = ["10","0001","111001","1","0"], m = 5, n = 3`

| String   | Zeros | Ones |
| -------- | ----- | ---- |
| "10"     | 1     | 1    |
| "0001"   | 3     | 1    |
| "111001" | 2     | 4    |
| "1"      | 0     | 1    |
| "0"      | 1     | 0    |

Processing:

* Start with `dp` all zeros.
* Add `"10"` → use 1 zero, 1 one → dp[1][1] = 1
* Add `"0001"` → use 3 zeros, 1 one → dp[4][2] = 2 (by combining with "10")
* Skip `"111001"` since needs 4 ones > n=3.
* Add `"1"` and `"0"` → can form up to subset size = 4.

**Output: 4**

---
