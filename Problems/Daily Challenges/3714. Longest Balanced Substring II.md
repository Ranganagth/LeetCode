[3714. Longest Balanced Substring II](https://leetcode.com/problems/longest-balanced-substring-ii/)

# Intuition

A substring is **balanced** if every **distinct character** appearing in it has the **same frequency**.

Since the alphabet is restricted to `{a, b, c}`, a substring can be balanced in **three possible forms**:

1. Contains only **one character**
   → always balanced
   → longest consecutive run

2. Contains **exactly two characters**
   → their counts must be equal
   → treat as longest subarray where

   ```
   count(x) − count(y) = 0
   ```

3. Contains **all three characters**
   → counts must satisfy

   ```
   count(a) = count(b) = count(c)
   ```

   which is equivalent to:

   ```
   count(a) − count(b) = 0
   count(b) − count(c) = 0
   ```

   Using prefix differences allows finding longest substring where the pair
   `(d1 = a-b, d2 = b-c)` repeats.

The final answer is the maximum among:

* longest single-character segment
* best substring for each pair of characters
* best substring for all three characters

This yields an **O(n)** solution.

---

# Approach

### Step 1 — single character segments

Scan runs of identical letters and record longest run.

### Step 2 — two-character balance

For each pair `(x,y)`:

* consider only segments containing these letters
* track prefix difference
* longest segment where difference repeats gives balanced substring

### Step 3 — three-character balance

Maintain prefix counts `(ca,cb,cc)` and store first occurrence of pair:

```
(d1 = ca-cb, d2 = cb-cc)
```

If the pair appears again, substring between them is balanced.

---

# Complexity

- **Time:**  O(n)
- **Space:** O(n)

---

# Code

```ts
function longestBalanced(s: string): number {
    const n = s.length;
    let ans = 0;

    // ---------- 1. single char runs ----------
    for (let i = 0; i < n;) {
        let j = i;
        while (j < n && s[j] === s[i]) j++;
        ans = Math.max(ans, j - i);
        i = j;
    }

    // ---------- 2. two-character cases ----------
    ans = Math.max(ans, twoChars(s, "a", "b"));
    ans = Math.max(ans, twoChars(s, "a", "c"));
    ans = Math.max(ans, twoChars(s, "b", "c"));

    // ---------- 3. three-character case ----------
    const map = new Map<string, number>();
    map.set("0,0", -1);

    let ca = 0, cb = 0, cc = 0;

    for (let i = 0; i < n; i++) {
        if (s[i] === "a") ca++;
        else if (s[i] === "b") cb++;
        else cc++;

        const d1 = ca - cb;
        const d2 = cb - cc;
        const key = `${d1},${d2}`;

        if (map.has(key))
            ans = Math.max(ans, i - map.get(key)!);
        else
            map.set(key, i);
    }

    return ans;
}

function twoChars(s: string, x: string, y: string): number {
    const n = s.length;
    let best = 0;

    const first = new Map<number, number>();

    for (let i = 0; i < n;) {
        if (s[i] !== x && s[i] !== y) {
            i++;
            continue;
        }

        first.clear();
        first.set(0, i - 1);

        let diff = 0;
        let j = i;

        while (j < n && (s[j] === x || s[j] === y)) {
            diff += (s[j] === x ? 1 : -1);

            if (first.has(diff))
                best = Math.max(best, j - first.get(diff)!);
            else
                first.set(diff, j);

            j++;
        }
        i = j;
    }
    return best;
};

```

---

# Example Walkthrough

### Input

```
s = "abbac"
```

**Single runs**

```
"a" length=1
"bb" length=2
"a" length=1
"c" length=1
→ best = 2
```

**Two-char case (a,b)**
Balanced substring:

```
"abba" length = 4
```

**Three-char case**
No longer substring satisfies equal counts.

Final answer:

```
4
```
