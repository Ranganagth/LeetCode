[3625. Count Number of Trapezoids II](https://leetcode.com/problems/count-number-of-trapezoids-ii/)

## Problem Statement

A trapezoid exists if and only if among the four chosen points there are **two distinct non-overlapping line segments that share the same slope**.
The shape must be convex and cannot collapse into a parallelogram counted multiple times.
We only need slope relationships of all possible point pairs.

---

# Intuition

Four points form a trapezoid when:

* You can pick two **different line segments** with the **same slope**
* Those segments are **not collinear**
* Those segments do **not share the midpoint** (removes parallelograms)

So the problem becomes:

1. Compute slope for every pair of points.
2. Group segments by slope.
3. For each slope group: count how many unordered pairs of segments you can select.
4. Remove invalid shapes:

   * Segments lying on the same infinite line (same slope + same intercept)
   * Parallelograms: two segments with same slope and same midpoint

Final count = valid combinations across all slope groups
− collinear combinations
− parallelogram combinations.

---

# Approach

1. Iterate through every pair `(i,j)` and compute:

   * Slope `k`
   * Line intercept `b` (or marker for vertical lines)
   * Midpoint signature `(x1+x2, y1+y2)` to detect parallelograms

2. Maintain:

   * `slopeToIntercept`: slope → list of intercepts
     (used to remove collinear pairs)
   * `midToSlope`: midpoint → list of slopes
     (used to remove parallelograms)

3. First pass: count all segment pairs with same slope.

4. Second pass: subtract pairs belonging to same slope and same line (collinear).

5. Third pass: subtract parallelogram configurations.

---

# Complexity

| Step             | Complexity  |
| ---------------- | ----------- |
| Pair generation  | O(n²)       |
| Hash aggregation | O(n²)       |
| Final counting   | O(n²)       |
| Memory           | O(n²) worst |

Given `n ≤ 500`, worst case ~125k pairs — acceptable.

---

# Code

```ts
function countTrapezoids(points: number[][]): number {
    const n = points.length;
    const INF = 1e9 + 7;

    const slopeToIntercept = new Map<number, number[]>();
    const midToSlope = new Map<number, number[]>();
    let result = 0;

    for (let i = 0; i < n; i++) {
        const [x1, y1] = points[i];
        for (let j = i + 1; j < n; j++) {
            const [x2, y2] = points[j];
            const dx = x1 - x2;
            const dy = y1 - y2;

            let k: number;
            let b: number;

            if (x1 === x2) {
                k = INF;
                b = x1;
            } else {
                k = (y2 - y1) / (x2 - x1);
                b = (y1 * dx - x1 * dy) / dx;
            }

            const mid = (x1 + x2) * 10000 + (y1 + y2);

            if (!slopeToIntercept.has(k)) slopeToIntercept.set(k, []);
            slopeToIntercept.get(k)!.push(b);

            if (!midToSlope.has(mid)) midToSlope.set(mid, []);
            midToSlope.get(mid)!.push(k);
        }
    }

    for (const list of slopeToIntercept.values()) {
        if (list.length < 2) continue;

        const freq = new Map<number, number>();
        let sum = 0;

        for (const b of list) {
            const count = (freq.get(b) || 0) + 1;
            freq.set(b, count);
        }

        for (const count of freq.values()) {
            result += sum * count;
            sum += count;
        }
    }

    for (const list of midToSlope.values()) {
        if (list.length < 2) continue;

        const freq = new Map<number, number>();
        let sum = 0;

        for (const k of list) {
            const count = (freq.get(k) || 0) + 1;
            freq.set(k, count);
        }

        for (const count of freq.values()) {
            result -= sum * count;
            sum += count;
        }
    }

    return result;
};

```

---

# Example Walkthrough

Input:

```
[[-3,2],[3,0],[2,3],[3,2],[2,-3]]
```

All segment slopes generated → group by slope.

* For slope value appearing ≥2 times:

  * Count combinations of selecting two segments → contributes to trapezoids.
* Intercept grouping removes degenerate collinear cases.
* Midpoint grouping removes parallelograms.

Final count:

```
2
```

---
