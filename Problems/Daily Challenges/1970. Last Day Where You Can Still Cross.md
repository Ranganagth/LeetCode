[1970. Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/)

# Intuition

The grid starts entirely walkable, and each day another cell becomes water. Once a full **top-to-bottom path disappears**, it never reappears.
So the answer is the **latest day such a path still exists**.

**Key leverage:**
Instead of simulating forward (land → water), think **backward (water → land)** or use **binary search** on the day.

Best approach here: **Binary search + BFS/DFS**.

* If crossing is possible on day `d`, then it is also possible on all days `< d`.
* If crossing is impossible on day `d`, it stays impossible for all days `> d`.

This monotonic property makes binary search valid.

---

# Approach

Binary search day range:

1. mid = candidate day
2. Build grid where first `mid` cells in `cells` are water.
3. Check whether any path exists from **top row to bottom row** through land:

   * Start BFS/DFS from every land cell in top row
   * Move only on land
4. If path exists → move right (search later days)
   If not → move left (search earlier days)

Return the last day with a valid path.

---

# Complexity

Let `R = row`, `C = col`, `N = R*C`.

* Building grid each check: `O(N)`
* BFS per check: `O(N)`
* Binary search steps: `O(log N)`

- **Total:** *O(N log N)*
- **Space:** *O(N)*

---

# Code

```ts
function latestDayToCross(row: number, col: number, cells: number[][]): number {
    let left = 1, right = cells.length, ans = 0;

    const canCross = (day: number): boolean => {
        const grid = Array.from({ length: row }, () => Array(col).fill(0));

        // mark flooded up to this day
        for (let i = 0; i < day; i++) {
            const [r, c] = cells[i];
            grid[r - 1][c - 1] = 1;
        }

        const q: [number, number][] = [];
        const seen = Array.from({ length: row }, () => Array(col).fill(false));

        // push all land cells in top row
        for (let c = 0; c < col; c++) {
            if (grid[0][c] === 0) {
                q.push([0, c]);
                seen[0][c] = true;
            }
        }

        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

        while (q.length) {
            const [r0, c0] = q.shift()!;
            if (r0 === row - 1) return true; // reached bottom

            for (const [dr, dc] of dirs) {
                const nr = r0 + dr, nc = c0 + dc;
                if (
                    nr >= 0 && nr < row &&
                    nc >= 0 && nc < col &&
                    !seen[nr][nc] &&
                    grid[nr][nc] === 0
                ) {
                    seen[nr][nc] = true;
                    q.push([nr, nc]);
                }
            }
        }

        return false;
    };

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (canCross(mid)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return ans;
};

```

---

# Example walkthrough

row = 2, col = 2
cells = [[1,1],[2,1],[1,2],[2,2]]

Day simulation via binary search checks:

* Day 2 grid:

  ```
  1 0
  1 0
  ```

  Path exists: top-right → bottom-right. Valid.

* Day 3 grid:

  ```
  1 1
  1 0
  ```

  No path top → bottom. Invalid.

The last valid day = **2**.

---
