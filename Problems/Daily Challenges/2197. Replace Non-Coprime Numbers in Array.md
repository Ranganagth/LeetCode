[2197. Replace Non-Coprime Numbers in Array](https://leetcode.com/problems/replace-non-coprime-numbers-in-array/)

# Intuition

We need to count how many words in `text` can be typed **without using any broken letters**.

* If a word contains even **one broken letter**, it cannot be typed.
* If a word contains **no broken letters**, it can be typed.

So, we just:

1. Split the sentence into words.
2. Check each word letter by letter.
3. If none of its characters are in `brokenLetters`, increase the counter.

---

# Approach

1. Convert `brokenLetters` into a `Set` for O(1) lookup.
2. Split `text` into words.
3. For each word:

   * Check every character against the broken set.
   * If the word contains no broken character, count it.
4. Return the count.

---

# Complexity

* Let `n = text.length` and `m = brokenLetters.length`.
* Creating the set: **O(m)**
* Checking all words: **O(n)** (each letter checked once).
* Overall: **O(n + m)**, very efficient.

---

# Code

```typescript
function canBeTypedWords(text: string, brokenLetters: string): number {
    const brokenSet = new Set(brokenLetters);
    const words = text.split(" ");
    let count = 0;

    for (const word of words) {
        let valid = true;
        for (const ch of word) {
            if (brokenSet.has(ch)) {
                valid = false;
                break;
            }
        }
        if (valid) count++;
    }

    return count;
}
```

---

## Example Walkthrough

### Example 1

```
text = "hello world", brokenLetters = "ad"
brokenSet = { 'a', 'd' }

Words:
- "hello" → letters: h,e,l,l,o → none are in {a,d} → valid
- "world" → letters: w,o,r,l,d → 'd' is broken → invalid

Result = 1
```

### Example 2

```
text = "leet code", brokenLetters = "lt"
brokenSet = { 'l','t' }

Words:
- "leet" → contains 'l','t' → invalid
- "code" → no l or t → valid

Result = 1
```

### Example 3

```
text = "leet code", brokenLetters = "e"
brokenSet = { 'e' }

Words:
- "leet" → contains 'e' → invalid
- "code" → contains 'e' → invalid

Result = 0
```

---
