[3542. Minimum Operations to Convert All Elements to Zero](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/)

# Intuition

* One operation selects a contiguous subarray and sets to `0` all positions whose value equals the **minimum** of that subarray.

* If we choose a segment that contains several occurrences of its minimum value, **all** those occurrences are zeroed in **one** operation.

* After removing those minima, the segment splits into smaller segments (gaps between the removed indices) and we repeat recursively.

* For any segment of strictly positive numbers, the minimal operations needed are:

$$operations(segment) = min( count_nonzero_in_segment, 1 + sum( operations(child_segment_i) ) )$$
  
  * `count_nonzero_in_segment`: the worst-case option — remove each element individually (choose subarray length 1 each time).
  * `1 + Σ(child_ops)`: remove the minimum value occurrences in one operation, then solve each resulting child segment recursively.

* To make recursion efficient on up to `1e5` elements, we:

  * Precompute a *sparse table* to query the index of the minimum value on any interval in **O(1)**.
  * For a given minimum value `m`, we maintain a sorted list of all indices where `nums[i] == m`. That allows us to find all positions of `m` inside `[l,r]` quickly via binary search and iterate them to build child ranges.

* Important invariant: we only call recursion on segments that contain **no zeros** (initially split the array by zeros). That ensures the minimum returned by RMQ is always a positive number and we won't accidentally "remove" zeros.

---

# Complexity

* Preprocessing sparse table: `O(n log n)`.
* Each index is processed (removed as a minimum) exactly once across recursion, and each RMQ is `O(1)`; therefore the recursion overall is `O(n)`.
* Total time: `O(n log n)` due to sparse table construction.
* Extra space: `O(n log n)` for sparse table + `O(n)` for positions map and recursion stack.

---

# Code

```typescript
function minOperations(nums: number[]): number {
  const n = nums.length;
  // Split array by initial zeros; process only positive segments
  const segments: [number, number][] = [];
  let i = 0;
  while (i < n) {
    while (i < n && nums[i] === 0) i++;
    if (i >= n) break;
    let j = i;
    while (j < n && nums[j] !== 0) j++;
    segments.push([i, j - 1]);
    i = j;
  }

  if (segments.length === 0) return 0;

  // Build index lists for each value (only for positive values)
  const posMap = new Map<number, number[]>();
  for (let idx = 0; idx < n; idx++) {
    const v = nums[idx];
    if (v > 0) {
      if (!posMap.has(v)) posMap.set(v, []);
      posMap.get(v)!.push(idx);
    }
  }

  // Build sparse table for RMQ that returns index of minimum value in range [L,R]
  const LOG = Math.floor(Math.log2(n)) + 1;
  const st: number[][] = Array.from({ length: LOG }, () => Array(n).fill(0));
  // st[0][i] stores the index i
  for (let idx = 0; idx < n; idx++) st[0][idx] = idx;

  for (let k = 1; k < LOG; k++) {
    const len = 1 << k;
    const half = len >> 1;
    for (let start = 0; start + len - 1 < n; start++) {
      const i1 = st[k - 1][start];
      const i2 = st[k - 1][start + half];
      // choose index with smaller value; on tie choose smaller index (left-most)
      if (nums[i1] <= nums[i2]) st[k][start] = i1;
      else st[k][start] = i2;
    }
  }

  const logTable: number[] = Array(n + 1).fill(0);
  for (let x = 2; x <= n; x++) logTable[x] = logTable[Math.floor(x / 2)] + 1;

  function rmqIndex(L: number, R: number): number {
    const len = R - L + 1;
    const k = logTable[len];
    const i1 = st[k][L];
    const i2 = st[k][R - (1 << k) + 1];
    return nums[i1] <= nums[i2] ? i1 : i2;
  }

  // Binary search helpers over arrays of positions
  function lowerBound(arr: number[], target: number): number {
    let lo = 0, hi = arr.length;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (arr[mid] < target) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function upperBound(arr: number[], target: number): number {
    let lo = 0, hi = arr.length;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (arr[mid] <= target) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  // DFS recursion on ranges that contain only positive numbers (guaranteed by the splitting)
  function dfs(L: number, R: number): number {
    if (L > R) return 0;
    // number of elements in this positive range
    const len = R - L + 1;
    if (len === 0) return 0;

    // find index of minimum in [L, R]
    const minIdx = rmqIndex(L, R);
    const minVal = nums[minIdx];

    // get positions of minVal in [L,R]
    const posList = posMap.get(minVal)!; // must exist
    const loIdx = lowerBound(posList, L);
    const hiIdx = upperBound(posList, R); // exclusive
    // the positions inside [L,R] are posList[loIdx .. hiIdx-1]
    let ops = 1; // one operation to remove all occurrences of minVal in this range
    let prev = L;
    for (let t = loIdx; t < hiIdx; t++) {
      const p = posList[t];
      if (prev <= p - 1) {
        ops += dfs(prev, p - 1);
      }
      prev = p + 1;
    }
    if (prev <= R) ops += dfs(prev, R);

    // Option to delete each element individually instead
    return Math.min(ops, len);
  }

  // Sum operations over all positive segments
  let answer = 0;
  for (const [L, R] of segments) {
    answer += dfs(L, R);
  }
  return answer;
};

```

---

## Example Walkthroughs

1. **Example** `nums = [0,2]`

   * Positive segments: `[1,1]`
   * For `[1,1]`: min = 2, remove all occurrences (one op) → done.
   * Result: `1`

2. **Example** `nums = [3,1,2,1]`

   * Positive segment: `[0,3]`
   * min = 1 at positions 1 and 3 → remove both in 1 op → array splits: `[0,0]` and `[2]` and `[3..]` → we recurse on [0,0] (3) and [2,2] (2): each requires 1 operation; total `1 + 1 + 1 = 3`.
   * Compare with deleting each individually (4) → choose `3`.

3. **Example** `nums = [1,2,1,2,1,2]`

   * Positive whole segment `[0..5]`, min = 1 at positions 0,2,4 → remove all 1s in 1 op → children are three single 2's → each costs 1, total `1 + 3 = 4` (better than removing 6 individually).

---
