# Intuition

Explicitly constructing the binary number each time overflows and is unnecessary.
You only care whether the number is divisible by 5 → so track the number **mod 5**.

Binary shift logic:
If current value is `v`, and next bit is `b`, then
`newValue = v * 2 + b`
But we only keep:
`newValue %= 5`

If `newValue === 0`, then the prefix is divisible by 5.

---

# Approach

Maintain a running value `mod = 0`.
For each bit `b` in nums:

* Update: `mod = (mod * 2 + b) % 5`
* Append `mod === 0` to answer array

This prevents overflow and processes each bit in O(1).

---

# Complexity

* **Time:** O(n)
* **Space:** O(n) for output (O(1) additional space)

---

# Code

```ts
function prefixesDivBy5(nums: number[]): boolean[] {
    const result: boolean[] = [];
    let mod = 0;

    for (const bit of nums) {
        mod = (mod * 2 + bit) % 5;
        result.push(mod === 0);
    }

    return result;
};

```

---

# Example Walkthrough

**Input:** `nums = [0,1,1]`

**Start:** mod = 0

1. *bit* = 0
   mod = (0 * 2 + 0) % 5 = 0
   divisible → true

2. *bit* = 1
   mod = (0 * 2 + 1) % 5 = 1
   not divisible → false

3. *bit* = 1
   mod = (1 * 2 + 1) % 5 = 3
   not divisible → false

**Output:** `[true, false, false]`
