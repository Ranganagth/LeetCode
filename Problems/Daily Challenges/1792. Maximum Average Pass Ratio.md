[1792. Maximum Average Pass Ratio](https://leetcode.com/problems/maximum-average-pass-ratio/)

> New Solution
# Intuition

Adding one brilliant student to a class increases that class’s pass ratio by a certain amount:

$$
\Delta(p,t) = \frac{p+1}{t+1} - \frac{p}{t}.
$$

To maximize the final average pass ratio, always assign the next extra student to the class that yields the largest immediate increase $\Delta(p,t)$. This is a greedy strategy and we can implement it efficiently with a max-heap (priority queue) keyed by $\Delta$. After assigning a student to the chosen class, update its `p` and `t` and recompute its new $\Delta$, then reinsert into the heap.

# Approach

1. Build a max-heap of classes where the key is `delta = (p+1)/(t+1) - p/t`.
2. For each of the `extraStudents`:

   * Pop the class with the largest `delta`.
   * Increment its `pass` and `total`.
   * Recompute `delta` and push it back to the heap.
3. After allocation, compute the average pass ratio $\frac{1}{k}\sum (p_i/t_i)$ and return it.

We implement a binary max-heap in TypeScript for speed and avoid repeated full sorting.

# Complexity

* Time complexity: $O((k + \text{extra}) \log k)$ where $k=$ number of classes.

  * Building the heap: $O(k)$ (or $O(k\log k)$ if using repeated inserts).
  * Each extra student causes one pop and one push: $O(\log k)$ each, so $O(\text{extra}\log k)$.
* Space complexity: $O(k)$ for the heap.

# Code

```typescript
// Correct solution for the given problem statement
type ClassNode = {
    p: number;
    t: number;
    delta: number; // benefit of adding one student
};

function delta(p: number, t: number): number {
    // (p+1)/(t+1) - p/t
    return (p + 1) / (t + 1) - p / t;
}

class MaxHeap {
    heap: ClassNode[] = [];

    size(): number {
        return this.heap.length;
    }

    push(node: ClassNode) {
        this.heap.push(node);
        this.siftUp(this.heap.length - 1);
    }

    pop(): ClassNode | undefined {
        if (this.heap.length === 0) return undefined;
        const top = this.heap[0];
        const last = this.heap.pop()!;
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.siftDown(0);
        }
        return top;
    }

    private siftUp(idx: number) {
        const heap = this.heap;
        while (idx > 0) {
            const parent = Math.floor((idx - 1) / 2);
            if (heap[idx].delta <= heap[parent].delta) break;
            this.swap(idx, parent);
            idx = parent;
        }
    }

    private siftDown(idx: number) {
        const heap = this.heap;
        const n = heap.length;
        while (true) {
            let largest = idx;
            const l = 2 * idx + 1;
            const r = 2 * idx + 2;
            if (l < n && heap[l].delta > heap[largest].delta) largest = l;
            if (r < n && heap[r].delta > heap[largest].delta) largest = r;
            if (largest === idx) break;
            this.swap(idx, largest);
            idx = largest;
        }
    }

    private swap(i: number, j: number) {
        const tmp = this.heap[i];
        this.heap[i] = this.heap[j];
        this.heap[j] = tmp;
    }
}

function maxAveragePassRatio(classes: number[][], extraStudents: number): number {
    const heap = new MaxHeap();

    for (const [p, t] of classes) {
        heap.push({ p, t, delta: delta(p, t) });
    }

    for (let k = 0; k < extraStudents; k++) {
        const node = heap.pop();
        if (!node) break;
        node.p += 1;
        node.t += 1;
        node.delta = delta(node.p, node.t);
        heap.push(node);
    }

    let sum = 0;
    while (heap.size() > 0) {
        const node = heap.pop()!;
        sum += node.p / node.t;
    }

    return sum / classes.length;
}
```

## Example walkthrough with explanation

### Example 1

Input: `classes = [[1,2],[3,5],[2,2]]`, `extraStudents = 2`.

Initial deltas:

* class0: p=1,t=2 → delta ≈ (2/3 - 1/2) = 0.1666667
* class1: p=3,t=5 → delta ≈ (4/6 - 3/5) = 0.0333333
* class2: p=2,t=2 → delta = (3/3 - 2/2) = 0

1st extra student → choose class0 (largest delta), becomes p=2,t=3. New delta ≈ (3/4 - 2/3) = 0.0833333
2nd extra student → still class0 has largest delta, becomes p=3,t=4. New delta ≈ (4/5 - 3/4) = 0.05

Final classes: \[3/4, 3/5, 2/2] → average = (0.75 + 0.6 + 1) / 3 = 0.783333... → `0.78333`


---

> Old Solution
# Intuition

To maximize the average pass ratio across all classes, we need to assign extra students to the classes where they produce the highest marginal gain in the pass ratio. The marginal gain for adding a student to a class can be calculated as:

Gain=[(pass + 1) / (total + 1)]−(pass / total)

Using this, we prioritize the classes in a **max-heap (priority queue)** where the class with the highest marginal gain is processed first. After processing all the extra students, the average pass ratio across all classes is calculated.

# Approach

1. **Initialize Priority Queue**:    
    - Use a **max-heap** to store classes, ordered by the marginal gain of adding a student.
    - Each element in the queue is an object containing `pass` and `total`.

2. **Process Extra Students**:
    - While there are extra students, remove the class with the highest marginal gain from the priority queue.
    - Add one student to this class and calculate its new marginal gain.
    - Push the updated class back into the queue.

3. **Calculate Final Average**:
    - After distributing all extra students, calculate the average pass ratio by summing the pass ratios of all classes.

# Complexity

1. **Time Complexity**:    
    - Initializing the priority queue: ***O(n log ⁡n)***, where *n* is the number of classes.
    - Processing extra students: ***O(k log n)***, where *k* is the number of extra students.
    - Calculating the final average: **O(n log n)**.
    - Total: ***O((n + k) log n)***.

2. **Space Complexity**:    
    - Priority queue stores **O(n)** elements, so the space complexity is ***O(n)***.

# Code

```typescript
function maxAverageRatio(classes: number[][], extraStudents: number): number {
    // Import priority queue library
    const pq = new MinPriorityQueue({
        compare: (a, b) => {
            const gainA = (a.pass + 1) / (a.total + 1) - a.pass / a.total;
            const gainB = (b.pass + 1) / (b.total + 1) - b.pass / b.total;
            return gainB - gainA; // Max-Heap logic
        }
    });

    // Add all classes to the priority queue
    for (const [pass, total] of classes) {
        pq.enqueue({ pass, total });
    }

    // Assign extra students to maximize the average pass ratio
    while (extraStudents > 0) {
        const { pass, total } = pq.dequeue(); // Get class with max marginal gain
        pq.enqueue({ pass: pass + 1, total: total + 1 }); // Update the class with one more student
        extraStudents--;
    }

    // Calculate the final average pass ratio
    let totalRatio = 0;
    while (!pq.isEmpty()) {
        const { pass, total } = pq.dequeue();
        totalRatio += pass / total;
    }

    return totalRatio / classes.length;
};

```

---

### **Example and Explanation Walkthrough**

#### Example Input:

```typescript
const classes = [[1, 2], [3, 5], [2, 2]];
const extraStudents = 2;
console.log(maxAverageRatio(classes, extraStudents)); // Output: 0.78333
```

#### Steps:

1. **Initialize Priority Queue**:
    
    - Add the classes to the queue:
        - Class 1: *pass =1, total = 2, gain = 0.1667*.
        - Class 2: *pass = 3, total = 5, gain = 0.0333*.
        - Class 3: *pass = 2, total = 2, gain = 0.0000*.
    - Queue is ordered by marginal gain: [Class 1, Class 2, Class 3]
	
2. **Process Extra Students**:    
    - Assign 1 student to Class 1:
        - Updated Class 1: *pass = 2, total = 3, gain = 0.0833*.
        - Reorder queue: [Class 1, Class 2, Class 3].
    - Assign 1 student to Class 1 again:
        - Updated Class 1: *pass = 3, total = 4, gain = 0.0500*.
        - Reorder queue: [Class 2, Class 1, Class 3].

3. **Calculate Final Average**:    
    - Compute the average pass ratio:
        - Class 1: *3/4 = 0.75*.
        - Class 2: *3/5 = 0.60*.
        - Class 3: *2/2 = 1.00*.
        - Total average: *(0.75+0.60+1.00)/3 = 0.78333*.

#### Output:

```typescript
0.78333
```

---

This approach ensures an optimal distribution of extra students to maximize the average pass ratio efficiently.