[3446. Sort Matrix by Diagonals](https://leetcode.com/problems/sort-matrix-by-diagonals/)

# Intuition

Each diagonal in an `n x n` matrix can be identified by the difference `(i - j)`:

* Same `(i - j)` → same diagonal.

We need to sort diagonals differently depending on their position:

* If the diagonal starts from the **first column** (bottom-left triangle) or the **main diagonal**, we sort it in **non-increasing order**.
* If the diagonal starts from the **top row** (top-right triangle), we sort it in **non-decreasing order**.

Then we place back the sorted elements into the grid.

---

# Approach

1. Group elements by diagonals using `key = i - j`.
2. For each diagonal:

   * If its starting point lies in the **first column** (`j=0`) or on the **main diagonal**, sort in **descending** order.
   * If its starting point lies in the **top row** (`i=0`), sort in **ascending** order.
3. Reassign the sorted values back to their positions in the grid.
4. Return the modified grid.

---

# Complexity

* **Time complexity:**
  Each element belongs to exactly one diagonal. Sorting all diagonals together costs at most **O(n² log n)**.
* **Space complexity:**
  We use a map to store diagonals → **O(n²)**.

---

# Code

```typescript
function sortMatrix(grid: number[][]): number[][] {
    const n = grid.length;
    const diagonals: Map<number, number[]> = new Map();

    // Step 1: Group by diagonals
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const key = i - j;
            if (!diagonals.has(key)) diagonals.set(key, []);
            diagonals.get(key)!.push(grid[i][j]);
        }
    }

    // Step 2: Sort each diagonal appropriately
    for (let [key, arr] of diagonals) {
        if (key >= 0) {
            // bottom-left including main diagonal → sort descending
            arr.sort((a, b) => b - a);
        } else {
            // top-right → sort ascending
            arr.sort((a, b) => a - b);
        }
    }

    // Step 3: Place back values into the grid
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const key = i - j;
            grid[i][j] = diagonals.get(key)!.shift()!;
        }
    }

    return grid;
}
```

---

# Example walkthrough

### Example 1

Input:

```
grid = [[1,7,3],
        [9,8,2],
        [4,5,6]]
```

* Diagonal `(i-j=0)` → `[1,8,6]` → sorted descending `[8,6,1]`.
* Diagonal `(i-j=1)` → `[9,5]` (already descending).
* Diagonal `(i-j=2)` → `[4]`.
* Diagonal `(i-j=-1)` → `[7,2]` → sorted ascending `[2,7]`.
* Diagonal `(i-j=-2)` → `[3]`.

Reconstructed grid:

```
[[8,2,3],
 [9,6,7],
 [4,5,1]]
```

Output = **\[\[8,2,3],\[9,6,7],\[4,5,1]]** 

---
