[3650. Minimum Cost Path with Edge Reversals](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/)

# Intuition

At first glance, the problem looks complicated because:

* Edges are **directed**
* Each node has a **one-time switch**
* A switch allows you to **reverse an incoming edge**, but:

  * Only for **one move**
  * At **double cost**

The key realization is this:

> Using a switch at node `u` to reverse an incoming edge `v → u` and travel `u → v` with cost `2w` is **equivalent to having a permanent directed edge `u → v` with weight `2w`.**

Since each node’s switch can be used at most once, but **we only care about the cheapest path**, we can safely model *all possible reversals* as additional edges.

This transforms the problem into a **standard shortest-path problem**.

## Core Insight

For every original directed edge:

```
u → v (cost w)
```

We add:

* The original edge `u → v` with cost `w`
* A **reverse edge** `v → u` with cost `2w`

Now the graph contains **all possible moves** (normal + reversed), and the problem becomes:

> Find the shortest path from node `0` to node `n-1`.

This is exactly what **Dijkstra’s algorithm** is designed for.

---

# Approach

1. **Build a graph**

   * For each edge `[u, v, w]`:

     * Add `u → v` with cost `w`
     * Add `v → u` with cost `2w`

2. **Run Dijkstra’s algorithm**

   * Start from node `0`
   * Track minimum distance to each node
   * Use a priority queue for efficiency

3. **Early exit**

   * As soon as node `n - 1` is popped from the priority queue, return the distance

4. **If unreachable**, return `-1`

## Why This Works

* All valid paths (with or without switch usage) are represented
* Switch usage cost is correctly modeled
* Dijkstra guarantees the minimum total cost
* Switch constraints don’t need explicit tracking because:

  * Using a reversed edge twice is never optimal
  * Higher cost prevents illegal reuse naturally

---

# Complexity

* **Time Complexity:**
$$
  O((n + m)\log n)
$$
  where:
  * `n` = number of nodes
  * `m` = number of edges

* **Space Complexity:**
$$
  O(n + m)
$$
  for graph storage and distance tracking

This is optimal for large graphs (`n ≤ 5×10⁴`, `m ≤ 10⁵`).

---

# Code

```ts
function minCost(n: number, edges: number[][]): number {
    const g: [number, number][][] = Array.from({ length: n }, () => []);

    // Build graph
    for (const [u, v, w] of edges) {
        g[u].push([v, w]);       // normal edge
        g[v].push([u, 2 * w]);   // reversed edge using switch
    }

    const dist: number[] = Array(n).fill(Infinity);
    const visited: boolean[] = Array(n).fill(false);
    dist[0] = 0;

    const pq = new PriorityQueue<[number, number]>((a, b) =>
        a[0] < b[0] ? -1 : 1
    );

    pq.enqueue([0, 0]);

    while (!pq.isEmpty()) {
        const [currentDist, node] = pq.dequeue()!;

        if (node === n - 1) {
            return currentDist;
        }

        if (visited[node]) continue;
        visited[node] = true;

        for (const [next, cost] of g[node]) {
            if (currentDist + cost < dist[next]) {
                dist[next] = currentDist + cost;
                pq.enqueue([dist[next], next]);
            }
        }
    }

    return -1;
};

```

---

# Example Walkthrough

### Example 1

```
n = 4
edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]
```

**Graph after transformation:**

```
0 → 1 (3)
1 → 0 (6)

3 → 1 (1)
1 → 3 (2)

2 → 3 (4)
3 → 2 (8)

0 → 2 (2)
2 → 0 (4)
```

**Shortest path:**

```
0 → 1 (3)
1 → 3 (2)
```

**Total cost:**

```
3 + 2 = 5
```

**Output:**

```
5
```


### Example 2

```
0 → 2 → 1 → 3
```

**Costs:**

```
1 + 1 + 1 = 3
```

No switch needed.

**Output:**

```
3
```

---

## Final Takeaway

This problem looks complex, but the trick is:

> **Convert dynamic “reverse edge with cost” logic into static weighted edges.**

Once done, it reduces cleanly to **Dijkstra’s shortest path**, making the solution both elegant and optimal.
