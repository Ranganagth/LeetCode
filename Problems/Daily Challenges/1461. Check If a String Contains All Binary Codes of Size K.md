[1461. Check If a String Contains All Binary Codes of Size K](https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/)

# Intuition

There are exactly:
$$2^k$$

possible binary substrings (codes) of length `k`.

Brute force generation and checking each code inside the string is too slow because:

* `s.length` can be `5 × 10^5`
* `k` can be up to `20` → (2^{20} = 1,048,576) possible codes.

Instead, observe:

Every substring of length `k` inside `s` can be represented as a **binary number** using a sliding window.
If all distinct binary numbers of size `k` appear at least once → return `true`.

Use a **rolling bitmask** to represent each window efficiently.

---

# Approach

1. If `k > s.length`, return `false`.
2. Total required unique codes:

$$required = 2^k$$

3. Use:

   * bitmask integer representing current window.
   * boolean array (or Set) to track visited codes.
4. Slide window:

   * Shift mask left.
   * Add new bit.
   * Remove extra bits using masking.
$$mask = ((mask << 1) & ((1<<k)-1)) | currentBit$$


5. After first `k` characters:

   * mark mask as seen.
   * decrement remaining count when new code appears.
6. If all codes seen → return true early.

---

# Complexity

* **Time complexity:** $(O(N))$
* **Space complexity:** $(O(2^k))$

Optimal because every character is processed once.

---

# Code

```typescript
function hasAllCodes(s: string, k: number): boolean {

    const n = s.length;

    // impossible case
    if (k > n) return false;

    const totalCodes = 1 << k;

    // visited binary codes
    const seen = new Uint8Array(totalCodes);

    let mask = 0;
    const allOnes = totalCodes - 1;

    let remaining = totalCodes;

    for (let i = 0; i < n; i++) {

        // shift and add new bit
        mask = ((mask << 1) & allOnes) | (s.charCodeAt(i) - 48);

        // window becomes valid after k-1 index
        if (i >= k - 1) {

            if (seen[mask] === 0) {
                seen[mask] = 1;
                remaining--;

                // early exit
                if (remaining === 0) return true;
            }
        }
    }

    return false;
};

```

---

# Example Walkthrough

Example:

```
s = "00110110"
k = 2
```

Possible codes:

```
00
01
10
11
```

Sliding window:

```
00 → seen
01 → seen
11 → seen
10 → seen
01 → already seen
11 → already seen
10 → already seen
```

All 4 codes discovered.

Return:

```
true
```
