[3508. Implement Router](https://leetcode.com/problems/implement-router/)

## Problem statement

We need to design a router that:

* Stores data packets (`source`, `destination`, `timestamp`) with a **fixed memory limit** (FIFO eviction when full).
* Avoids adding duplicate packets (`source, destination, timestamp` triple must be unique).
* Forwards packets in **FIFO order**.
* Supports querying how many packets for a given `destination` fall within a **time range**.

---

# Intuition

We need to efficiently support:

1. **FIFO packet order** → use a queue.
2. **Duplicate detection** → use a hash set (`source-destination-timestamp` key).
3. **Efficient time-range counting per destination**:

   * Since `addPacket` timestamps are non-decreasing, we can store timestamps in **sorted order** for each destination.
   * Then answer queries with **binary search** (`lower_bound` / `upper_bound`).

---

# Approach

### Data Structures

1. **Queue** (`Array` or `Deque`):

   * Maintains order of packets.
   * Used for `forwardPacket` and eviction when memory is full.
1. **Set\<string>**:

   * Store string key `"source#dest#timestamp"` to check duplicates.
3. **Map\<destination, number\[]>**:

   * Each destination maps to a **sorted list of timestamps**.
   * Since packets come in increasing `timestamp`, we just **append** at the end.
   * For queries, use binary search.

### Methods

* **addPacket(source, dest, timestamp)**:

  1. If duplicate → return `false`.
  2. If memory full → evict oldest from queue, remove from set + timestamp array.
  3. Insert packet into all structures.
  4. Return `true`.

* **forwardPacket()**:

  1. If queue empty → return `[]`.
  2. Remove from queue, delete from set + timestamp array.
  3. Return `[source, dest, timestamp]`.

* **getCount(dest, start, end)**:

  1. Get `timestamps[]` for that destination.
  2. Binary search for leftmost index ≥ `start`.
  3. Binary search for rightmost index ≤ `end`.
  4. Return count = `right - left + 1`.

---

# Complexity

* **addPacket**: O(1) amortized (except when evicting → O(1) deletion).
* **forwardPacket**: O(1).
* **getCount**: O(log n) due to binary search per destination.
* **Space**: O(memoryLimit + total queries).

---

# Code

```typescript
class Router {
    private memoryLimit: number;
    private queue: [number, number, number][] = []; // [source, dest, ts]
    private packetSet: Set<string> = new Set();
    private destMap: Map<number, number[]> = new Map(); // dest -> sorted timestamps

    constructor(memoryLimit: number) {
        this.memoryLimit = memoryLimit;
    }

    addPacket(source: number, destination: number, timestamp: number): boolean {
        const key = `${source}#${destination}#${timestamp}`;
        if (this.packetSet.has(key)) return false;

        // Evict if memory full
        if (this.queue.length === this.memoryLimit) {
            const [s, d, t] = this.queue.shift()!;
            this.packetSet.delete(`${s}#${d}#${t}`);
            const arr = this.destMap.get(d)!;
            // Remove timestamp t (since FIFO, it's the oldest occurrence)
            if (arr.length && arr[0] === t) {
                arr.shift();
            } else {
                // fallback remove by index
                const idx = arr.indexOf(t);
                if (idx !== -1) arr.splice(idx, 1);
            }
        }

        // Add new packet
        this.queue.push([source, destination, timestamp]);
        this.packetSet.add(key);
        if (!this.destMap.has(destination)) this.destMap.set(destination, []);
        this.destMap.get(destination)!.push(timestamp);
        return true;
    }

    forwardPacket(): number[] {
        if (this.queue.length === 0) return [];
        const [s, d, t] = this.queue.shift()!;
        this.packetSet.delete(`${s}#${d}#${t}`);

        const arr = this.destMap.get(d)!;
        if (arr.length && arr[0] === t) {
            arr.shift();
        } else {
            const idx = arr.indexOf(t);
            if (idx !== -1) arr.splice(idx, 1);
        }

        return [s, d, t];
    }

    getCount(destination: number, startTime: number, endTime: number): number {
        if (!this.destMap.has(destination)) return 0;
        const arr = this.destMap.get(destination)!;
        if (arr.length === 0) return 0;

        const left = this.lowerBound(arr, startTime);
        const right = this.upperBound(arr, endTime);
        return Math.max(0, right - left);
    }

    private lowerBound(arr: number[], target: number): number {
        let lo = 0, hi = arr.length;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (arr[mid] < target) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    private upperBound(arr: number[], target: number): number {
        let lo = 0, hi = arr.length;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (arr[mid] <= target) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }
};

```

---

## Example Walkthrough

### Input

```
["Router", "addPacket", "addPacket", "addPacket", "addPacket", "addPacket", "forwardPacket", "addPacket", "getCount"]
[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]
```

### Execution

1. `Router(3)` → memory limit 3.
2. `addPacket(1,4,90)` → added.
3. `addPacket(2,5,90)` → added.
4. `addPacket(1,4,90)` → duplicate → false.
5. `addPacket(3,5,95)` → added.
6. `addPacket(4,5,105)` → evicts `[1,4,90]` (oldest), adds new.
7. `forwardPacket()` → returns `[2,5,90]`.
8. `addPacket(5,2,110)` → added.
9. `getCount(5,100,110)` → timestamps for dest=5 = \[95,105]. In range \[100,110] → only 105 → count=1.

### Output

```
[null, true, true, false, true, true, [2,5,90], true, 1]
```

---

