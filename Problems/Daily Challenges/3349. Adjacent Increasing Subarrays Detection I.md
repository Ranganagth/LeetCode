[3349. Adjacent Increasing Subarrays Detection I](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i/)

# Intuition

We need to find **two adjacent subarrays** of length `k` such that:

1. Both subarrays are **strictly increasing**.
2. The **second subarray starts right after the first**, i.e.,
   if the first starts at index `a`, the second starts at `a + k`.

In short:

* We need to find a window of length `2k` (`nums[a..a + 2k - 1]`) such that:

  * The first `k` elements form a strictly increasing sequence.
  * The next `k` elements form another strictly increasing sequence.

---

# Approach

1. **Define a helper check for increasing sequence:**

   * A subarray `nums[i..i + k - 1]` is strictly increasing if:

     ```
     nums[j] < nums[j + 1] for all j in [i, i + k - 2]
     ```

2. **Compute for all indices whether subarray of size `k` is increasing:**

   * For each index `i` from `0` to `n - k`, check if `nums[i..i + k - 1]` is strictly increasing.
   * Store result in an array `isIncreasing[i]`.

3. **Check for adjacent increasing subarrays:**

   * For any `i` in range `[0, n - 2k]`, if:

     ```
     isIncreasing[i] === true && isIncreasing[i + k] === true
     ```

     then return `true`.

4. If no such pair found, return `false`.

---

# Time and Space Complexity

* **Time Complexity:**

  * Checking each subarray of size `k` takes `O(k)`, repeated `O(n)` times → `O(n*k)`.
  * Since `n ≤ 100`, this is perfectly fine.
* **Space Complexity:**

  * `O(n)` for storing the `isIncreasing` array.

---

# Code

```typescript
function hasIncreasingSubarrays(nums: number[], k: number): boolean {
  const n = nums.length;
  const isIncreasing: boolean[] = new Array(n).fill(false);

  // Step 1: Check each subarray of length k
  for (let i = 0; i + k <= n; i++) {
    let valid = true;
    for (let j = i; j < i + k - 1; j++) {
      if (nums[j] >= nums[j + 1]) {
        valid = false;
        break;
      }
    }
    isIncreasing[i] = valid;
  }

  // Step 2: Look for adjacent increasing subarrays
  for (let i = 0; i + 2 * k <= n; i++) {
    if (isIncreasing[i] && isIncreasing[i + k]) {
      return true;
    }
  }

  return false;
};

```

---

## Example Walkthrough

#### Example 1:

```
nums = [2, 5, 7, 8, 9, 2, 3, 4, 3, 1], k = 3
```

**Step 1: Find increasing subarrays of length 3**

* [2,5,7] → increasing
* [5,7,8] → increasing
* [7,8,9] → increasing
* [8,9,2] → not increasing
* [9,2,3] → not increasing
* [2,3,4] → increasing
* [3,4,3] → not increasing
* [4,3,1] → not increasing

`isIncreasing = [T, T, T, F, F, T, F, F, ...]`

**Step 2: Check adjacency**

* i = 0 → isIncreasing[0] = T, isIncreasing[3] = F → no
* i = 1 → isIncreasing[1] = T, isIncreasing[4] = F → no
* i = 2 → isIncreasing[2] = T, isIncreasing[5] = T → Yes

Return **true**

#### Example 2:

```
nums = [1,2,3,4,4,4,4,5,6,7], k = 5
```

Subarrays of length 5:

* [1,2,3,4,4] → not increasing 
* [2,3,4,4,4] → not increasing 
* [3,4,4,4,4] → not increasing 
* [4,4,4,4,5] → not increasing 
* [4,4,4,5,6] → not increasing 
* [4,4,5,6,7] → not increasing 

No increasing subarrays found → return **false**

**Final Answer:**

* **Example 1 Output:** `true`
* **Example 2 Output:** `false`
