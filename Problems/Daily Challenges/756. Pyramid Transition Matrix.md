[756. Pyramid Transition Matrix](https://leetcode.com/problems/pyramid-transition-matrix/)

# Intuition

Each upper row is determined by adjacent pairs in the row below. For each pair of letters, only certain top letters are allowed. You must check whether there exists **any sequence of valid choices** that builds a single block at the top. This is a **constraint search** problem over a very small state space (length ≤ 6), so **backtracking with memoization** solves it cleanly.

**Key observations:**

* Each row is shorter by one character
* Each adjacent pair uniquely restricts allowed next letters
* Branching factor is small because allowed characters ∈ {A..F}
* Many partial rows repeat → memoize failing states to prune search

Goal reduces to: generate all possible next rows recursively; stop when length = 1.

---

# Approach

1. Preprocess `allowed`

   * Map `(left,right)` → list of possible `top` letters
2. Backtrack

   * Given current row, build all possible next rows character-by-character
   * When a pair has no valid tops, dead end
3. Memoization on rows

   * Store rows that **cannot** lead to a full pyramid
4. Success condition

   * Reached one-character row

## Algorithm steps

* Build adjacency map: `map[pair] = [tops...]`
* DFS function:

  * input: current row
  * if length 1 → success
  * try to construct next row by exploring all combinations
  * prune using memo set

---

# Complexity

* Maximum width 6, alphabet size 6
* **Worst-case time:** `O(6^n)` exponential (n ≤ 6 → bounded small)
* Practical due to pruning and constraints
* **Space:** `O(6^n)` due to memoization (small)

---

# Code

```ts
function pyramidTransition(bottom: string, allowed: string[]): boolean {
    const mp: Map<string, string[]> = new Map();

    for (const pat of allowed) {
        const key = pat[0] + pat[1];
        if (!mp.has(key)) mp.set(key, []);
        mp.get(key)!.push(pat[2]);
    }

    const memo: Set<string> = new Set();

    function dfs(row: string): boolean {
        if (row.length === 1) return true;
        if (memo.has(row)) return false;

        const nextRows: string[] = [];

        function buildNext(idx: number, cur: string) {
            if (idx === row.length - 1) {
                nextRows.push(cur);
                return;
            }

            const pair = row[idx] + row[idx + 1];
            if (!mp.has(pair)) return;

            for (const c of mp.get(pair)!) {
                buildNext(idx + 1, cur + c);
            }
        }

        buildNext(0, "");

        for (const next of nextRows) {
            if (dfs(next)) return true;
        }

        memo.add(row);
        return false;
    }

    return dfs(bottom);
};

```

---

# Example walkthrough

**Input:**
`bottom = "BCD"`
`allowed = ["BCC","CDE","CEA","FFF"]`

**Mapping:**

* `BC → C`
* `CD → E`
* `CE → A`

**Process:**

* Bottom: `BCD`
* Pairs:

  * `BC` → `C`
  * `CD` → `E`
* Next row candidates: `"CE"`
* Row `"CE"`

  * Pair `CE` → `A`
* Next row: `"A"`
* Length = 1 → success

Output: **true**

---