[3347. Maximum Frequency of an Element After Performing Operations II](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/)

# Intuition

We want to **maximize the frequency of a single number** after performing `numOperations` limited additive operations.

Each operation:

* Can modify one unique element by adding any number from `[-k, k]`.
* Each index can be chosen **only once**.

So effectively, every number `nums[i]` can be converted into **any number within range `[nums[i] - k, nums[i] + k]`**.

Our goal:
Find the **largest group of numbers** that can overlap in value after up to `numOperations` modifications.

## Core Idea

* For each **potential target value `x`**, find how many elements could be converted into `x` (i.e., elements whose range `[nums[i] - k, nums[i] + k]` includes `x`).
* We can adjust at most `numOperations` additional elements to reach that frequency.
* The answer is the **maximum possible count** for any `x`.

But checking all possible integers (`1..10^9`) would be too slow.
So instead, we only check **“candidate target values”** that matter — i.e., existing numbers and their ±k boundaries.

---

# Approach

### Step 1: Sort the array

Sorting helps efficiently use binary search and range queries.

### Step 2: Count occurrences of each number

Using a `Map<number, number>` — this helps avoid repeated work and gives us the baseline frequency for each distinct number.

### Step 3: Generate candidate “modes”

Possible target numbers to maximize around are:

* Each unique number `num`
* `num - k`
* `num + k`

These represent the “range edges” where frequency changes could occur.

### Step 4: Binary search for range inclusion

For a given candidate mode `x`:

* Find all numbers in range `[x - k, x + k]`.
* That range represents all numbers that could be turned into `x`.

Use:

* `leftBound(value)` → smallest index where `nums[idx] >= value`
* `rightBound(value)` → largest index where `nums[idx] <= value`

Then `count = r - l + 1` gives how many elements could reach `x`.

### Step 5: Compute possible frequency

If `x` already exists in `nums`:

```
tempAns = min(count, numCount[x] + numOperations)
```

Otherwise:

```
tempAns = min(count, numOperations)
```

Keep track of the maximum `tempAns`.

---

# Complexity

| Step                      | Time                                                                             | Space    |
| ------------------------- | -------------------------------------------------------------------------------- | -------- |
| Sorting                   | O(n log n)                                                                       | O(1)     |
| Counting & building modes | O(n)                                                                             | O(n)     |
| Binary search per mode    | O(log n) each                                                                    | —        |
| Total                     | **O(n log n + m log n)**, where `m` is number of unique modes ≤ 3 × unique(nums) | **O(n)** |

Very efficient even for `n = 10^5`.

---

# Code

```typescript
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    nums.sort((a, b) => a - b);

    let ans = 0;
    const numCount: Map<number, number> = new Map();
    const modes: Set<number> = new Set();

    // Add candidate modes: each number and its +/- k neighbors
    const addMode = (value: number) => {
        modes.add(value);
        if (value - k >= nums[0]) modes.add(value - k);
        if (value + k <= nums[nums.length - 1]) modes.add(value + k);
    };

    // Count frequency of each distinct number
    let lastNumIndex = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== nums[lastNumIndex]) {
            numCount.set(nums[lastNumIndex], i - lastNumIndex);
            ans = Math.max(ans, i - lastNumIndex);
            addMode(nums[lastNumIndex]);
            lastNumIndex = i;
        }
    }
    numCount.set(nums[lastNumIndex], nums.length - lastNumIndex);
    ans = Math.max(ans, nums.length - lastNumIndex);
    addMode(nums[lastNumIndex]);

    // Binary search helpers
    const leftBound = (value: number) => {
        let left = 0, right = nums.length - 1;
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (nums[mid] < value) left = mid + 1;
            else right = mid;
        }
        return left;
    };

    const rightBound = (value: number) => {
        let left = 0, right = nums.length - 1;
        while (left < right) {
            const mid = Math.floor((left + right + 1) / 2);
            if (nums[mid] > value) right = mid - 1;
            else left = mid;
        }
        return left;
    };

    // Try maximizing around each candidate mode
    for (const mode of modes) {
        const l = leftBound(mode - k);
        const r = rightBound(mode + k);

        let tempAns: number;
        const countInRange = r - l + 1;

        if (numCount.has(mode)) {
            tempAns = Math.min(countInRange, numCount.get(mode)! + numOperations);
        } else {
            tempAns = Math.min(countInRange, numOperations);
        }

        ans = Math.max(ans, tempAns);
    }

    return ans;
};

```

---

## Example Walkthrough

### Example 1

```
nums = [1, 4, 5], k = 1, numOperations = 2
```

**Step 1:** Sort → `[1, 4, 5]`
**Frequencies:** `{1 → 1, 4 → 1, 5 → 1}`
**Candidate modes:** `{1, 0, 2, 4, 3, 5, 6}`

Check around mode = 4:

* Range `[3, 5]`
* leftBound(3) = 1 (points to 4)
* rightBound(5) = 2 (points to 5)
* Range length = 2
* `numCount(4) = 1`
* `tempAns = min(2, 1 + 2) = 2`

→ **Max frequency = 2**

Output: `2`

### Example 2

```
nums = [5, 11, 20, 20], k = 5, numOperations = 1
```

**Step 1:** Sort → `[5, 11, 20, 20]`
**Frequencies:** `{5 → 1, 11 → 1, 20 → 2}`
**Candidate modes:** `{5, 0, 10, 11, 6, 16, 20, 15, 25}`

Check mode = 20:

* Range `[15, 25]`
* leftBound(15) = 2
* rightBound(25) = 3
* Range length = 2
* `numCount(20) = 2`
* `tempAns = min(2, 2 + 1) = 2`

Output: `2`

---

## Summary

| Concept              | Description                                                   |
| -------------------- | ------------------------------------------------------------- |
| **Goal**             | Maximize frequency of a number after limited ±k modifications |
| **Technique**        | Binary search on sorted array + mode candidates               |
| **Key Optimization** | Check only relevant “modes”: number and its ±k boundaries     |
| **Time Complexity**  | O(n log n + m log n)                                          |
| **Space Complexity** | O(n)                                                          |
