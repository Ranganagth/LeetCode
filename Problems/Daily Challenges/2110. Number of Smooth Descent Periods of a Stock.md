[2110. Number of Smooth Descent Periods of a Stock](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/)

# Intuition

A smooth descent period is a contiguous segment where each next price decreases by **exactly 1**.
Every single day alone is always valid.

So the problem reduces to:

* Find maximal contiguous segments where `prices[i-1] - prices[i] == 1`
* For each such segment of length `L`, count how many subarrays it contributes

A segment of length `L` contributes:

```
1 + 2 + ... + L = L * (L + 1) / 2
```

---

# Approach

Traverse the array once and maintain the length of the current smooth descent chain.

* Initialize `currentLength = 1` (single day)
* For each `i` from `1` to `n-1`:

  * If `prices[i-1] - prices[i] == 1`, extend the chain → `currentLength++`
  * Else, reset → `currentLength = 1`
* Add `currentLength` to the answer at each step

Why this works:

* At position `i`, `currentLength` equals the number of smooth descent subarrays ending at `i`
* Summing these gives the total count

---

# Complexity

* **Time:** `O(n)` — single pass
* **Space:** `O(1)` — constant extra space

---

# Code

```ts
function getDescentPeriods(prices: number[]): number {
    let ans = 1;
    let curr = 1;

    for (let i = 1; i < prices.length; i++) {
        if (prices[i - 1] - prices[i] === 1) {
            curr++;
        } else {
            curr = 1;
        }
        ans += curr;
    }

    return ans;
};

```

---

# Example Walkthrough

### Example 1

`prices = [3,2,1,4]`

| i | prices[i] | curr | ans |
| - | --------- | ---- | --- |
| 0 | 3         | 1    | 1   |
| 1 | 2         | 2    | 3   |
| 2 | 1         | 3    | 6   |
| 3 | 4         | 1    | 7   |

Result: `7`


### Example 2

`prices = [8,6,7,7]`

No consecutive `-1` differences.

Each element contributes only itself.

Result: `4`


### Example 3

`prices = [1]`

Single element.

Result: `1`

---
