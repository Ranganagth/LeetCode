[3573. Best Time to Buy and Sell Stock V](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/)

# Intuition

Each transaction is an **independent price difference** over a contiguous interval:

* Normal transaction earns `prices[j] - prices[i]`
* Short selling earns `prices[i] - prices[j]`

Both are equivalent to earning the **absolute difference** between two days, but with a strict rule:

* You must choose direction first (buy→sell or sell→buy)
* Transactions cannot overlap
* At most `k` disjoint segments

This reduces to:
**Pick at most k non-overlapping segments, each contributing the maximum possible profit segment-wise.**

This is a dynamic programming problem similar to stock trading, but with **two holding states**:

* Holding a long position
* Holding a short position

---
# Approach

**State Definition**

Let:

* `dp[t][0]`: max profit after `t` transactions, currently **not holding** any position
* `dp[t][1]`: max profit after `t` transactions, currently **holding a long position**
* `dp[t][2]`: max profit after `t` transactions, currently **holding a short position**

Only completed buy–sell or sell–buy increments `t`.


**State Transitions**

For each price `p`:

1. **Open positions (no transaction counted yet)**

```
dp[t][1] = max(dp[t][1], dp[t][0] - p)   // buy
dp[t][2] = max(dp[t][2], dp[t][0] + p)   // sell (short)
```

2. **Close positions (transaction completed)**

```
dp[t+1][0] = max(
  dp[t+1][0],
  dp[t][1] + p,   // sell long
  dp[t][2] - p    // buy back short
)
```

Transactions are counted **only when closing** a position.


**Initialization**

```
dp[0][0] = 0
dp[*][*] = -∞ otherwise
```


**Answer**

Maximum `dp[t][0]` for `t ≤ k`.

---

# Complexity

* **Time:** `O(n * k)`
* **Space:** `O(k)`

Optimal under given constraints.

---

# Code

```ts
function maximumProfit(prices: number[], k: number): number {
    const n = prices.length;
    const NEG = -1e18;

    const dp0 = new Array(k + 1).fill(NEG); // no position
    const dpLong = new Array(k + 1).fill(NEG); // holding long
    const dpShort = new Array(k + 1).fill(NEG); // holding short

    dp0[0] = 0;

    for (const price of prices) {
        for (let t = k; t >= 0; t--) {
            if (dp0[t] !== NEG) {
                dpLong[t] = Math.max(dpLong[t], dp0[t] - price);
                dpShort[t] = Math.max(dpShort[t], dp0[t] + price);
            }
            if (t + 1 <= k) {
                if (dpLong[t] !== NEG) {
                    dp0[t + 1] = Math.max(dp0[t + 1], dpLong[t] + price);
                }
                if (dpShort[t] !== NEG) {
                    dp0[t + 1] = Math.max(dp0[t + 1], dpShort[t] - price);
                }
            }
        }
    }

    return Math.max(...dp0);
};

```

---

# Example Walkthrough

**Example 1**

`prices = [1,7,9,8,2], k = 2`

* Transaction 1 (normal): buy at 1 → sell at 9 → profit 8
* Transaction 2 (short): sell at 8 → buy at 2 → profit 6
* **Total** = 14

DP captures both directions explicitly and ensures non-overlap by counting transactions only on close.

---

### Summary

Allowing short selling converts the problem into a **bidirectional interval profit selection**, but transaction boundaries still matter.
Explicit long/short state DP is the minimal correct model.
