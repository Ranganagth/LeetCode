[2749. Minimum Operations to Make the Integer Zero](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/)

# Intuition

Each operation subtracts a value of the form $$2^i + \text{num2}$$ from `num1`. After performing `k` operations with chosen exponents $$i_1,\dots,i_k$$ we have:


$$\sum_{j=1}^{k} (2^{i_j} + \text{num2}) = \text{num1}
\quad\Longrightarrow\quad
\sum_{j=1}^{k} 2^{i_j} = \text{num1} - k\cdot\text{num2} \equiv T
$$

So the right-hand side $$T$$ must be a positive integer that can be written as a sum of exactly `k` powers of two (repetitions allowed).  
A well-known property about writing an integer `T` as a sum of powers of two (with repetition) is:

- The minimal number of powers needed is `popcount(T)` (i.e., the number of 1-bits of `T`) — take distinct powers for each 1-bit.
- By splitting a power $$2^j$$ into two $$2^{j-1}$$ you can **increase** the number of parts by 1; hence you can realize **any** `k` with `popcount(T) ≤ k ≤ T`.

Thus for a candidate `k` we require:

1. `T = num1 - k * num2` is a positive integer (`T >= k` in particular),
2. `popcount(T) <= k` (and since `k ≤ T` will be checked, `popcount(T) ≤ k ≤ T` is the necessary and sufficient condition).

We want the minimal `k` satisfying the two conditions; if none exists, answer is `-1`.

Practically we can iterate `k` from `1` up to a reasonable upper bound and check these conditions. Because exponents `i` are allowed up to `60` (i.e. $$2^{60}$$ is the largest single term), iterating `k` up to a modest bound (e.g. `100`) is sufficient in practice and is the common approach for this task.

---

# Approach

1. For `k` from `1` to an upper bound (we use `100` which comfortably covers 60-bit behaviors):
   - Compute `T = num1 - k * num2`.
   - If `T < k`, continue (impossible because we need at least `k` units using `k` powers of two).
   - Compute `pc = popcount(T)` (number of `1` bits in `T`).
   - If `pc <= k <= T`, return `k`.
2. If loop finishes, return `-1`.

Note: `T` must be positive integer; since `num1 >= 1` and `k >= 1`, we check `T >= k`.

---

# Complexity

- **Time complexity:** We loop `k` up to the fixed bound `B = 100`, and each iteration does `O(1)` operations including `popcount` which is constant-time for 64-bit. So overall `O(B)` which is `O(1)` practically.
- **Space complexity:** `O(1)`.

---

# Code

```typescript
function minOperations(num1: number, num2: number): number {
    // helper: count number of set bits in a non-negative integer (64-bit safe)
    function popcount(x: number): number {
        // use JavaScript's number (double), but bit ops operate on 32-bit.
        // For T possibly larger than 2^31, use loop with BigInt for correctness.
        let bx = BigInt(x);
        let cnt = 0;
        while (bx > 0n) {
            if ((bx & 1n) === 1n) cnt++;
            bx = bx >> 1n;
        }
        return cnt;
    }

    // Reasonable upper bound for number of operations:
    const MAX_K = 100; // 100 >= 60 (bits), safe for constraints here

    for (let k = 1; k <= MAX_K; k++) {
        // T = num1 - k * num2
        const Tbig = BigInt(num1) - BigInt(k) * BigInt(num2);
        if (Tbig < BigInt(k)) continue; // T < k -> can't split into k powers
        // Convert Tbig to number if small; popcount uses BigInt internally
        const pc = popcount(Number(Tbig)); // Number(Tbig) is safe here because Tbig fits in JS number usually
        // But to be fully safe use BigInt version in popcount:
        // We'll call popcount using BigInt path:
        // (modify popcount to accept BigInt). Simpler: recalc popcount with BigInt directly:
        // For simplicity below we compute popcount with BigInt explicitly.
        // We'll reimplement popcount for BigInt here:
        let bb = Tbig;
        let cnt = 0;
        while (bb > 0n) {
            if ((bb & 1n) === 1n) cnt++;
            bb >>= 1n;
        }
        // now cnt is popcount(T)
        if (cnt <= k && BigInt(k) <= Tbig) {
            return k;
        }
    }

    return -1;
};

```

*(The implementation above uses `BigInt` for correctness when `T` can be large. We iterate `k` up to `100`, which is small and fast.)*

---

## Example walkthrough

### Example 1
Input: `num1 = 3`, `num2 = -2`.

Try `k = 1`:
- `T = 3 - 1 * (-2) = 5`.  
- `popcount(5) = 2`. `2 <= 1`? no.

`k = 2`:
- `T = 3 - 2 * (-2) = 7`.  
- `popcount(7) = 3`. `3 <= 2`? no.

`k = 3`:
- `T = 3 - 3 * (-2) = 9`.  
- `popcount(9) = 2`. `2 <= 3` and `3 <= 9` → OK.  
So minimal `k = 3`. Output `3`.

### Example 2
Input: `num1 = 5`, `num2 = 7`.

Try increasing `k`:
- `k = 1`: `T = 5 - 7 = -2` -> invalid.
- `k = 2`: `T = 5 - 14 = -9` -> invalid.
For `k` increasing `T` stays negative, so no `k` satisfies conditions -> return `-1`.

---
