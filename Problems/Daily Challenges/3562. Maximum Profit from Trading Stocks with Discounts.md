[3562. Maximum Profit from Trading Stocks with Discounts](https://leetcode.com/problems/maximum-profit-from-trading-stocks-with-discounts/)

# Intuition

This is a **tree-structured knapsack with dependency-based discounts**.

Key properties:

* Employees form a rooted tree (CEO = root).
* Buying a stock is optional and costs budget.
* Profit is `future[i] - buyPrice`.
* If a boss is bought, their **direct children get a discounted price**.
* Discount only depends on whether the **parent is bought**, not ancestors.
* Budget is small (≤ 160), n is moderate (≤ 160).

This forces:

* Tree DP
* Knapsack-style budget transitions
* Two states per node: parent bought vs parent not bought

---

# Core Idea

For every employee `u`, compute DP arrays:

* `dp0[b]`: max profit using `b` budget in subtree of `u` **when parent of `u` is NOT bought**
* `dp1[b]`: max profit using `b` budget in subtree of `u` **when parent of `u` IS bought**

Why two states:

* Determines whether `u` itself can be bought at full price or discounted price.
* Determines what discount state children inherit.


## DP Construction (Postorder DFS)

For node `u`:

1. Build adjacency list → tree
2. DFS children first
3. Merge children results using **knapsack convolution**
4. After children are merged, decide whether to buy `u`

Definitions:

* `cost = present[u]`
* `discountCost = floor(present[u] / 2)`
* `profitFull = future[u] - cost`
* `profitDiscount = future[u] - discountCost`


## Transitions

After combining children into `subProfit0` and `subProfit1`:

* **If parent not bought (dp0)**

  * Either skip `u`
  * Or buy `u` at full cost

* **If parent bought (dp1)**

  * Either skip `u`
  * Or buy `u` at discounted cost

## Why This Works

* Tree ensures no cycles
* Parent decision only affects direct children
* Budget small → knapsack feasible
* Two-state DP cleanly models discount propagation

---

# Complexity

* Tree DP with knapsack merging
* **Time:** `O(n * budget²)` → `160 * 160²` acceptable
* **Space:** `O(n * budget)`

---

# Code

```ts
function maxProfit(
    n: number,
    present: number[],
    future: number[],
    hierarchy: number[][],
    budget: number,
): number {
    const g: number[][] = Array.from({ length: n }, () => []);

    for (const [u, v] of hierarchy) {
        g[u - 1].push(v - 1);
    }

    const dfs = (u: number): [number[], number[], number] => {
        const cost = present[u];
        const dCost = Math.floor(cost / 2);

        const dp0 = new Array(budget + 1).fill(0);
        const dp1 = new Array(budget + 1).fill(0);

        let sub0 = new Array(budget + 1).fill(0);
        let sub1 = new Array(budget + 1).fill(0);

        let size = 0;

        for (const v of g[u]) {
            const [v0, v1, vSize] = dfs(v);
            size += vSize;

            const next0 = new Array(budget + 1).fill(0);
            const next1 = new Array(budget + 1).fill(0);

            for (let i = 0; i <= budget; i++) {
                for (let j = 0; j <= Math.min(i, vSize); j++) {
                    next0[i] = Math.max(next0[i], sub0[i - j] + v0[j]);
                    next1[i] = Math.max(next1[i], sub1[i - j] + v1[j]);
                }
            }

            sub0 = next0;
            sub1 = next1;
        }

        for (let b = 0; b <= budget; b++) {
            dp0[b] = sub0[b];
            dp1[b] = sub0[b];

            if (b >= cost) {
                dp0[b] = Math.max(dp0[b], sub1[b - cost] + future[u] - cost);
            }

            if (b >= dCost) {
                dp1[b] = Math.max(dp1[b], sub1[b - dCost] + future[u] - dCost);
            }
        }

        return [dp0, dp1, size + cost];
    };

    return dfs(0)[0][budget];
};

```

---

# Example Walkthrough

```
complexity:
1
|
2
|
3

present = [5,2,3]
future  = [8,5,6]
budget = 7
```

* Buy 1 at cost 5 → profit 3
* Buy 2 at discounted cost 1 → profit 4
* Buy 3 at discounted cost 1 → profit 5
* Total cost = 7
* Total profit = 12

Tree DP allows buying all three because discounts cascade **downwards only**.

---

**Final Result**

This solution correctly handles:

* Hierarchical dependency
* Conditional discounts
* Budget constraints
* Optimal global selection
