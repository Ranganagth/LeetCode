[3397. Maximum Number of Distinct Elements After Operations](https://leetcode.com/problems/maximum-number-of-distinct-elements-after-operations/)

# Intuition

We are given an array `nums` and an integer `k`.
For each element, we can add any value from the range `[-k, k]` **at most once**.
Our goal is to **maximize the number of distinct elements** after performing the operations optimally.

In other words:

* For each number `x`, we can make it any integer in `[x - k, x + k]`.
* We need to pick values (within those ranges) so that the final numbers are as distinct as possible.

## Core Idea

Think of each element as a *range of possible values*:

```
nums[i] → [nums[i] - k, nums[i] + k]
```

We want to **assign values** from these ranges to **maximize unique values**.

### Key Insight:

If we process numbers in **sorted order**, and try to greedily assign the smallest possible available value within each range, we can ensure:

* Minimum overlap between intervals
* Maximum number of unique numbers

This is similar to the classic “assign intervals to unique points” greedy problem.

---

# Approach

1. **Sort the array** `nums` — ensures we handle smaller intervals first.
2. Maintain a variable `nextAvailable` — the next smallest integer we can assign to ensure uniqueness.
3. For each element:

   * The element can take any value in `[nums[i] - k, nums[i] + k]`.
   * To maximize distinctness:

     * If `nextAvailable < nums[i] - k`, move `nextAvailable` up to `nums[i] - k` (the start of its range).
     * If `nextAvailable <= nums[i] + k`, we can assign `nextAvailable` to this element and increment it (since it’s now used).
     * Otherwise, skip (can’t assign a unique number from this range).

---

### Algorithm Example

#### Example 1:

```
nums = [1, 2, 2, 3, 3, 4], k = 2
```

After sorting: `[1, 2, 2, 3, 3, 4]`
Each element’s range:

```
1 → [-1, 3]
2 → [0, 4]
2 → [0, 4]
3 → [1, 5]
3 → [1, 5]
4 → [2, 6]
```

Now assign greedily:

| Element | Range   | nextAvailable | Assigned | New nextAvailable |
| ------- | ------- | ------------- | -------- | ----------------- |
| 1       | [-1, 3] | -∞ → -1       | -1       | 0                 |
| 2       | [0, 4]  | 0             | 0        | 1                 |
| 2       | [0, 4]  | 1             | 1        | 2                 |
| 3       | [1, 5]  | 2             | 2        | 3                 |
| 3       | [1, 5]  | 3             | 3        | 4                 |
| 4       | [2, 6]  | 4             | 4        | 5                 |

Assigned values = `[-1, 0, 1, 2, 3, 4]`
Distinct count = **6**

---

#### Example 2:

```
nums = [4, 4, 4, 4], k = 1
```

Each range = `[3, 5]`

| Element | Range  | nextAvailable    | Assigned | New nextAvailable |
| ------- | ------ | ---------------- | -------- | ----------------- |
| 4       | [3, 5] | 3                | 3        | 4                 |
| 4       | [3, 5] | 4                | 4        | 5                 |
| 4       | [3, 5] | 5                | 5        | 6                 |
| 4       | [3, 5] | 6 (out of range) | —        | —                 |

Distinct values = `[3, 4, 5]` → **3**

---

# Complexity Analysis

| Type      | Complexity   | Reason                      |
| --------- | ------------ | --------------------------- |
| **Time**  | `O(n log n)` | Sorting the array dominates |
| **Space** | `O(1)`       | Only a few variables used   |

---

# Code

```typescript
function maxDistinctElements(nums: number[], k: number): number {
    nums.sort((a, b) => a - b);
    let nextAvailable = -Infinity;
    let distinctCount = 0;

    for (const num of nums) {
        const low = num - k;
        const high = num + k;

        // Ensure nextAvailable is within this range
        if (nextAvailable < low) nextAvailable = low;

        if (nextAvailable <= high) {
            distinctCount++;
            nextAvailable++; // use this number
        }
    }

    return distinctCount;
};

```

---

## Walkthrough Example

### Input:

```ts
nums = [1, 2, 2, 3, 3, 4];
k = 2;
```

### Execution:

| i | num | range  | nextAvailable (before) | assigned | nextAvailable (after) |
| - | --- | ------ | ---------------------- | -------- | --------------------- |
| 1 | 1   | [-1,3] | -∞ → -1                | -1       | 0                     |
| 2 | 2   | [0,4]  | 0                      | 0        | 1                     |
| 3 | 2   | [0,4]  | 1                      | 1        | 2                     |
| 4 | 3   | [1,5]  | 2                      | 2        | 3                     |
| 5 | 3   | [1,5]  | 3                      | 3        | 4                     |
| 6 | 4   | [2,6]  | 4                      | 4        | 5                     |
**Total distinct = 6**

## Final Output

```
Input: nums = [1, 2, 2, 3, 3, 4], k = 2
Output: 6
```

---

## Summary

| Step | Concept                      | Description                                               |
| ---- | ---------------------------- | --------------------------------------------------------- |
| 1    | Sort `nums`                  | Handle ranges in increasing order                         |
| 2    | Use `nextAvailable`          | Track next unique assignable value                        |
| 3    | Greedy assignment            | Always pick the smallest valid unused number in the range |
| 4    | Count successful assignments | Equals max number of distinct elements                    |
