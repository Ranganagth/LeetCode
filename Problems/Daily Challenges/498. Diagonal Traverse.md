[498. Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)

# Intuition

When traversing diagonally in a matrix, elements are grouped by the sum of their indices `(i + j)`.

* If `(i + j)` is **even**, we traverse the diagonal **upwards (right-to-left)**.
* If `(i + j)` is **odd**, we traverse the diagonal **downwards (left-to-right)**.

This alternating traversal ensures we capture the zigzag diagonal order.

---

# Approach

1. Iterate over the matrix with indices `(i, j)` where `i` is the row and `j` is the column.
2. Group elements based on their diagonal key `d = i + j`.
3. Store elements in a map/array keyed by `d`.

   * If `d` is even → push elements in reverse order later.
   * If `d` is odd → keep elements in the same order.
4. Flatten the diagonals into a single output array.

This avoids repeatedly switching direction mid-traversal and is straightforward.

---

# Complexity

* **Time complexity:**
  Each element is visited exactly once → **O(m \* n)**
* **Space complexity:**
  Output array of size `m * n` + minor extra space for diagonal grouping → **O(m \* n)**

---

# Code

```typescript
function findDiagonalOrder(mat: number[][]): number[] {
    const m = mat.length;
    const n = mat[0].length;
    const diagonals: Map<number, number[]> = new Map();

    // Group elements by sum of indices
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            const d = i + j;
            if (!diagonals.has(d)) {
                diagonals.set(d, []);
            }
            diagonals.get(d)!.push(mat[i][j]);
        }
    }

    const result: number[] = [];
    for (let [d, arr] of diagonals.entries()) {
        if (d % 2 === 0) {
            result.push(...arr.reverse()); // reverse on even diagonals
        } else {
            result.push(...arr); // keep as is on odd diagonals
        }
    }

    return result;
}
```

---

# Example walkthrough with explanation

### Example 1

`mat = [[1,2,3],[4,5,6],[7,8,9]]`

* Diagonal 0: `[1]` → even → reverse → `[1]`
* Diagonal 1: `[2,4]` → odd → `[2,4]`
* Diagonal 2: `[3,5,7]` → even → reversed → `[7,5,3]`
* Diagonal 3: `[6,8]` → odd → `[6,8]`
* Diagonal 4: `[9]` → even → `[9]`

Final result: **\[1,2,4,7,5,3,6,8,9]**

---
