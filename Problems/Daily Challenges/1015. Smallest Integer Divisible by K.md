[1015. Smallest Integer Divisible by K](https://leetcode.com/problems/smallest-integer-divisible-by-k/)

# Intuition

The number is made only of digit `1`:
`1, 11, 111, 1111, ...`
These numbers grow too large to store, but we do not need the number itself — only its remainder modulo `k`.

Let `r(i)` = remainder of the number consisting of `i` ones.
Then:

```
r(1) = 1 % k
r(i) = (r(i-1) * 10 + 1) % k
```

We search for the smallest `i` such that `r(i) = 0`.

However:
If `k` has factor 2 or 5, no number made only of ones can be divisible by k → return `-1`.

Reason: numbers made of all ones always end with digit 1 → cannot be divisible by 2 or 5.

---

# Approach

1. If `k % 2 === 0` or `k % 5 === 0`, return -1.
2. Start with `remainder = 0`.
3. For `i` from 1 to k (pigeonhole principle guarantees answer within k steps):

   * Update remainder: `remainder = (remainder * 10 + 1) % k`
   * If `remainder === 0`, return i.
4. If not found, return -1.

---

# Complexity

* **Time:** O(k)
* **Space:** O(1)

---

# Code

```ts
function smallestRepunitDivByK(k: number): number {
    if (k % 2 === 0 || k % 5 === 0) return -1;

    let remainder = 0;

    for (let length = 1; length <= k; length++) {
        remainder = (remainder * 10 + 1) % k;
        if (remainder === 0) return length;
    }

    return -1;
};

```

---

# Example Walkthrough

### Example: k = 3

We compute remainders:

1. length = 1 → number = 1
   remainder = 1 % 3 = 1

2. length = 2 → number = 11
   remainder = (1 * 10 + 1) % 3 = 2

3. length = 3 → number = 111
   remainder = (2 * 10 + 1) % 3 = 0

Remainder becomes zero at length **3** → answer is **3**.

### Example: k = 2

Ends with 1 → never divisible by 2.
Return **-1**.

### Example: k = 1

1 % 1 = 0 → answer is **1**.

---

