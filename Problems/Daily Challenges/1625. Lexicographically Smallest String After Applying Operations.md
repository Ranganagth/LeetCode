[1625. Lexicographically Smallest String After Applying Operations](https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/)

## Problem Understanding

We are given:

* A numeric string `s` (even length)
* Two integers `a` and `b`
* Two operations we can perform any number of times:

  1. **Add Operation:** Add `a` to all digits at odd indices (`1, 3, 5, ...`) modulo 10.
  2. **Rotate Operation:** Rotate the string right by `b` positions.

We can apply both operations any number of times and in any order.
We need to find the **lexicographically smallest possible string** after performing any sequence of these operations.

---

# Intuition

This is a **state exploration problem**:

* Each operation changes the string deterministically.
* There are only finitely many distinct possible strings (since each digit is 0–9 and the string length ≤ 100).

We can model this as a **graph traversal problem**:

* Each node = a string configuration.
* Each edge = one of the two operations (add or rotate).
* We want the smallest string lexicographically among all reachable states.

Thus, the correct approach is to use **BFS (Breadth First Search)** or **DFS** with a `visited` set to avoid cycles.

## Key Observations

1. **Finite states:**

   * There are at most `10 * n` distinct configurations because:

     * Only 10 possible "add" results (0–9) per odd index.
     * Only `n` possible rotations.

2. **The order of applying operations doesn’t matter infinitely —**
   BFS ensures we explore all reachable states systematically.

3. **Lexicographically smallest string search —**
   Simply compare strings as we explore.

---

# Approach

1. Use a **queue** (BFS) initialized with the original string.
2. Maintain a `visited` set to avoid repeating states.
3. While queue is not empty:

   * Pop one string `cur`.
   * Update answer if `cur` is lexicographically smaller than current best.
   * Generate next states:

     * **Operation 1:** Add `a` to odd indices → new string `addStr`
     * **Operation 2:** Rotate right by `b` → new string `rotStr`
   * If either new string hasn’t been visited, push it into the queue.
4. After exploration, return the smallest string found.

---

# Complexity Analysis

| Type      | Complexity      | Reason                                                           |
| --------- | --------------- | ---------------------------------------------------------------- |
| **Time**  | `O(10 * n * n)` | BFS visiting at most 10×n states, each costing O(n) to transform |
| **Space** | `O(10 * n)`     | To store visited states                                          |

Given `n ≤ 100`, this is efficient.

---

# Code

```typescript
function findLexSmallestString(s: string, a: number, b: number): string {
    const visited = new Set<string>();
    const queue: string[] = [s];
    let smallest = s;
    const n = s.length;

    const addOperation = (str: string): string => {
        const arr = str.split('').map(Number);
        for (let i = 1; i < n; i += 2) {
            arr[i] = (arr[i] + a) % 10;
        }
        return arr.join('');
    };

    const rotateOperation = (str: string): string => {
        return str.slice(n - b) + str.slice(0, n - b);
    };

    while (queue.length > 0) {
        const cur = queue.shift()!;
        if (visited.has(cur)) continue;
        visited.add(cur);

        // Update smallest string if found smaller
        if (cur < smallest) smallest = cur;

        // Generate next states
        const added = addOperation(cur);
        const rotated = rotateOperation(cur);

        if (!visited.has(added)) queue.push(added);
        if (!visited.has(rotated)) queue.push(rotated);
    }

    return smallest;
};

```

---

## Example Walkthrough

### Example 1:

```
Input: s = "5525", a = 9, b = 2
```

1. Start = `"5525"`
2. Apply operations:

| Step | Operation         | Result   |
| ---- | ----------------- | -------- |
| 1    | Rotate            | `"2555"` |
| 2    | Add (odd indices) | `"2454"` |
| 3    | Add again         | `"2353"` |
| 4    | Rotate            | `"5323"` |
| 5    | Add twice         | `"5121"` |
| 6    | Rotate            | `"2151"` |
| 7    | Add               | `"2050"` |

 The lexicographically smallest string = `"2050"`

---

### Example 2:

```
Input: s = "74", a = 5, b = 1
```

* Start = `"74"`
* Rotate → `"47"`
* Add (odd index only) → `"42"`
* Rotate → `"24"`

 Smallest = `"24"`


### Example 3:

```
Input: s = "0011", a = 4, b = 2
```

* Adding to odd indices cycles through same pattern (0–9) but none produce smaller lexicographic order.
* Rotating by 2 yields same pattern.
  Smallest = `"0011"`

---

## Summary

| Step | Concept                   | Description                                           |
| ---- | ------------------------- | ----------------------------------------------------- |
| 1    | BFS over states           | Explore all possible strings by performing add/rotate |
| 2    | Track visited             | Prevent infinite cycles                               |
| 3    | Compare lexicographically | Keep track of smallest string found                   |
| 4    | Efficiency                | O(n²) with small constant — feasible for n ≤ 100      |

---
