[2435. Paths in Matrix Whose Sum Is Divisible by K](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/)

# Intuition

The sum along any valid path depends only on the sequence of cells chosen while moving down or right.  
Instead of storing the full sum (which can be large), we only care about its remainder modulo `k`, because a path is valid if the final sum `% k == 0`.

Thus, we treat the problem as counting how many ways we can reach each cell `(i, j)` with every possible remainder value from `0 .. k-1`.

This turns into a dynamic programming problem where each state tracks:

- position `(i, j)`
- remainder of the sum modulo `k`

---

# Approach

Use 3D DP:

`dp[i][j][r] = number of ways to reach cell (i, j) with total sum ≡ r (mod k)`

Transition:

From top:  
`dp[i][j][newR] += dp[i-1][j][oldR]`

From left:  
`dp[i][j][newR] += dp[i][j-1][oldR]`

Where:

```
value = grid[i][j] % k
newR = (oldR + value) % k
```

Initialize start cell:

```
dp[0][0][grid[0][0] % k] = 1
```

Final answer is `dp[m-1][n-1][0]` because remainder `0` means divisible by `k`.

Since `m * n ≤ 50,000`, using a 3D DP with size `m * n * k` is efficient enough.

Apply modulo `1e9 + 7` to avoid overflow.

---

# Complexity

- **Time Complexity:** O(m × n × k)
    
- **Space Complexity:** O(m × n × k)

---

# Code

```ts
function numberOfPaths(grid: number[][], k: number): number {
    const MOD = 1_000_000_007;
    const m = grid.length, n = grid[0].length;
    
    const dp: number[][][] = Array.from({ length: m }, () => 
        Array.from({ length: n }, () => Array(k).fill(0))
    );
    
    dp[0][0][grid[0][0] % k] = 1;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            const value = grid[i][j] % k;

            if (i > 0) {
                for (let r = 0; r < k; r++) {
                    dp[i][j][(r + value) % k] = 
                        (dp[i][j][(r + value) % k] + dp[i - 1][j][r]) % MOD;
                }
            }

            if (j > 0) {
                for (let r = 0; r < k; r++) {
                    dp[i][j][(r + value) % k] = 
                        (dp[i][j][(r + value) % k] + dp[i][j - 1][r]) % MOD;
                }
            }
        }
    }

    return dp[m - 1][n - 1][0];
};

```

---

# Example Walkthrough

**Input:**

```
grid = [[5,2,4],
        [3,0,5],
        [0,7,2]], k = 3
```

Start at `(0,0)`:

- `dp[0][0][5 % 3 = 2] = 1`
    

Iterate through grid:

- At `(0,1)` value = 2 → sum paths from left
    
- At `(1,0)` value = 3 → sum paths from top
    
- Continue filling dp states…
    

Finally at `(2,2)` (bottom-right):

We find `dp[2][2][0] = 2`.

Meaning there are **exactly two** valid paths where total sum is divisible by `3`.

---
