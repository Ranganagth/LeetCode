[2092. Find All People With Secret](https://leetcode.com/problems/find-all-people-with-secret/)

# Intuition

The secret spreads **only through meetings**, and **time matters**.

Key properties:

* Person `0` and `firstPerson` know the secret at time `0`.
* Meetings at the **same time** allow *instantaneous chain sharing*.
* Meetings at **different times** are independent; secret cannot travel backward in time.

So for each timestamp:

* If at least one person in a connected group knows the secret **at that time**, then **everyone in that group gets it**.
* But that connectivity **must not persist across different times** unless the secret truly spreads.

This naturally leads to **processing meetings grouped by time**, using **temporary union-find** per time block.

## Core Insight

You must **union people only within the same time**, propagate the secret inside that group, then **reset connections** before the next time.

Global union-find fails because it leaks connections across time.

---

# Approach

1. Sort all meetings by `time`.
2. Maintain a boolean array `knowsSecret`.
   * Initially: `knowsSecret[0] = knowsSecret[firstPerson] = true`.
1. Process meetings **grouped by identical time**:
   * For that time:
     * Union all participants of those meetings (temporary DSU).
     * If **any person in a component knows the secret**, mark **entire component** as knowing it.
   * After finishing this time:
     * Reset DSU for only the nodes involved (discard temporary connectivity).
4. Collect all people who know the secret.


## Why this works

* Instantaneous sharing within the same time is captured by union-find.
* Resetting DSU prevents illegal sharing across time.
* Complexity stays linearithmic.

---

# Complexity

* **Time:** `O(m log m + m α(n))`
  * Sorting meetings dominates

* **Space:** `O(n + m)`

---

# Code

```ts
function findAllPeople(
    n: number,
    meetings: number[][],
    firstPerson: number
): number[] {
    meetings.sort((a, b) => a[2] - b[2]);

    const knows = new Array(n).fill(false);
    knows[0] = true;
    knows[firstPerson] = true;

    const parent = new Array(n).fill(0).map((_, i) => i);

    const find = (x: number): number => {
        if (parent[x] !== x) parent[x] = find(parent[x]);
        return parent[x];
    };

    const union = (a: number, b: number) => {
        a = find(a);
        b = find(b);
        if (a !== b) parent[b] = a;
    };

    let i = 0;
    while (i < meetings.length) {
        const time = meetings[i][2];
        const participants = new Set<number>();

        // union all meetings at this time
        let j = i;
        while (j < meetings.length && meetings[j][2] === time) {
            const [x, y] = meetings[j];
            union(x, y);
            participants.add(x);
            participants.add(y);
            j++;
        }

        // check which components have the secret
        const groupHasSecret = new Map<number, boolean>();
        for (const p of participants) {
            const root = find(p);
            if (!groupHasSecret.has(root)) {
                groupHasSecret.set(root, false);
            }
            if (knows[p]) {
                groupHasSecret.set(root, true);
            }
        }

        // spread secret inside groups
        for (const p of participants) {
            if (groupHasSecret.get(find(p))!) {
                knows[p] = true;
            }
        }

        // reset DSU for next time
        for (const p of participants) {
            parent[p] = p;
        }

        i = j;
    }

    const result: number[] = [];
    for (let i = 0; i < n; i++) {
        if (knows[i]) result.push(i);
    }
    return result;
};

```

---

# Example Walkthrough

**Example :**

```
n = 4
meetings = [[3,1,3],[1,2,2],[0,3,3]]
firstPerson = 3
```

**Initial:**

```
knows = {0,3}
```

**Time = 2:**

```
Meeting: (1,2)
Neither knows → nothing spreads
```

**Time = 3:**

```
Meetings: (3,1), (0,3)
Union {0,1,3}
Group contains secret → all get secret
```

**Final:**

```
{0,1,3}
```

---

## Key Takeaway

This problem is not graph traversal — it is **time-partitioned connectivity**.
Union only what exists *at the same time*, propagate, then forget.
