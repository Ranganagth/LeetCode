[3346. Maximum Frequency of an Element After Performing Operations I](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/)

# Intuition

We want to **maximize the frequency** of a single number in the array after performing up to `numOperations` modifications.
Each modification allows us to pick one index `i` (only once) and add any value between `[-k, k]` to `nums[i]`.

So, for each number `x` in the sorted array:

* We can potentially modify nearby numbers (within `x - k` and `x + k`) to make them equal to `x`.
* But we can only change at most `numOperations` numbers.

Hence, we want to **find the maximum possible number of elements that can fall within a range of length `2k`**, centered around some target value.

---

# Approach

1. **Sort the array.**
   Sorting makes it easier to work with value ranges and use binary search.

2. **Pre-calculate frequency counts** of each unique number — stored in a `Map<number, number>`.

3. **Binary search helpers**
   Implement two helper functions:

   * `leftBound(value)` → smallest index where `nums[idx] >= value`
   * `rightBound(value)` → largest index where `nums[idx] <= value`

4. **For each candidate integer `i` from smallest to largest number in `nums`:**

   * Find the range `[i - k, i + k]`.
   * Use binary search to find indices `l` and `r` → count of numbers within this range.
   * If `i` already appears in array, we can **add up to `numOperations` more** of them (from elements in that range).
   * But we cannot exceed `r - l + 1`, because only elements within that range can be modified into `i`.

   So:

   ```
   tempAns = min(r - l + 1, numCount[i] + numOperations)
   ```

5. **Keep track of maximum `ans`** seen across all possible `i`.

---

# Complexity

* **Sorting:** `O(n log n)`
* **Binary search per element:** `O(log n)`
* **Looping through value range (maxValue - minValue):** In worst case, `10^5` (bounded by constraints).

Overall:

* **Time:** `O(n log n + R log n)` where `R = max(nums) - min(nums)`
* **Space:** `O(n)` for map and sorted array.

---

# Code

```typescript
function maxFrequency(nums: number[], k: number, numOperations: number): number {
  nums.sort((a, b) => a - b);

  let ans = 0;
  const numCount: Map<number, number> = new Map();

  let lastNumIndex = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== nums[lastNumIndex]) {
      numCount.set(nums[lastNumIndex], i - lastNumIndex);
      ans = Math.max(ans, i - lastNumIndex);
      lastNumIndex = i;
    }
  }
  numCount.set(nums[lastNumIndex], nums.length - lastNumIndex);
  ans = Math.max(ans, nums.length - lastNumIndex);

  const leftBound = (value: number) => {
    let left = 0;
    let right = nums.length - 1;
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (nums[mid] < value) left = mid + 1;
      else right = mid;
    }
    return left;
  };

  const rightBound = (value: number) => {
    let left = 0;
    let right = nums.length - 1;
    while (left < right) {
      const mid = Math.floor((left + right + 1) / 2);
      if (nums[mid] > value) right = mid - 1;
      else left = mid;
    }
    return left;
  };

  for (let i = nums[0]; i <= nums[nums.length - 1]; i++) {
    const [l, r] = [leftBound(i - k), rightBound(i + k)];

    let tempAns: number;
    if (numCount.has(i)) {
      tempAns = Math.min(r - l + 1, numCount.get(i)! + numOperations);
    } else {
      tempAns = Math.min(r - l + 1, numOperations);
    }

    ans = Math.max(ans, tempAns);
  }

  return ans;
};

```

---

## Example Walkthrough

### Example 1

```
nums = [1, 4, 5], k = 1, numOperations = 2
```

**Step 1: Sort**

```
nums = [1, 4, 5]
```

**Step 2: Frequencies**

```
numCount = { 1 → 1, 4 → 1, 5 → 1 }
```

**Step 3: Iterate possible target values**

* For `i = 4`:

  * Range = [3, 5]
  * leftBound(3) = index 1 (value 4)
  * rightBound(5) = index 2 (value 5)
  * Range covers 2 elements (4,5)
  * tempAns = min(2, 1 + 2) = 2

→ `ans = 2`

No better option found.

**Output → 2**


### Example 2

```
nums = [5, 11, 20, 20], k = 5, numOperations = 1
```

* Sort → `[5, 11, 20, 20]`
* Frequencies → `{ 5 → 1, 11 → 1, 20 → 2 }`

Try `i = 20`:

* Range = [15, 25]
* leftBound(15) = index 2
* rightBound(25) = index 3
* Range count = 2 (both 20s)
* tempAns = min(2, 2 + 1) = 2

→ **Output = 2**

---

## Final Notes

* Works efficiently for up to `10^5` numbers.
* Binary search ensures minimal overhead.
* Logic flexibly handles `numOperations = 0` and `k = 0` cases correctly.
