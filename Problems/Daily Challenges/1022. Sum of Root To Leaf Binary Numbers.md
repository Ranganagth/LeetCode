[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)

# Intuition

Each **root → leaf path** forms a binary number.

Example:

```
1 → 0 → 1

Binary = 101
Decimal = 5
```

Instead of storing the entire binary string, construct the number while traversing.

Binary property:

```
Appending a bit:

current = previous << 1 + bit
```

Example:

```
previous = 10 (binary 1010)

append 1:

1010 << 1 = 10100
10100 + 1 = 10101
```

Equivalent to:

```
current = previous * 2 + node.val
```

Thus:

* Traverse tree.
* Carry accumulated binary value.
* When reaching a leaf → add value to total sum.

---

# Approach

Use **DFS traversal**.

At each node:

```
currentValue = (previousValue << 1) | node.val
```

(`|` works because node value is only `0` or `1`)

If node is a leaf:

```
add to result.
```

Otherwise:

```
continue DFS left and right.
```

## Algorithm

```
DFS(node, value):

    if node null:
        return

    value = value * 2 + node.val

    if leaf:
        add value into answer

    DFS(left)
    DFS(right)
```

---

# Complexity

Let:

```
N = number of nodes
```

### Time Complexity

Each node visited once:

```
O(N)
```

### Space Complexity

Recursive stack depth equals tree height.

Worst case (skewed tree):

```
O(N)
```

Balanced tree:

```
O(log N)
```

---

# Code

Standard TreeNode definition:

```typescript
class TreeNode {
    val: number
    left: TreeNode | null
    right: TreeNode | null

    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = val ?? 0
        this.left = left ?? null
        this.right = right ?? null
    }
}
```

### DFS Solution

```typescript
function sumRootToLeaf(root: TreeNode | null): number {

    let total = 0;

    function dfs(node: TreeNode | null, current: number): void {

        if (!node) return;

        // build binary number
        current = (current << 1) | node.val;

        // leaf node
        if (!node.left && !node.right) {
            total += current;
            return;
        }

        dfs(node.left, current);
        dfs(node.right, current);
    }

    dfs(root, 0);

    return total;
};

```

---

# Example Walkthrough

## Example 1

Input:

```
root = [1,0,1,0,1,0,1]
```

Tree:

```
        1
      /   \
     0     1
    / \   / \
   0  1  0   1
```

### Path 1

```
1 → 0 → 0

Binary:

1
10
100 = 4
```

### Path 2

```
1 → 0 → 1

1
10
101 = 5
```

### Path 3

```
1 → 1 → 0

1
11
110 = 6
```

### Path 4

```
1 → 1 → 1

1
11
111 = 7
```

### Sum

```
4 + 5 + 6 + 7 = 22
```

Output:

```
22
```

---

## Example 2

```
root = [0]
```

Single node.

Binary:

```
0 = 0
```

Output:

```
0
```
