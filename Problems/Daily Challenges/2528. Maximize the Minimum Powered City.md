[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)

# Intuition

We are asked to maximize the **minimum power** among all cities after adding `k` new power stations optimally.

### Key observations:

* Each city’s **power** depends on the number of stations in its surrounding range `[i - r, i + r]`.
* When we add a new power station, it affects **multiple cities** within that range.
* The challenge is **where to place** the new stations to maximize the **minimum power** across all cities.

This is a **“maximize minimum”** type problem — a common signal for **binary search on the answer**.

---

# Approach

We’ll use **Binary Search + Sliding Window (Prefix Sum Trick)**.

### 1. Compute initial power for each city

We can precompute the initial power of each city using a **difference array technique** in O(n):

For each station `i`:

* It adds `stations[i]` power to all cities in range `[i - r, i + r]`.
* We use a difference array to efficiently update ranges.

### 2. Binary search on the answer

Let’s define:

> `check(val)` → returns **true** if we can make every city have power ≥ `val` using ≤ k new stations.

We’ll binary search for the **largest possible val** that returns `true`.

### 3. The `check()` function

We simulate city-by-city:

* Maintain current power using a running sum (`sum`).
* If a city’s power `< val`, we need to **add new stations** to increase it.
* We add the missing amount at the **farthest reachable point** that still benefits this city — i.e., city `i + r`.

We use a temporary difference array `diff[]` to simulate these virtual additions without recalculating from scratch.

If at any point we need more than `k` total new stations → return `false`.

Otherwise, return `true`.

### 4. Binary Search Boundaries

* Lower bound (`lo`): minimum current power
* Upper bound (`hi`): total current power + k (worst case, if all stations help one city)
* We keep searching until `lo > hi`.

---

# Complexity Analysis

| Operation                      | Complexity             |
| ------------------------------ | ---------------------- |
| Preprocessing difference array | O(n)                   |
| Each `check(val)`              | O(n)                   |
| Binary search steps            | O(log(maxPower))       |
| **Total**                      | **O(n log(maxPower))** |

Where `maxPower` ≈ sum of all stations + k (can go up to ~10¹⁴ but log scale keeps it efficient).

Works efficiently for `n ≤ 10⁵`.

---

# Code

```typescript
function maxPower(stations: number[], r: number, k: number): number {
    const n = stations.length;
    const cnt: number[] = new Array(n + 1).fill(0);

    // Build difference array
    for (let i = 0; i < n; i++) {
        const left = Math.max(0, i - r);
        const right = Math.min(n, i + r + 1);
        cnt[left] += stations[i];
        cnt[right] -= stations[i];
    }

    // Check if possible to achieve at least `val` min power
    const check = (val: number): boolean => {
        const diff = [...cnt];
        let sum = 0;
        let remaining = k;

        for (let i = 0; i < n; i++) {
            sum += diff[i];
            if (sum < val) {
                const add = val - sum; // how much power we need to reach val
                if (remaining < add) return false;
                remaining -= add;
                sum += add;
                const end = Math.min(n, i + 2 * r + 1);
                diff[end] -= add;
            }
        }
        return true;
    };

    let lo = Math.min(...stations);
    let hi = stations.reduce((a, b) => a + b, 0) + k;
    let res = 0;

    while (lo <= hi) {
        const mid = Math.floor(lo + (hi - lo) / 2);
        if (check(mid)) {
            res = mid;
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }
    return res;
};

```

---

## Example Walkthrough

### Input:

```
stations = [1, 2, 4, 5, 0]
r = 1
k = 2
```

### Step 1: Initial power per city

Each station at index `i` affects `[i - 1, i + 1]`.

| City | Power coverage from stations | Power |
| ---- | ---------------------------- | ----- |
| 0    | 1 + 2                        | 3     |
| 1    | 1 + 2 + 4                    | 7     |
| 2    | 2 + 4 + 5                    | 11    |
| 3    | 4 + 5 + 0                    | 9     |
| 4    | 5 + 0                        | 5     |

So initial powers = `[3, 7, 11, 9, 5]`, min = 3.

### Step 2: Binary search

We try increasing `val` (minimum power goal) and check feasibility.

#### Check `val = 5`

* City 0 has 3 (<5) → need 2 new stations near 0+r=1.

  * Remaining k = 2 - 2 = 0
  * Updated diff makes other cities get benefit from these new stations.
* All cities now ≥ 5 → feasible.

#### Check `val = 6`

* City 0 has 3 (<6) → need 3 new stations.

  * Remaining k = 2 < 3 → not feasible.

Hence, **max val = 5**.

**Output: 5**

---

## Summary

| Concept          | Explanation                                                                                 |
| ---------------- | ------------------------------------------------------------------------------------------- |
| Problem type     | Maximize the minimum                                                                        |
| Strategy         | Binary search on answer                                                                     |
| Helper function  | Greedy + sliding window (difference array)                                                  |
| Time Complexity  | O(n log(sum(stations) + k))                                                                 |
| Space Complexity | O(n)                                                                                        |
| Key insight      | Adding new stations affects a range of cities; simulate efficiently using prefix difference |

---
