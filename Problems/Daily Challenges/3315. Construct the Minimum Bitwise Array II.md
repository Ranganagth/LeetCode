[3315. Construct the Minimum Bitwise Array II](https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/)

# Intuition

We need the **smallest non-negative integer `x`** such that:

```
x OR (x + 1) = p
```

where `p` is a **prime number**.

The key is to understand **how `x OR (x + 1)` behaves in binary**.

---
# Approach

## Bitwise Insight

Consider how adding `1` works in binary:

* All **trailing 1s** become `0`
* The first `0` to the left becomes `1`

Example:

```
x      = 010111
x + 1  = 011000
OR     = 011111
```

### Critical observation

`x OR (x + 1)` always produces a number whose **least significant bits are all 1s**.

Therefore:

* If `p` **ends with `t` trailing 1s**, then `x` must end with **`t-1` trailing 1s**
* If `p` is even → impossible (OR result is always odd)

---

## When is it impossible?

If `p` is **even**:

* `x OR (x + 1)` is always odd
* So **no solution exists**

```
p = 2 → ans = -1
```

## How to construct the minimum `x`

Let:

* `t` = number of trailing `1`s in `p`

Then the **smallest valid `x`** is obtained by:

* Turning the **lowest 1-bit that participates in carry into 0**

That is:

```
x = p ^ (1 << (t - 1))
```

This:

* Preserves higher bits
* Produces the smallest possible `x`
* Ensures `x OR (x + 1) = p`

---

# Algorithm

For each `p` in `nums`:

1. If `p` is even → `ans[i] = -1`
2. Count trailing 1s in `p`
3. Compute:

   ```
   ans[i] = p ^ (1 << (trailingOnes - 1))
   ```

---

# Complexity

* **Time:** `O(n · log p)` (bit counting)
* **Space:** `O(1)`
* Optimal under constraints

---

# Code

```ts
function minBitwiseArray(nums: number[]): number[] {
    const res: number[] = [];

    for (const p of nums) {
        // Even primes have no solution
        if ((p & 1) === 0) {
            res.push(-1);
            continue;
        }

        // Count trailing ones
        let t = 0;
        let temp = p;
        while ((temp & 1) === 1) {
            t++;
            temp >>= 1;
        }

        // Remove the (t-1)th bit
        const x = p ^ (1 << (t - 1));
        res.push(x);
    }

    return res;
};

```

---

# Example Walkthrough

### Example 1

```
nums = [2,3,5,7]
```

| p | Binary | trailing 1s | x  | x OR (x+1) |
| - | ------ | ----------- | -- | ---------- |
| 2 | 10     | —           | -1 | impossible |
| 3 | 11     | 2           | 1  | 1 OR 2 = 3 |
| 5 | 101    | 1           | 4  | 4 OR 5 = 5 |
| 7 | 111    | 3           | 3  | 3 OR 4 = 7 |

Output:

```
[-1, 1, 4, 3]
```

### Example 2

```
nums = [11,13,31]
```

| p  | Binary | trailing 1s | x  |
| -- | ------ | ----------- | -- |
| 11 | 1011   | 2           | 9  |
| 13 | 1101   | 1           | 12 |
| 31 | 11111  | 5           | 15 |

Output:

```
[9, 12, 15]
```

---

## Final Insight

* `x OR (x + 1)` forces trailing 1s
* Only **odd primes** are valid
* Minimal `x` is obtained by **clearing the correct carry bit**
* Pure bit manipulation, no brute force required
