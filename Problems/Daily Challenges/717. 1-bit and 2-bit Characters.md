[717. 1-bit and 2-bit Characters](https://leetcode.com/problems/1-bit-and-2-bit-characters/)

# Intuition

The encoding rules force a deterministic parsing pattern.
A `0` always represents a one-bit character.
A `1` always starts a two-bit character: either `10` or `11`.
Because the array always ends with `0`, you only need to verify whether this last `0` stands alone or gets consumed as part of a two-bit character.

---

# Approach

Scan from left to right.
Whenever you see a `1`, skip the next bit because it forms a two-bit character.
Whenever you see `0`, move one step because it forms a one-bit character.
If the pointer lands exactly on the last index at the end, the last character is one-bit.
If the pointer jumps past it, the last character was consumed by a preceding two-bit encoding.

---

# Complexity

- **Time Complexity:** Single pass through the array - *O(n)*
- **Space Complexity:** Constant extra space - *O(1)*

---

# Code

```ts
function isOneBitCharacter(bits: number[]): boolean {
    let i = 0;
    const n = bits.length;

    while (i < n - 1) {
        if (bits[i] === 1) {
            i += 2;     // two-bit character
        } else {
            i += 1;     // one-bit character
        }
    }
    return i === n - 1;
};

```

---

# Example Walkthrough

bits = [1, 0, 0]

i = 0 → bits[0] = 1 → two-bit → i = 2
i = 2 is last index → the last character is a single `0` → true

bits = [1, 1, 1, 0]

i = 0 → bits[0] = 1 → two-bit → i = 2
i = 2 → bits[2] = 1 → two-bit → i = 4
i = 4 → out of bounds, last `0` was consumed → false
