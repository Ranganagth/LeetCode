[3583. Count Special Triplets](https://leetcode.com/problems/count-special-triplets/)

# Intuition

For every index `j`, we need:

```
nums[i] = nums[j] * 2   where i < j
nums[k] = nums[j] * 2   where k > j
```

So for each `j`, the count of valid triplets contributed is:

```
(# occurrences of nums[j] * 2 before j) × (# occurrences of nums[j] * 2 after j)
```

This avoids cubic or quadratic brute force.

---

# Approach

1. Precompute frequency of all values using a hashmap.
2. Maintain another hashmap `leftCount` that tracks elements seen so far.
3. For each index `j`:
   - Decrease count of `nums[j]` from the right frequency map, since `j` is now the middle.
   - Compute:
     ```
     leftCount[nums[j] * 2] × rightCount[nums[j] * 2]
     ```
   - Add to answer.
   - Add `nums[j]` into `leftCount`.

Modulo operations are applied throughout.

---

# Complexity

- **Time:** `O(n)`
- **Space:** `O(n)` in worst-case for maps.

---

# Code

```ts
function specialTriplets(nums: number[]): number {
    const mod = 1_000_000_007;
    const right = new Map<number, number>();
    const left = new Map<number, number>();

    for (const x of nums) {
        right.set(x, (right.get(x) || 0) + 1);
    }

    let result = 0;

    for (const x of nums) {
        right.set(x, right.get(x)! - 1);

        const target = x * 2;
        const leftCount = left.get(target) || 0;
        const rightCount = right.get(target) || 0;

        result = (result + (leftCount * rightCount) % mod) % mod;

        left.set(x, (left.get(x) || 0) + 1);
    }

    return result;
};

```

---

# Example Walkthrough

**Input:**

```
nums = [8,4,2,8,4]
```

**Processing:**

| j | nums[j] | target=2×nums[j] | countLeft[target] | countRight[target] | triplets added |
|---|---------|------------------|-------------------|--------------------|----------------|
| 0 | 8 | 16 | 0 | 0 | 0 |
| 1 | 4 | 8 | 0 | 1 | 0 |
| 2 | 2 | 4 | 1 | 1 | 1 |
| 3 | 8 | 16 | 0 | 0 | 0 |
| 4 | 4 | 8 | 1 | 0 | 1 |

**Total** = `2`