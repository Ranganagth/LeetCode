[2787. Ways to Express an Integer as Sum of Powers](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/)

# Intuition

We are looking for **the number of ways to sum unique x-th powers of positive integers to get exactly `n`**.

For example:

* If `n=10` and `x=2`,
  possible squares ≤ 10 are:
  `1² = 1`, `2² = 4`, `3² = 9`
  The only combination: `3² + 1² = 9 + 1 = 10`.

This is very similar to the **"subset sum"** problem:

* We have a set of numbers = ${1^x, 2^x, 3^x, ...}$ up to the largest number whose power ≤ n.
* We need to count subsets that sum to exactly `n`.

---

# Approach

We can solve this using **Dynamic Programming**.

Let:

* `dp[i][sum]` = number of ways to form sum `sum` using numbers starting from `i^x` (or larger).

We use recursion with memoization:

* At each step (current base number `curr`):

  1. **Include** `curr^x` in the sum (if it doesn't exceed remaining total)
  2. **Exclude** it and move to the next base number
* Stop when:

  * `sum == n` → 1 valid way
  * `sum > n` → invalid
  * `curr^x > n - sum` → can't include it

We take modulo **1e9+7** at each step.

---

# Complexity Analysis

Let `m` = largest integer whose `x`-th power ≤ `n`

* **States**: `O(m * n)`
* **Transitions**: O(1)
* **Time Complexity**: `O(m * n)`
* **Space Complexity**: `O(m * n)` (can be reduced to O(n) with bottom-up DP)

---

# Code

```ts
function numberOfWays(n: number, x: number): number {
    const MOD = 1_000_000_007;

    // Precompute powers up to n
    const powers: number[] = [];
    for (let i = 1; Math.pow(i, x) <= n; i++) {
        powers.push(Math.pow(i, x));
    }

    const m = powers.length;
    const memo: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(-1));

    function dfs(index: number, remaining: number): number {
        if (remaining === 0) return 1;
        if (index >= m || remaining < 0) return 0;
        if (memo[index][remaining] !== -1) return memo[index][remaining];

        // Option 1: skip current power
        let ways = dfs(index + 1, remaining);

        // Option 2: take current power
        ways = (ways + dfs(index + 1, remaining - powers[index])) % MOD;

        memo[index][remaining] = ways;
        return ways;
    }

    return dfs(0, n);
}
```

---

### Example Walkthrough

### Example:

```
n = 10, x = 2
```

* Powers: \[1, 4, 9]
* Start from index 0:

  * Include `1`: need sum = 9 → only option is `9` → valid way
  * Exclude `1`: try sum = 10 without it → no valid set
* Result = **1**

---

### Another Example:

```
n = 4, x = 1
```

* Powers: \[1, 2, 3, 4]
* Ways:

  * {4}
  * {3, 1}
* Total ways = **2**

---
