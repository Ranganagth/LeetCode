[401. Binary Watch](https://leetcode.com/problems/binary-watch/)

# Intuition

The watch contains:

* **4 LEDs for hours** → values `0–11`
* **6 LEDs for minutes** → values `0–59`

A time is valid if:

```
number_of_set_bits(hour) + number_of_set_bits(minute) = turnedOn
```

Since the domain is small (12 × 60 = 720 combinations), brute-force enumeration is optimal and simplest.

---

# Approach

1. Iterate all possible hours `0..11`.
2. Iterate all possible minutes `0..59`.
3. Count the number of `1` bits in both numbers.
4. If the total equals `turnedOn`, format the time:

   * hour without leading zero
   * minute with 2 digits
5. Add to result.

---

# Complexity

* Total combinations: `12 × 60 = 720`
* Bit counting constant time
* **Time:** `O(1)` (constant bounded search)
* **Space:** `O(result size)`

---

# Code

```typescript
function readBinaryWatch(turnedOn: number): string[] {
    const result: string[] = [];

    const bitCount = (x: number): number => {
        let cnt = 0;
        while (x > 0) {
            cnt += x & 1;
            x >>= 1;
        }
        return cnt;
    };

    for (let h = 0; h < 12; h++) {
        for (let m = 0; m < 60; m++) {
            if (bitCount(h) + bitCount(m) === turnedOn) {
                const minute = m.toString().padStart(2, '0');
                result.push(`${h}:${minute}`);
            }
        }
    }

    return result;
};

```

---

# Example Walkthrough

**Input:**

```
turnedOn = 1
```

Possible configurations with exactly one LED:

* One LED in minutes:

  ```
  0:01, 0:02, 0:04, 0:08, 0:16, 0:32
  ```
* One LED in hours:

  ```
  1:00, 2:00, 4:00, 8:00
  ```

**Output:**

```
["0:01","0:02","0:04","0:08","0:16","0:32",
 "1:00","2:00","4:00","8:00"]
```
