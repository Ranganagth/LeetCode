[3350. Adjacent Increasing Subarrays Detection II](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/)

# Intuition

We’re looking for two *adjacent strictly increasing* subarrays of the same length `k`:

```
nums[a .. a + k - 1]
nums[a + k .. a + 2k - 1]
```

Both must be strictly increasing.

We want the **maximum `k`** that satisfies this.

So intuitively:

* We’re looking for two consecutive *increasing runs* of length ≥ `k`.
* The end of the first increasing subarray must immediately connect to the start of the next.

## Key Observation

If we compute the **length of the current increasing sequence** at each index, we can determine:

* How long of an increasing streak ends at each position (`incLenEnd[i]`).
* How long of an increasing streak starts at each position (`incLenStart[i]`).

Then, if between index `i` and `i+1` we have:

```
nums[i] >= nums[i+1]   (the increasing sequence breaks here)
```

Then the boundary between `i` and `i+1` might separate two increasing subarrays.

At that boundary:

* The length of the left increasing run = `incLenEnd[i]`
* The length of the right increasing run = `incLenStart[i+1]`

Thus, we can form two adjacent strictly increasing subarrays of length:

```
k = min(incLenEnd[i], incLenStart[i+1])
```

We take the **maximum** of such `k` over all possible boundaries.

---

# Approach

1. **Compute left-to-right increasing streaks (`incLenEnd`):**

   * `incLenEnd[i]` = number of consecutive increasing elements ending at `i`.
   * If `nums[i] > nums[i-1]`, `incLenEnd[i] = incLenEnd[i-1] + 1`; else `1`.

2. **Compute right-to-left increasing streaks (`incLenStart`):**

   * `incLenStart[i]` = number of consecutive increasing elements starting at `i`.
   * If `nums[i] < nums[i+1]`, `incLenStart[i] = incLenStart[i+1] + 1`; else `1`.

3. **Iterate over all adjacent boundaries (i):**

   * For every break between `nums[i]` and `nums[i+1]`, compute:

     ```
     k = min(incLenEnd[i], incLenStart[i+1])
     ```
   * Track `maxK = max(maxK, k)`.

4. **Return `maxK`.**

---

# Complexity Analysis

* **Time:** `O(n)` (we traverse the array 3 times)
* **Space:** `O(n)` (to store two arrays `incLenEnd` and `incLenStart`)

---

# Code

```typescript
function maxIncreasingSubarrays(nums: number[]): number {
  const n = nums.length;
  const incLenEnd = new Array(n).fill(1);
  const incLenStart = new Array(n).fill(1);

  // Step 1: Compute increasing lengths ending at each index
  for (let i = 1; i < n; i++) {
    if (nums[i] > nums[i - 1]) {
      incLenEnd[i] = incLenEnd[i - 1] + 1;
    }
  }

  // Step 2: Compute increasing lengths starting at each index
  for (let i = n - 2; i >= 0; i--) {
    if (nums[i] < nums[i + 1]) {
      incLenStart[i] = incLenStart[i + 1] + 1;
    }
  }

  // Step 3: Check for adjacent increasing subarrays
  let maxK = 0;
  for (let i = 0; i < n - 1; i++) {
    const k = Math.min(incLenEnd[i], incLenStart[i + 1]);
    maxK = Math.max(maxK, k);
  }

  return maxK;
};

```

---

## Example Walkthrough

### Example 1:

```
nums = [2,5,7,8,9,2,3,4,3,1]
```

#### Step 1: incLenEnd

```
nums:        2  5  7  8  9  2  3  4  3  1
incLenEnd:   1  2  3  4  5  1  2  3  1  1
```

#### Step 2: incLenStart

```
nums:        2  5  7  8  9  2  3  4  3  1
incLenStart: 5  4  3  2  1  3  2  1  1  1
```

#### Step 3: Compute adjacent boundaries

| i   | incLenEnd[i] | incLenStart[i+1] | min | maxK  |
| --- | ------------ | ---------------- | --- | ----- |
| 0   | 1            | 4                | 1   | 1     |
| 1   | 2            | 3                | 2   | 2     |
| 2   | 3            | 2                | 2   | 2     |
| 3   | 4            | 1                | 1   | 2     |
| 4   | 5            | 3                | 3   | **3** |
| 5   | 1            | 2                | 1   | 3     |
| 6   | 2            | 1                | 1   | 3     |
| 7   | 3            | 1                | 1   | 3     |

**Answer: 3**

---

### Example 2:

```
nums = [1,2,3,4,4,4,4,5,6,7]
```

#### Step 1:

```
incLenEnd:   1 2 3 4 1 1 1 2 3 4
```

#### Step 2:

```
incLenStart: 4 3 2 1 1 1 3 2 1 1
```

#### Step 3:

| i   | incLenEnd[i] | incLenStart[i+1] | min | maxK  |
| --- | ------------ | ---------------- | --- | ----- |
| 0   | 1            | 3                | 1   | 1     |
| 1   | 2            | 2                | 2   | **2** |
| 2   | 3            | 1                | 1   | 2     |
| 3   | 4            | 1                | 1   | 2     |
| ... | ...          | ...              | ... | ...   |

**Answer: 2**

**Final Answers**

* Example 1 → `3`
* Example 2 → `2`

---

