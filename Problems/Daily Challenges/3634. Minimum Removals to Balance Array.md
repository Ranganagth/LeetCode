[3634. Minimum Removals to Balance Array](https://leetcode.com/problems/minimum-removals-to-balance-array/)

# Intuition

After removals, the remaining array must satisfy

```
max ≤ k * min
```

Instead of thinking about which elements to remove, think about **which elements to keep**.

If the array is sorted, any valid remaining set must form a **contiguous window** `[i … j]` such that:

```
nums[j] ≤ k * nums[i]
```

To minimize removals, we must **maximize the number of elements kept** in such a window.

Thus the problem becomes:

> Find the longest subarray in the sorted array satisfying
> `nums[right] ≤ k * nums[left]`.

The answer:

```
removals = n − (maximum valid window size)
```

---

# Approach (Sorting + Sliding Window)

1. Sort `nums`.
2. Use two pointers `left` and `right`.
3. Expand `right` while the condition holds.
4. If violated, move `left` forward.
5. Track the maximum window length.

This gives the largest balanced subset.

---

# Complexity

* Sorting: `O(n log n)`
* Sliding window: `O(n)`
* Total: `O(n log n)`
* Space: `O(1)` extra (ignoring sorting)

---

# Code

```ts
function minRemoval(nums: number[], k: number): number {
    nums.sort((a, b) => a - b);

    const n = nums.length;
    let left = 0;
    let maxLen = 0;

    for (let right = 0; right < n; right++) {
        while (nums[right] > nums[left] * k) {
            left++;
        }
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return n - maxLen;
};

```

---

# Example Walkthrough

### Example 1

```
nums = [2,1,5], k = 2
```

Sort:

```
[1,2,5]
```

Sliding window:

| left | right | window  | valid?                | size |
| ---- | ----- | ------- | --------------------- | ---- |
| 0    | 0     | [1]     | yes                   | 1    |
| 0    | 1     | [1,2]   | 2 ≤ 1×2 ✓             | 2    |
| 0    | 2     | [1,2,5] | 5 ≤ 1×2 ✗ → move left |      |
| 1    | 2     | [2,5]   | 5 ≤ 2×2 ✗ → move left |      |
| 2    | 2     | [5]     | ✓                     | 1    |

Max window size = 2
Removals = 3 − 2 = **1**

### Example 2

```
nums = [1,6,2,9], k = 3
```

Sorted:

```
[1,2,6,9]
```

Best window:

```
[2,6]   (6 ≤ 2×3)
size = 2
```

Removals:

```
4 − 2 = 2
```

---

## Key Insight

The optimal remaining array must be a **sorted contiguous segment** satisfying the ratio condition.
Thus the task reduces to **finding the longest multiplicative-bounded sliding window**.
