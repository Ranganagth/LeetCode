[3147. Taking Maximum Energy From the Mystic Dungeon](https://leetcode.com/problems/taking-maximum-energy-from-the-mystic-dungeon/)

# Intuition

We are given:

* An array `energy[i]` (positive or negative).
* A jump value `k`.

Starting from some magician `i`, we will collect:

```
energy[i] + energy[i + k] + energy[i + 2k] + ... until (i + xk) >= n
```

We must choose the **best starting point** `i` (0 ≤ i < n) to **maximize total energy** collected.

This is very similar to **jump-based dynamic programming** or a **path accumulation problem**.

---

## Key Idea

We want:

```
dp[i] = maximum energy we can gain starting from magician i
```

When we start from magician `i`, we must:

* Absorb `energy[i]`
* Then jump to `i + k` (if it exists)

So:

```
dp[i] = energy[i] + (dp[i + k] if i + k < n else 0)
```

We just compute `dp[i]` backwards (from right to left), and take the **maximum** among all `dp[i]`.

---

# Approach

1. Initialize `dp` array of length `n`.
2. Iterate `i` from `n - 1` down to `0`:

   * If `i + k >= n`, `dp[i] = energy[i]`
   * Else `dp[i] = energy[i] + dp[i + k]`
3. Return `max(dp[i])` for all `i`.

---

# Time & Space Complexity

* **Time:** O(n) (single backward pass)
* **Space:** O(n) (can be reduced to O(1) if computed in-place)

---

# Code

```typescript
function maximumEnergy(energy: number[], k: number): number {
    const n = energy.length;
    const dp = new Array(n).fill(0);

    for (let i = n - 1; i >= 0; i--) {
        dp[i] = energy[i];
        if (i + k < n) dp[i] += dp[i + k];
    }

    return Math.max(...dp);
};

```

---

## Example Walkthrough

### Example 1:

```
energy = [5, 2, -10, -5, 1], k = 3
```

Let’s compute `dp` backwards:

| i   | energy[i] | i+k     | dp[i+k] | dp[i] = energy[i] + dp[i+k] |
| --- | --------- | ------- | ------- | --------------------------- |
| 4   | 1         | 7 (out) | -       | 1                           |
| 3   | -5        | 6 (out) | -       | -5                          |
| 2   | -10       | 5 (out) | -       | -10                         |
| 1   | 2         | 4       | 1       | 3                           |
| 0   | 5         | 3       | -5      | 0                           |

Final `dp = [0, 3, -10, -5, 1]`

Maximum = **3**

Output: `3`

---

### Example 2:

```
energy = [-2, -3, -1], k = 2
```

| i | energy[i] | i+k     | dp[i+k] | dp[i] |
| - | --------- | ------- | ------- | ----- |
| 2 | -1        | 4 (out) | -       | -1    |
| 1 | -3        | 3 (out) | -       | -3    |
| 0 | -2        | 2       | -1      | -3    |

`dp = [-3, -3, -1]`
Maximum = **-1**

Output: `-1`

---

## **Summary**

| Step           | Idea                  | Detail                                         |
| -------------- | --------------------- | ---------------------------------------------- |
| **1**          | Define `dp[i]`        | Max energy starting from i                     |
| **2**          | Recurrence            | `dp[i] = energy[i] + dp[i + k] (if in bounds)` |
| **3**          | Direction             | Compute from right to left                     |
| **4**          | Answer                | `max(dp)`                                      |
| **Complexity** | O(n) time, O(n) space |                                                |

---
