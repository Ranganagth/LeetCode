[3453. Separate Squares I](https://leetcode.com/problems/separate-squares-i/)

# Intuition

The x-coordinates are irrelevant. A horizontal cut only depends on how much vertical area of each square lies below a given y.

For a square with bottom `y` and side `l`:

* Below the line at height `h`:

  * `0` if `h ≤ y`
  * `l²` if `h ≥ y + l`
  * `l * (h − y)` if `y < h < y + l`

Each square contributes a **piecewise-linear** area function in `h`.
The total area below the line is a monotonic, continuous function of `h`.

Goal:

```
area_below(h) = total_area / 2
```

This is a root-finding problem on a monotonic function.

---

# Approach

1. Compute `totalArea = Σ (l²)`
2. Binary search on `h` (the y-coordinate of the horizontal line)
3. For a candidate `h`, compute:

   ```
   area_below(h) = Σ contribution of each square
   ```
4. If `area_below(h) < totalArea / 2`, move the line up
   Else move it down
5. Continue until precision ≤ 1e-5
6. Return the smallest valid `h`

Binary search works because:

* Function is monotonic increasing
* Answer is guaranteed to exist

---

# Complexity

* **Time:** `O(n log R)`
  * `n = number of squares`
  * `R = coordinate range (up to 1e9)`

* **Space:** `O(1)` extra

---

# Code

```typescript
function separateSquares(squares: number[][]): number {
    let totalArea = 0;
    let minY = Infinity;
    let maxY = -Infinity;

    for (const [, y, l] of squares) {
        totalArea += l * l;
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y + l);
    }

    const target = totalArea / 2;
    let left = minY;
    let right = maxY;

    const areaBelow = (h: number): number => {
        let area = 0;
        for (const [, y, l] of squares) {
            if (h <= y) continue;
            if (h >= y + l) {
                area += l * l;
            } else {
                area += l * (h - y);
            }
        }
        return area;
    };

    for (let i = 0; i < 80; i++) {
        const mid = (left + right) / 2;
        if (areaBelow(mid) < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    return left;
};

```

---

# Example Walkthrough

### Example 1

`squares = [[0,0,1],[2,2,1]]`

Total area = `2`

* For `h = 1`:

  * Square 1 contributes `1`
  * Square 2 contributes `0`
  * Area below = `1`
* Area above = `1`

Balanced. Minimum valid `h = 1.00000`


### Example 2

`squares = [[0,0,2],[1,1,1]]`

Total area = `5` → target = `2.5`

At `h = 7/6 ≈ 1.16667`:

* Square 1: `2 * (7/6) = 14/6`
* Square 2: `(7/6 − 1) * 1 = 1/6`
* Area below = `15/6 = 2.5`
* Area above = `2.5`

Balanced at `h = 1.16667`

---

## Core Insight

This is not geometry.
This is monotonic area accumulation + binary search.
