[3408. Design Task Manager](https://leetcode.com/problems/design-task-manager/)

## Problem Restatement

We need to design a **Task Management System** that supports:

* Initializing tasks.
* Adding a new task for a user.
* Editing an existing task’s priority.
* Removing an existing task.
* Executing the top-priority task across all users.

  * Tie-breaking rule: highest `taskId` wins if multiple tasks have the same highest priority.
  * After execution, the task is removed.

Constraints are large (`10^5` tasks, `2*10^5` operations), so we need efficient operations.

---

# Intuition

The key challenge is **efficiently finding and updating the highest priority task**.

* If we used only a **Map**:

  * We could update and remove tasks in O(1).
  * But finding the top task would require scanning all tasks → O(N). Too slow.

* If we used only a **Heap (Priority Queue)**:

  * We can get the top task in O(1).
  * But editing/removing a task inside the heap requires searching → O(N). Too slow.

**Solution**: Use a **hybrid approach** with:

1. A **priority queue (max-heap)** for retrieving top tasks efficiently.
2. A **map** (`taskId → task details`) for tracking latest valid tasks.

Whenever a task is edited/removed:

* We **add a fresh entry into the heap** (lazy update).
* We **invalidate the old version** in the map.
* During `execTop`, we repeatedly discard outdated heap entries until the top matches the valid one in the map.

This technique is called **lazy deletion** in heaps.

---

# Approach

### Data Structures:

* **`q`** = priority queue of tasks `[userId, taskId, priority]`, sorted by:

  * Higher priority first (`b[2] - a[2]`)
  * If same priority, higher taskId first (`b[1] - a[1]`)
* **`m`** = map from taskId → latest task `[userId, taskId, priority]`.

### Methods:

#### `constructor(tasks)`

* Load initial tasks into both `q` and `m`.

#### `add(userId, taskId, priority)`

* Create task `[userId, taskId, priority]`.
* Push into both `q` and `m`.

#### `edit(taskId, newPriority)`

* Get old task from `m`.
* If the priority differs, create a new updated task.
* Update `m`, push new task into `q`.
* Old heap entries remain, but they’re invalid (lazy deletion will clean them).

#### `rmv(taskId)`

* Simply delete task from `m`.
* Old heap entries remain in `q` but will be ignored later.

#### `execTop()`

* While `q` is not empty:

  * Look at top of heap (`q.front()`).
  * Compare with the map (`m.get(taskId)`).
  * If they match, it’s valid → remove from both structures and return `userId`.
  * Else discard heap entry (outdated/removed task).
* If heap becomes empty, return `-1`.

---

# Complexity Analysis

* **Add**: O(log N) (heap insert)
* **Edit**: O(log N) (heap insert + map update)
* **Remove**: O(1) (map delete, heap cleanup deferred)
* **ExecTop**:

  * Each task can be discarded at most once.
  * Across all operations, heap cleanup amortizes to O(log N).

So **all operations are O(log N)** amortized, which is efficient for `2*10^5` calls.

Space complexity: **O(N)** (heap + map storage).

---
# Code

```ts
class TaskManager {
    q = new PriorityQueue<number[]>((a, b) => b[2] - a[2] || b[1] - a[1]);
    m = new Map<number, number[]>();

    constructor(tasks: number[][]) {
        for (const task of tasks) {
            this.q.enqueue(task);
            this.m.set(task[1], task);
        }
    }

    add(userId: number, taskId: number, priority: number): void {
        const task = [userId, taskId, priority];
        this.q.enqueue(task);
        this.m.set(taskId, task);
    }

    edit(taskId: number, newPriority: number): void {
        let task = this.m.get(taskId)!;
        if (task[2] !== newPriority) {
            task = [task[0], task[1], newPriority];
            this.m.set(taskId, task);
            this.q.enqueue(task);
        }
    }

    rmv(taskId: number): void {
        this.m.delete(taskId);
    }

    execTop(): number {
        while (this.q.size() > 0) {
            const qTask = this.q.front();
            const mTask = this.m.get(qTask[1]);
            if (qTask === mTask) {
                this.m.delete(qTask[1]);
                this.q.dequeue();
                return qTask[0];
            }
            this.q.dequeue();
        }
        return -1;
    }
};

```

---

## Example Walkthrough

Input:

```ts
["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]
[[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]
```

### Step by Step:

1. **Initialize**

   ```
   tasks: 
   [1, 101, 10], [2, 102, 20], [3, 103, 15]
   heap = [(2,102,20), (3,103,15), (1,101,10)]
   map = {101→(1,101,10), 102→(2,102,20), 103→(3,103,15)}
   ```

2. **add(4,104,5)**

   ```
   heap += (4,104,5)
   map[104] = (4,104,5)
   ```

3. **edit(102,8)**

   ```
   old task = (2,102,20)
   new task = (2,102,8)
   map[102] = (2,102,8)
   heap += (2,102,8)
   (old version in heap will be ignored later)
   ```

4. **execTop()**

   * Heap top = (2,102,20), but map\[102]=(2,102,8) → outdated → discard.
   * Next top = (3,103,15), matches map → execute.
   * Remove 103 from map.
     **Output = 3**

5. **rmv(101)**

   ```
   map.delete(101)
   ```

6. **add(5,105,15)**

   ```
   heap += (5,105,15)
   map[105] = (5,105,15)
   ```

7. **execTop()**

   * Heap top = (5,105,15), matches map.
   * Remove from map.
     **Output = 5**

Final outputs:

```
[null, null, null, 3, null, null, 5]
```

---
