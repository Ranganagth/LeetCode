[3408. Design Task Manager](https://leetcode.com/problems/design-task-manager/)

# Intuition

We need a system that:

* Can **add** tasks for users with a priority.
* Can **edit** an existing task’s priority.
* Can **remove** a task.
* Can **execute the top task**: the one with the **highest priority**, and if multiple, the one with the **largest taskId**.

This is essentially a **priority scheduling problem**.
We need to quickly retrieve the **maximum element** while also supporting **updates** and **deletions**.

Key observations:

* If we always need the **highest-priority task**, a **max-heap** (priority queue) is ideal.
* Problem: **edit** and **remove** make things tricky, because standard heaps don’t support efficient arbitrary updates/removals.
* Solution: use a **lazy deletion strategy**:

  * Keep a **map** of valid tasks (`taskId → {userId, priority}`).
  * Push new entries into the heap when editing.
  * For removals, just delete from the map.
  * When popping from the heap, skip entries that are outdated or removed.

---

# Approach

### Data Structures

1. **Heap** (max priority queue):
   Stores `[priority, taskId, userId]`.
   Comparison: higher priority first; if equal, larger taskId first.

2. **Hash Map**:
   Maps `taskId → {userId, priority}` to store the *current valid state* of a task.

### Operations

* **add(userId, taskId, priority)**

  * Insert into map.
  * Push into heap.

* **edit(taskId, newPriority)**

  * Update map.
  * Push new entry into heap (old entries will be ignored later).

* **rmv(taskId)**

  * Remove from map.

* **execTop()**

  * Pop from heap until we find a valid entry (exists in map with matching priority).
  * Remove it from map and return its `userId`.
  * If heap empties, return `-1`.

---

# Complexity

* **add**: `O(log n)` (heap push)
* **edit**: `O(log n)` (heap push)
* **rmv**: `O(1)` (map delete)
* **execTop**: amortized `O(log n)` (heap pops, but each entry is popped once overall)
* **Space**: `O(n)` (heap + map)

---

# Code

```ts
type Task = {
    userId: number;
    taskId: number;
    priority: number;
};

class MaxHeap<T> {
    private data: T[] = [];
    private cmp: (a: T, b: T) => number;

    constructor(cmp: (a: T, b: T) => number) {
        this.cmp = cmp;
    }

    size(): number {
        return this.data.length;
    }

    push(val: T): void {
        this.data.push(val);
        this.bubbleUp(this.data.length - 1);
    }

    pop(): T | undefined {
        if (this.data.length === 0) return undefined;
        const top = this.data[0];
        const end = this.data.pop()!;
        if (this.data.length > 0) {
            this.data[0] = end;
            this.bubbleDown(0);
        }
        return top;
    }

    private bubbleUp(idx: number) {
        const element = this.data[idx];
        while (idx > 0) {
            const parentIdx = Math.floor((idx - 1) / 2);
            const parent = this.data[parentIdx];
            if (this.cmp(element, parent) <= 0) break;
            this.data[parentIdx] = element;
            this.data[idx] = parent;
            idx = parentIdx;
        }
    }

    private bubbleDown(idx: number) {
        const length = this.data.length;
        const element = this.data[idx];
        while (true) {
            let left = idx * 2 + 1;
            let right = idx * 2 + 2;
            let swap = idx;

            if (left < length && this.cmp(this.data[left], this.data[swap]) > 0) {
                swap = left;
            }
            if (right < length && this.cmp(this.data[right], this.data[swap]) > 0) {
                swap = right;
            }
            if (swap === idx) break;
            [this.data[idx], this.data[swap]] = [this.data[swap], this.data[idx]];
            idx = swap;
        }
    }
}

class TaskManager {
    private heap: MaxHeap<[number, number, number]>; // [priority, taskId, userId]
    private taskMap: Map<number, { userId: number; priority: number }>;

    constructor(tasks: number[][]) {
        this.taskMap = new Map();
        this.heap = new MaxHeap<[number, number, number]>((a, b) => {
            if (a[0] !== b[0]) return a[0] - b[0];   // higher priority first
            return a[1] - b[1];                      // if tie, higher taskId first
        });

        for (const [userId, taskId, priority] of tasks) {
            this.add(userId, taskId, priority);
        }
    }

    add(userId: number, taskId: number, priority: number): void {
        this.taskMap.set(taskId, { userId, priority });
        this.heap.push([priority, taskId, userId]);
    }

    edit(taskId: number, newPriority: number): void {
        const task = this.taskMap.get(taskId);
        if (!task) return;
        task.priority = newPriority;
        this.heap.push([newPriority, taskId, task.userId]);
    }

    rmv(taskId: number): void {
        this.taskMap.delete(taskId);
    }

    execTop(): number {
        while (this.heap.size() > 0) {
            const [priority, taskId, userId] = this.heap.pop()!;
            const task = this.taskMap.get(taskId);
            if (task && task.priority === priority) {
                this.taskMap.delete(taskId);
                return userId;
            }
        }
        return -1;
    }
};

```

---

## Example Walkthrough

Input:

```ts
["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]
[[[[1,101,10],[2,102,20],[3,103,15]]], [4,104,5], [102,8], [], [101], [5,105,15], []]
```

Execution:

1. `TaskManager([[1,101,10],[2,102,20],[3,103,15]])`

   * Heap: `[20,102,2], [15,103,3], [10,101,1]`
   * Map: `{101→(1,10), 102→(2,20), 103→(3,15)}`

2. `add(4,104,5)`

   * Heap adds `[5,104,4]`
   * Map adds `{104→(4,5)}`

3. `edit(102,8)`

   * Map updates `102→(2,8)`
   * Heap adds `[8,102,2]`

4. `execTop()`

   * Heap pops `[20,102,2]`, but map has priority=8 → outdated → discard.
   * Heap pops `[15,103,3]`, valid → remove from map → return **3**.

5. `rmv(101)`

   * Map deletes `101`.

6. `add(5,105,15)`

   * Heap adds `[15,105,5]`
   * Map adds `{105→(5,15)}`

7. `execTop()`

   * Heap pops `[15,105,5]`, valid → remove from map → return **5**.

Output:

```
[null, null, null, 3, null, null, 5]
```

---
