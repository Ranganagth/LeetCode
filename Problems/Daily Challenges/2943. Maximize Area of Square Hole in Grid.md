[2943. Maximize Area of Square Hole in Grid](https://leetcode.com/problems/maximize-area-of-square-hole-in-grid/)

# Intuition

The grid is formed by **bars**, not cells.

* There are `n + 2` horizontal bars → `n + 1` horizontal gaps (unit height each initially).
* There are `m + 2` vertical bars → `m + 1` vertical gaps.

Removing a bar **merges two adjacent gaps**.
Removing consecutive bars merges multiple gaps into a larger continuous gap.

A **square hole** of side `k` requires:

* a vertical gap of height `k`
* a horizontal gap of width `k`

So the problem reduces to:

> Find the **maximum continuous gap** achievable horizontally and vertically after removing allowed bars, then take
> **(min(maxHeight, maxWidth))²**

## Key Observation

* Bars are indexed.
* If you remove bars at indices `[x, x+1, x+2]`, you merge **4 unit gaps**.
* The largest gap equals
  `longest consecutive sequence of removable bars + 1`.

This is identical to finding the **longest consecutive subsequence** in `hBars` and `vBars`.

---

# Approach

1. **Sort** `hBars` and `vBars`.
2. Compute the **longest consecutive run** in each.
3. Convert runs into gap sizes:

   ```
   gap = longestRun + 1
   ```
4. The largest square side:

   ```
   side = min(maxHorizontalGap, maxVerticalGap)
   ```
5. Return:

   ```
   side * side
   ```

---

# Complexity

* Sorting at most 100 elements.
* Time: **O(k log k)** where `k ≤ 100`
* Space: **O(1)**

Works easily within constraints (`n, m` up to `10^9`).

---

# Code

```ts
function maximizeSquareHoleArea(
    n: number,
    m: number,
    hBars: number[],
    vBars: number[],
): number {
    const longestConsecutive = (arr: number[]): number => {
        arr.sort((a, b) => a - b);
        let maxRun = 1;
        let curr = 1;

        for (let i = 1; i < arr.length; i++) {
            if (arr[i] === arr[i - 1] + 1) {
                curr++;
                maxRun = Math.max(maxRun, curr);
            } else {
                curr = 1;
            }
        }
        return maxRun + 1;
    };

    const maxHeight = longestConsecutive(hBars);
    const maxWidth = longestConsecutive(vBars);

    const side = Math.min(maxHeight, maxWidth);
    return side * side;
};

```

---

# Example Walkthrough

### Example 1

```
n = 2, m = 1
hBars = [2,3]
vBars = [2]
```

Horizontal:

* Bars `[2,3]` → consecutive length = 2
* Gap height = `2 + 1 = 3`

Vertical:

* Bars `[2]` → consecutive length = 1
* Gap width = `1 + 1 = 2`

Square side:

```
min(3, 2) = 2
```

Area:

```
2² = 4
```

### Example 2

```
hBars = [2]
vBars = [2]
```

Both directions:

```
gap = 1 + 1 = 2
area = 4
```

### Example 3

```
hBars = [2,3] → gap = 3
vBars = [2,4] → longest run = 1 → gap = 2
```

Square:

```
min(3,2)² = 4
```

---

## Final Insight

* Removing **consecutive bars** is the only way to enlarge gaps.
* The problem is purely **interval merging**, not geometry.
* Once reduced to longest consecutive sequence, the solution is immediate and optimal.
