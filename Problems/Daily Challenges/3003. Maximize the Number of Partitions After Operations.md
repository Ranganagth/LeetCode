[3003. Maximize the Number of Partitions After Operations](https://leetcode.com/problems/maximize-the-number-of-partitions-after-operations/)

# Intuition

You are allowed to change **at most one character** in `s`, and you want to **maximize the number of partitions** you can make when repeatedly removing the *longest prefix that contains at most `k` distinct characters*.

The challenge:  
Changing one character can drastically alter how distinct characters are distributed — hence affecting how many times the “distinct character limit” is reached, i.e., how many partitions occur.

## Step-by-Step Intuition

1. **Without any change**  
   You can greedily scan from left to right:
   - Maintain a bitmask (26 bits for each letter `a-z`) to track which letters are present in the current prefix.
   - Once the number of distinct characters exceeds `k`, start a new partition.

2. **With one change allowed**  
   You can imagine changing one character splits the string into:
   - **Left part** (before the change)
   - **Changed character**
   - **Right part** (after the change)

   The question becomes:
   - How many partitions can we get on the left?
   - How many partitions can we get on the right?
   - And how does the changed character affect merging or splitting partitions?

   To efficiently compute this, we precompute partition info **from both directions**:
   - `left[i]` → how many partitions if we consider prefix ending at `i`
   - `right[i]` → how many partitions if we consider suffix starting at `i`

---

# Approach

We do **two passes** to precompute partition details:

### 1. **Left-to-right pass**
   - Maintain:
     - `mask`: bitmask of distinct characters in the current segment
     - `count`: number of distinct characters
     - `num`: how many partitions formed so far
   - Each time distinct characters exceed `k`, start a new partition (`num++`), reset mask & count.

   Store these three at every position:
   - `left[i] = [num, mask, count]`

### 2. **Right-to-left pass**
   Similar logic, but reversed — build partitions moving backward.
   - `right[i] = [num, mask, count]`

### 3. **Combine and simulate the "change"**

For each possible index `i` (where you could potentially change the character):
- Compute potential partitions combining:
  - Left of `i`
  - Right of `i`
- Combine their bitmasks → `totMask = left[i][1] | right[i][1]`
- Count distinct characters in `totMask`
- Depending on whether changing a character helps you “bridge” two partitions or “split” more segments, adjust the count.

---

# Complexity

- **Time complexity:** `O(n * 26)`  
  - Each pass (left and right) runs in `O(n)`
  - Combining masks and counting bits per index is `O(26)` worst case
- **Space complexity:** `O(n)`  
  - Storing `left` and `right` arrays

---

# Code

```typescript
function maxPartitionsAfterOperations(s: string, k: number): number {
    const n: number = s.length;
    const left: number[][] = Array(n)
        .fill(0)
        .map(() => Array(3).fill(0));
    const right: number[][] = Array(n)
        .fill(0)
        .map(() => Array(3).fill(0));

    let num = 0, mask = 0, count = 0;

    // Left to right pass
    for (let i = 0; i < n - 1; i++) {
        const bit = 1 << (s.charCodeAt(i) - 97);
        if (!(mask & bit)) {
            count++;
            if (count <= k) {
                mask |= bit;
            } else {
                num++;
                mask = bit;
                count = 1;
            }
        }
        left[i + 1][0] = num;
        left[i + 1][1] = mask;
        left[i + 1][2] = count;
    }

    // Right to left pass
    num = 0; mask = 0; count = 0;
    for (let i = n - 1; i > 0; i--) {
        const bit = 1 << (s.charCodeAt(i) - 97);
        if (!(mask & bit)) {
            count++;
            if (count <= k) {
                mask |= bit;
            } else {
                num++;
                mask = bit;
                count = 1;
            }
        }
        right[i - 1][0] = num;
        right[i - 1][1] = mask;
        right[i - 1][2] = count;
    }

    let maxPartitions = 0;
    for (let i = 0; i < n; i++) {
        let partitions = left[i][0] + right[i][0] + 2;
        let combinedMask = left[i][1] | right[i][1];
        let distinct = 0;
        while (combinedMask) {
            combinedMask &= (combinedMask - 1);
            distinct++;
        }

        if (left[i][2] === k && right[i][2] === k && distinct < 26) {
            partitions++;
        } else if (Math.min(distinct + 1, 26) <= k) {
            partitions--;
        }
        maxPartitions = Math.max(maxPartitions, partitions);
    }

    return maxPartitions;
}
```

---

## Example Walkthrough

### Example:
`s = "accca"`, `k = 2`

**Step 1:** Try without any change  
- Longest prefix with ≤2 distinct chars: `"acc"`  
  → partitions = 2 (`"acc"`, `"ca"`)

**Step 2:** Try changing one character optimally  
Change `s[2]` (the 3rd char `'c'`) → `'b'`  
`s = "acbca"`

Now perform partitioning:
1. `"ac"` (2 distinct: `a, c`) → partition 1  
   Remaining: `"bca"`
2. `"bc"` (2 distinct: `b, c`) → partition 2  
   Remaining: `"a"`
3. `"a"` → partition 3

**Total partitions = 3**

## **Output**
```
Input: s = "accca", k = 2
Output: 3
```

---

## Summary

| Step | Action | Reason |
|------|--------|--------|
| Precompute left/right | Efficiently track partitions for each prefix/suffix | Avoid redoing work |
| Use bitmasks | Efficiently count distinct characters | Fast comparison |
| Try each possible index for change | Explore optimal change | Ensure max partitions |
| Combine left + right info | Merge effect of change | Evaluate globally |
