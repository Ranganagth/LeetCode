[1895. Largest Magic Square](https://leetcode.com/problems/largest-magic-square/)

# Intuition

A **magic square** requires:

* All row sums equal
* All column sums equal
* Both diagonal sums equal

Since values **do not need to be distinct**, the only constraint is **sum equality**.

Brute force checking every k×k square and recomputing sums would be too slow if done naively.
The key optimization is to **precompute prefix sums** so any row, column, or diagonal sum can be queried in O(1).

Given small constraints (`m, n ≤ 50`), we can:

* Try square sizes from **largest to smallest**
* Stop immediately once a valid magic square is found

---

# Approach

### Step 1: Prefix Sums

Precompute:

1. **Row prefix sums**
2. **Column prefix sums**
3. **Main diagonal prefix sums**
4. **Anti-diagonal prefix sums**

This allows:

* Row sum in O(1)
* Column sum in O(1)
* Diagonal sums in O(1)

### Step 2: Try All Square Sizes

For `k` from `min(m, n)` down to `2`:

* For every possible top-left `(r, c)`
* Check if the k×k subgrid is magic

Stop at the first valid `k`.

### Step 3: Magic Square Validation

For a square starting at `(r, c)`:

1. Compute target sum = sum of first row
2. Verify:

   * All rows equal target
   * All columns equal target
   * Main diagonal = target
   * Anti-diagonal = target

---

# Complexity

* **Time:** `O(min(m,n)³)`
  * Worst case: `50³ = 125,000` checks

* **Space:** `O(mn)` for prefix sums
* Efficient and well within limits

---

# Code

```ts
function largestMagicSquare(grid: number[][]): number {
    const m = grid.length;
    const n = grid[0].length;

    // Row prefix sums
    const rowSum = Array.from({ length: m }, () => Array(n + 1).fill(0));
    // Column prefix sums
    const colSum = Array.from({ length: m + 1 }, () => Array(n).fill(0));
    // Main diagonal prefix
    const diag1 = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    // Anti-diagonal prefix
    const diag2 = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            rowSum[i][j + 1] = rowSum[i][j] + grid[i][j];
            colSum[i + 1][j] = colSum[i][j] + grid[i][j];
            diag1[i + 1][j + 1] = diag1[i][j] + grid[i][j];
            diag2[i + 1][j] = diag2[i][j + 1] + grid[i][j];
        }
    }

    const maxK = Math.min(m, n);

    for (let k = maxK; k >= 2; k--) {
        for (let r = 0; r + k <= m; r++) {
            for (let c = 0; c + k <= n; c++) {

                const target = rowSum[r][c + k] - rowSum[r][c];
                let valid = true;

                // Check rows
                for (let i = 0; i < k && valid; i++) {
                    if (rowSum[r + i][c + k] - rowSum[r + i][c] !== target) {
                        valid = false;
                    }
                }

                // Check columns
                for (let j = 0; j < k && valid; j++) {
                    if (colSum[r + k][c + j] - colSum[r][c + j] !== target) {
                        valid = false;
                    }
                }

                // Check diagonals
                const d1 = diag1[r + k][c + k] - diag1[r][c];
                const d2 = diag2[r + k][c] - diag2[r][c + k];

                if (valid && d1 === target && d2 === target) {
                    return k;
                }
            }
        }
    }

    return 1;
};

```

---

# Example Walkthrough

### Example 1

```
grid =
[
 [7,1,4,5,6],
 [2,5,1,6,4],
 [1,5,4,3,2],
 [1,2,7,3,4]
]
```

Checking `k = 3` at `(1,1)`:

```
5 1 6
5 4 3
2 7 3
```

* Rows: `12, 12, 12`
* Columns: `12, 12, 12`
* Diagonals: `12, 12`

Valid → **answer = 3**

### Example 2

```
grid =
[
 [5,1,3,1],
 [9,3,3,1],
 [1,3,3,8]
]
```

No valid 3×3
Valid 2×2 exists → **answer = 2**

---

## Final Insight

* Prefix sums eliminate repeated computation
* Checking largest sizes first ensures early exit
* No need to enforce distinct numbers
* This is a controlled brute-force with constant-time checks
