[2353. Design a Food Rating System](https://leetcode.com/problems/design-a-food-rating-system/)

# Intuition

We need a system to:

1. Track each food → its cuisine and rating.
2. For each cuisine, quickly get the **highest-rated food**.

   * If multiple foods share the same rating, choose the **lexicographically smallest**.

The challenge:

* Ratings can change, so we must efficiently update.
* We need fast queries for the top food per cuisine.

---

# Approach

We can use these mappings:

1. **foodMap**:
   Maps food → `{ cuisine, rating }`

   * Allows quick lookup and update when ratings change.

2. **cuisineMap**:
   Maps cuisine → **max-heap (priority queue)** of foods.

   * Each heap stores tuples `[-rating, food]`.
   * Negative rating because JS doesn’t have max-heap, only min-heap priority queues.
   * Lexicographic tie-breaking works because when rating is equal, `"ramen" < "sushi"` gives correct order.

**Handling outdated entries in heap (lazy removal):**

* When rating changes, we **don’t remove old entry** (costly).
* Instead, we push the new tuple into the heap.
* When querying `highestRated`, we pop elements until the top matches the current rating in `foodMap`.

---

# Complexity

* `changeRating`: **O(log n)** (heap insert).
* `highestRated`: amortized **O(log n)** (pop outdated entries).
* Initialization: **O(n log n)** (heap inserts).

---

# Code

```typescript
class FoodRatings {
    private foodMap: Map<string, { cuisine: string; rating: number }>;
    private cuisineMap: Map<string, [number, string][]>; // heap for each cuisine

    constructor(foods: string[], cuisines: string[], ratings: number[]) {
        this.foodMap = new Map();
        this.cuisineMap = new Map();

        for (let i = 0; i < foods.length; i++) {
            const food = foods[i];
            const cuisine = cuisines[i];
            const rating = ratings[i];

            this.foodMap.set(food, { cuisine, rating });

            if (!this.cuisineMap.has(cuisine)) {
                this.cuisineMap.set(cuisine, []);
            }
            this.pushHeap(this.cuisineMap.get(cuisine)!, [-rating, food]);
        }
    }

    changeRating(food: string, newRating: number): void {
        const { cuisine } = this.foodMap.get(food)!;
        this.foodMap.set(food, { cuisine, rating: newRating });

        // Insert new record into heap
        this.pushHeap(this.cuisineMap.get(cuisine)!, [-newRating, food]);
    }

    highestRated(cuisine: string): string {
        const heap = this.cuisineMap.get(cuisine)!;

        while (heap.length > 0) {
            const top = heap[0];   // top element of heap
            const rating = -top[0];
            const food = top[1];

            const current = this.foodMap.get(food)!;

            if (current.rating === rating) {
                return food;
            }
            this.popHeap(heap); // outdated entry, remove
        }

        return "";
    }

    // ---------- Heap Helpers ----------
    private pushHeap(heap: [number, string][], val: [number, string]) {
        heap.push(val);
        this.bubbleUp(heap, heap.length - 1);
    }

    private popHeap(heap: [number, string][]) {
        const last = heap.pop();
        if (!last) return;
        if (heap.length === 0) return last;

        const ret = heap[0];
        heap[0] = last;
        this.bubbleDown(heap, 0);
        return ret;
    }

    private bubbleUp(heap: [number, string][], idx: number) {
        while (idx > 0) {
            const parent = Math.floor((idx - 1) / 2);
            if (this.compare(heap[idx], heap[parent]) < 0) {
                [heap[idx], heap[parent]] = [heap[parent], heap[idx]];
                idx = parent;
            } else break;
        }
    }

    private bubbleDown(heap: [number, string][], idx: number) {
        const n = heap.length;
        while (true) {
            let smallest = idx;
            const left = idx * 2 + 1;
            const right = idx * 2 + 2;

            if (left < n && this.compare(heap[left], heap[smallest]) < 0) {
                smallest = left;
            }
            if (right < n && this.compare(heap[right], heap[smallest]) < 0) {
                smallest = right;
            }
            if (smallest !== idx) {
                [heap[idx], heap[smallest]] = [heap[smallest], heap[idx]];
                idx = smallest;
            } else break;
        }
    }

    // Compare by rating first, then lexicographically
    private compare(a: [number, string], b: [number, string]): number {
        if (a[0] !== b[0]) return a[0] - b[0]; // higher rating = smaller -rating
        return a[1].localeCompare(b[1]);       // lexicographically smaller
    }
}

```

---

## Example Walkthrough

Input:

```ts
foods = ["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"]
cuisines = ["korean", "japanese", "japanese", "greek", "japanese", "korean"]
ratings = [9, 12, 8, 15, 14, 7]
```

Operations:

1. `highestRated("korean")` → `"kimchi"` (rating 9 > bulgogi’s 7).
2. `highestRated("japanese")` → `"ramen"` (14 > sushi’s 8 > miso’s 12).
3. `changeRating("sushi", 16)` → update sushi rating.
4. `highestRated("japanese")` → `"sushi"` (16 is max).
5. `changeRating("ramen", 16)` → ramen now ties.
6. `highestRated("japanese")` → `"ramen"` (16, tie but lexicographically smaller).

Output:
`[null, "kimchi", "ramen", null, "sushi", null, "ramen"]`

---
