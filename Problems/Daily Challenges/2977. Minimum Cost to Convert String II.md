[2977. Minimum Cost to Convert String II](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)

# Intuition

You are allowed to **replace substrings** of `source` with other substrings at some cost, under two strict rules:

1. Replacements must be **disjoint**, or
2. They must be applied to **exactly the same interval** (allowing chaining).

This means:

* You **cannot partially overlap** two different replacements.
* You **can chain multiple transformations on the same substring**.

So the problem becomes:

> At each index `i`, either:
>
> * leave the character unchanged (if `source[i] == target[i]`), or
> * apply **one full substring replacement** starting at `i`, and then jump forward.

This strongly suggests **dynamic programming over indices**.

---

## Key Observations

### 1. Substring transformations can be chained

If we can convert:

```
"c" → "e" → "b"
```

then the effective cost of `"c" → "b"` is the **shortest path** through transformations.

So first:

* Treat every `original[i] → changed[i]` as a **directed edge** with cost.
* Compute **all-pairs shortest paths** over these transformations.

This converts multiple-step replacements into **single optimal costs**.

### 2. DP over positions

Let:

```
dp[i] = minimum cost to convert source[i..n-1] → target[i..n-1]
```

Transition:

* If `source[i] == target[i]`, we may skip:

  ```
  dp[i] = dp[i+1]
  ```
* Otherwise, try every substring replacement starting at `i`:

  ```
  source[i..i+L-1] → target[i..i+L-1]
  dp[i] = min(dp[i], cost + dp[i+L])
  ```

Answer is `dp[0]`.

---

# Algorithm

### Step 1: Build transformation graph

* Nodes are **unique strings** from `original` and `changed`
* Use **Floyd–Warshall** to compute minimum cost between all pairs

### Step 2: Preprocess substring replacements

* For every transformation `orig → chg`
* Store its **minimum cost**

### Step 3: Dynamic Programming

* Traverse `source` from right to left
* At each index:

  * Match valid replacements
  * Update `dp[i]`

## Correctness

* DP ensures **no overlapping intervals**
* Chaining is handled via shortest-path preprocessing
* All valid operations are explored
* Minimum cost is guaranteed

---

# Complexity

Let:
* `n = source.length ≤ 1000`
* `k = number of transformations ≤ 100`

- **Time**
	* Floyd–Warshall: `O(k³)` (safe for k ≤ 100)
	* DP: `O(n × k × L)` where `L ≤ n`
	* Overall: **O(10⁶)** scale — efficient

- **Space**
	* Transformation graph + DP array
	* **O(n + k²)**

---

# Code

```ts
function minimumCost(
    source: string,
    target: string,
    original: string[],
    changed: string[],
    cost: number[]
): number {
    const n = source.length;
    const INF = Number.MAX_SAFE_INTEGER;

    // Collect unique strings
    const set = new Set<string>();
    for (let s of original) set.add(s);
    for (let s of changed) set.add(s);

    const arr = Array.from(set);
    const id = new Map<string, number>();
    arr.forEach((s, i) => id.set(s, i));

    const m = arr.length;
    const dist = Array.from({ length: m }, () => Array(m).fill(INF));

    for (let i = 0; i < m; i++) dist[i][i] = 0;

    // Initialize direct transformations
    for (let i = 0; i < original.length; i++) {
        const u = id.get(original[i])!;
        const v = id.get(changed[i])!;
        dist[u][v] = Math.min(dist[u][v], cost[i]);
    }

    // Floyd–Warshall
    for (let k = 0; k < m; k++) {
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < m; j++) {
                if (dist[i][k] !== INF && dist[k][j] !== INF) {
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }

    // DP
    const dp = Array(n + 1).fill(INF);
    dp[n] = 0;

    for (let i = n - 1; i >= 0; i--) {
        // No operation
        if (source[i] === target[i]) {
            dp[i] = dp[i + 1];
        }

        // Try all substring replacements
        for (let u = 0; u < m; u++) {
            const orig = arr[u];
            const len = orig.length;
            if (i + len > n) continue;

            if (source.substr(i, len) !== orig) continue;

            for (let v = 0; v < m; v++) {
                if (dist[u][v] === INF) continue;
                const chg = arr[v];
                if (chg.length !== len) continue;

                if (target.substr(i, len) === chg) {
                    dp[i] = Math.min(dp[i], dist[u][v] + dp[i + len]);
                }
            }
        }
    }

    return dp[0] === INF ? -1 : dp[0];
};

```

---

# Example Walkthrough

### Example 

```
source = "abcdefgh"
target = "acdeeghh"
```

Operations:

1. `"bcd" → "cde"` at cost 1
2. `"fgh" → "thh"` at cost 3
3. `"thh" → "ghh"` at cost 5

DP builds:

```
dp[0] = 1 + 8 = 9
```

Output:

```
9
```

---

## Final Insight

This is a **substring DP problem with graph optimization**.

Key ideas:

* **Shortest paths** for chained replacements
* **Index-based DP** to prevent overlaps
* Careful substring matching

Once you see the DP structure, the problem becomes clean and systematic.
