[190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)

# Intuition

A 32-bit integer contains bits indexed from `0..31`.
Reversing the bits means moving:

```
bit i  -> position (31 − i)
```

Repeatedly extract the least significant bit using:

```
n & 1
```

Shift the result left and insert this extracted bit until all 32 bits are processed.

---

# Approach

1. Initialize `result = 0`.
2. Repeat **32 times**:

   * Left shift result.
   * Append `(n & 1)` to result.
   * Right shift `n`.
3. Return result.

This guarantees correct handling of leading zeros.

---

# Complexity

* **Time:** `O(32) = O(1)`
* **Space:** `O(1)`

---

# Code

```ts
function reverseBits(n: number): number {
    let result = 0;

    for (let i = 0; i < 32; i++) {
        result = (result << 1) | (n & 1);
        n >>>= 1; // unsigned shift
    }

    return result >>> 0;
};

```

---

# Example Walkthrough

**Input**

```
n = 43261596
binary = 00000010100101000001111010011100
```

Process (illustrative):

* extract last bit `0`, append → result `0`
* extract `0`, append → result `00`
* extract `1`, append → result `001`
* continue …

After 32 steps:

```
00111001011110000010100101000000
```

Decimal:

```
964176192
```

---

## Follow-up Optimization

When the function is called many times:

1. Precompute reversed values for all **8-bit numbers (0–255)**.
2. Split the 32-bit integer into four bytes.
3. Reverse each byte using lookup and recombine:

```
rev =
    (lookup[b0] << 24) |
    (lookup[b1] << 16) |
    (lookup[b2] << 8)  |
    lookup[b3]
```

This reduces operations to constant table lookups and shifts.
