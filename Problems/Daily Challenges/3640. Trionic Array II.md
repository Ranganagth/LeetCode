[3640. Trionic Array II](https://leetcode.com/problems/trionic-array-ii/)

# Intuition

A **trionic subarray** must have **three consecutive monotonic segments**:

1. **Strictly increasing**
2. **Strictly decreasing**
3. **Strictly increasing**

All three segments must be **non-empty** and contiguous.

The challenge is:
* Values can be **negative**
* We must **maximize the sum**, not the length
* Brute force over all `(l, p, q, r)` is impossible for `n = 10^5`

Key idea:
> A valid trionic subarray is fully determined once we locate a **peak (p)** and a **valley (q)**.
> From there, we only need the **best prefix** and **best suffix** sums that preserve strict monotonicity.

---

# High-Level Approach

We scan the array and treat each index `i` as a **potential start** of a trionic subarray.

For each `i`, we:

### 1. Find the first increasing segment

Move `j` forward while `nums[j] > nums[j-1]`

* End index → `p`
* If no increase → skip

### 2. Find the decreasing segment

Continue moving `j` while `nums[j] < nums[j-1]`

* End index → `q`
* If no decrease or no room for a third segment → skip

### 3. Find the increasing segment again

From `q+1`, ensure at least one increase exists

### 4. Maximize the sum

Instead of fixing the full range:

* **Expand left** (within first increasing segment) to get the **maximum prefix sum**
* **Expand right** (within last increasing segment) to get the **maximum suffix sum**

This allows skipping negative contributions while preserving monotonicity.

## Why This Works

* Every valid trionic subarray has a unique `(p, q)`
* We only consider **valid monotonic transitions**
* Prefix/suffix maximization handles negative values optimally
* Skipping indices (`i = q - 1`) avoids redundant work

---

# Complexity

* **Time:** `O(n)`
  * Each index is processed a constant number of times

* **Space:** `O(1)`
  * Only scalar variables

---

# Code

```ts
function maxSumTrionic(nums: number[]): number {
    const n = nums.length;
    let ans = -Infinity;

    for (let i = 0; i < n; i++) {
        let j = i + 1;
        let res = 0;

        // 1) strictly increasing
        while (j < n && nums[j] > nums[j - 1]) j++;
        const p = j - 1;
        if (p === i) continue;

        // 2) strictly decreasing
        res += nums[p] + nums[p - 1];
        while (j < n && nums[j] < nums[j - 1]) {
            res += nums[j];
            j++;
        }
        const q = j - 1;

        if (q === p || q === n - 1 || (j < n && nums[j] <= nums[q])) {
            i = q;
            continue;
        }

        // 3) strictly increasing again
        res += nums[q + 1];

        // maximize suffix (third segment)
        let maxSum = 0, sum = 0;
        for (let k = q + 2; k < n && nums[k] > nums[k - 1]; k++) {
            sum += nums[k];
            maxSum = Math.max(maxSum, sum);
        }
        res += maxSum;

        // maximize prefix (first segment)
        maxSum = 0; sum = 0;
        for (let k = p - 2; k >= i; k--) {
            sum += nums[k];
            maxSum = Math.max(maxSum, sum);
        }
        res += maxSum;

        ans = Math.max(ans, res);
        i = q - 1;
    }

    return ans;
};

```

---

# Example Walkthrough

### Example 1

```
nums = [0, -2, -1, -3, 0, 2, -1]
```

Choose:

* `l = 1, p = 2, q = 3, r = 5`

Segments:

* Increasing: `[-2, -1]`
* Decreasing: `[-1, -3]`
* Increasing: `[-3, 0, 2]`

Sum:

```
-2 + (-1) + (-3) + 0 + 2 = -4
```

No other trionic subarray has a higher sum → **answer = -4**

### Example 2

```
nums = [1, 4, 2, 7]
```

Segments:

* `[1, 4] ↑`
* `[4, 2] ↓`
* `[2, 7] ↑`

Sum:

```
1 + 4 + 2 + 7 = 14
```

→ **answer = 14**

---

## Final Insight

This problem is solved by recognizing that:

> **Trionic subarrays are defined by shape, not length**

Once the shape is fixed, **prefix/suffix maximization** turns a hard problem into a linear scan.

This is the optimal and intended solution.
