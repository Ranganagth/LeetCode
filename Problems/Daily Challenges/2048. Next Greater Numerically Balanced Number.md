[2048. Next Greater Numerically Balanced Number](https://leetcode.com/problems/next-greater-numerically-balanced-number/)

## Understanding the Problem

A number `x` is **numerically balanced** if:

> For every digit `d` present in `x`, it appears exactly `d` times.

### Examples:
- `22` → digit `2` appears **2** times → Correct numerically balanced  
- `1333` → digit `1` appears once, `3` appears three times → Correct  
- `122` → digit `1` appears once, `2` appears twice → Correct
- `1223` → digit `2` appears twice, `3` once → (3 appears 1 time, not 3 times)

### Goal

Given an integer `n`, find the **smallest numerically balanced number strictly greater than n**.

---

# Intuition

- For each candidate number `x` (starting at `n+1`), count how many times each digit `0..9` occurs.
- A number is **numerically balanced** iff:
    - Digit `0` does **not** appear (if `count[0] > 0` it's invalid), and        
    - For every digit `d = 1..9` that appears (`count[d] > 0`), `count[d] == d`.
- Return the first `x` that satisfies the above.

---

## **Key Observations**

1. Digits range from `1` to `9` (since `0` can’t appear — it would require appearing 0 times).
2. The maximum possible length of such a number is **9 digits** (since digit 9 appearing 9 times gives the largest possible size).
3. Therefore, we can **generate all valid combinations** where:
   - For each digit `d`, it appears exactly `d` times.
   - Combine these digits in any order to form numbers.

Because total combinations are very limited, we can precompute efficiently.

---

# Approach

1. **Generate all possible numerically balanced numbers:**
   - For each subset of digits `{1, 2, ..., 7}`, create a multiset that has `d` copies of `d`.
   - Generate all permutations of that multiset (careful with duplicates).
   - Convert to integers.
   - Keep only unique numbers.

2. **Sort** the generated numbers.

3. **Binary search** or simply iterate to find the smallest number > `n`.

---

# Complexity Analysis

- Let `k` be the number of tested integers until we find the answer (in practice small for the given constraints).    
- Each check is `O(d)` where `d` is number of digits (≤ 7 for `n ≤ 10^6`), so total is `O(k * d)` — easily fine for the limit.

---

# Code

```typescript
function nextBeautifulNumber(n: number): number {
  const results: number[] = [];

  // Helper to generate numerically balanced numbers recursively
  function generate(current: number[], start: number) {
    const num = parseInt(current.join(''));
    if (current.length > 0) results.push(num);
    for (let d = start; d <= 7; d++) {
      const next = [...current];
      for (let i = 0; i < d; i++) next.push(d);
      if (next.length <= 9) generate(next, d + 1);
    }
  }

  generate([], 1);

  // Sort all generated numbers
  results.sort((a, b) => a - b);

  // Return smallest number strictly greater than n
  for (const val of results) {
    if (val > n) return val;
  }

  // For completeness
  return -1;
};

```

---

## Example Walkthrough

### Example 1
```
Input: n = 1
```

Generated numerically balanced numbers (sorted):
```
1, 22, 122, 333, 1333, 1444, 122333, ...
```

→ First number > 1 is **22**

Output: `22`

### Example 2
```
Input: n = 1000
```

Possible numerically balanced numbers near 1000:
```
122, 333, 1333, 1444, 15555, ...
```

→ First number > 1000 is **1333**

Output: `1333`

### Example 3
```
Input: n = 3000
```

Possible candidates:
```
1333, 1444, 15555, 3133, 322, ...
```

→ First > 3000 is **3133**

Output: `3133`

---
