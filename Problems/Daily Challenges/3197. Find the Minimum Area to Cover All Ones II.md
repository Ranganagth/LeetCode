[3197. Find the Minimum Area to Cover All Ones II](https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-ii/)

# Intuition

We need to cover **all `1`s in the grid** using **3 non-overlapping rectangles** with minimal total area.
* The rectangles must align with the grid axes and cover every `1`.
* Since we only need 3 rectangles, there are two possible ways to partition the grid:
  1. **Split horizontally** (rows).
  2. **Split vertically** (columns).

So the problem reduces to:
Find the best way to partition the grid into 3 rectangles and calculate the sum of areas.

The trick here is:
* **Check all possible splits** (both horizontal and vertical).
* For each partition, compute the bounding rectangle covering all `1`s in that region.
* Minimize the total area.

To cover vertical possibilities as well, the solution rotates the grid (transpose with rotation) and repeats the calculation.

---

# Approach 

1. **Helper: `minimumSum2`**
   * Given a subgrid defined by `(u, d, l, r)`, it finds the bounding rectangle covering all `1`s in that region.
   * Returns its area. If no `1`s exist, return `∞` (large number so it's never chosen).

2. **Helper: `rotate`**
   * Rotates the grid 90° so that vertical partitions can be handled as horizontal splits in the rotated version.

3. **Helper: `solve`**
   * Iterates over all possible ways of splitting the grid into 3 rectangles:
     * **Type A (L-shaped split):**
       One rectangle on top half, then two rectangles splitting the bottom half.
     * **Type B (reverse L-shaped split):**
       Two rectangles on top half, one rectangle on bottom half.
     * **Type C (straight horizontal split into 3):**
       Divide the grid into 3 strips horizontally.
   * For each split, compute the total area using `minimumSum2` and track the minimum.

4. **Main Function: `minimumSum`**
   * Calls `solve(grid)` for horizontal partitions.
   * Calls `solve(rotate(grid))` for vertical partitions.
   * Returns the minimum result.

---

# Complexity

* Grid size: `n × m` (with `n, m ≤ 30`).
* `minimumSum2` scans at most `O(n × m)`.
* `solve` tries:
  * ~`O(n × m)` partitions for L-shape cases.
  * ~`O(n²)` partitions for horizontal strips.
* So each `solve` ≈ `O(n² × m²)` in worst case, but with small constraints (`30×30`), this is feasible.
* **Overall:** `O(n² × m²)` (works fine for given constraints).
* **Space Complexity:** `O(n × m)` (grid storage).

---

# Code

```typescript
function minimumSum(grid: number[][]): number {
    const rgrid = rotate(grid);
    return Math.min(solve(grid), solve(rgrid));
}

function minimumSum2(
    grid: number[][],
    u: number,
    d: number,
    l: number,
    r: number,
): number {
    let min_i = grid.length, max_i = 0;
    let min_j = grid[0].length, max_j = 0;
    for (let i = u; i <= d; i++) {
        for (let j = l; j <= r; j++) {
            if (grid[i][j] === 1) {
                min_i = Math.min(min_i, i);
                min_j = Math.min(min_j, j);
                max_i = Math.max(max_i, i);
                max_j = Math.max(max_j, j);
            }
        }
    }
    return min_i <= max_i
        ? (max_i - min_i + 1) * (max_j - min_j + 1)
        : Number.MAX_SAFE_INTEGER / 3;
}

function rotate(vec: number[][]): number[][] {
    const n = vec.length, m = vec[0].length;
    const ret: number[][] = new Array(m).fill(0).map(() => new Array(n));
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            ret[m - j - 1][i] = vec[i][j];
        }
    }
    return ret;
}

function solve(grid: number[][]): number {
    const n = grid.length, m = grid[0].length;
    let res = n * m;
    for (let i = 0; i + 1 < n; i++) {
        for (let j = 0; j + 1 < m; j++) {
            res = Math.min(
                res,
                minimumSum2(grid, 0, i, 0, m - 1) +
                    minimumSum2(grid, i + 1, n - 1, 0, j) +
                    minimumSum2(grid, i + 1, n - 1, j + 1, m - 1),
            );
            res = Math.min(
                res,
                minimumSum2(grid, 0, i, 0, j) +
                    minimumSum2(grid, 0, i, j + 1, m - 1) +
                    minimumSum2(grid, i + 1, n - 1, 0, m - 1),
            );
        }
    }
    for (let i = 0; i + 2 < n; i++) {
        for (let j = i + 1; j + 1 < n; j++) {
            res = Math.min(
                res,
                minimumSum2(grid, 0, i, 0, m - 1) +
                    minimumSum2(grid, i + 1, j, 0, m - 1) +
                    minimumSum2(grid, j + 1, n - 1, 0, m - 1),
            );
        }
    }
    return res;
};

```

---

## Example Walkthrough

### Example 1:

```ts
grid = [
  [1,0,1],
  [1,1,1]
]
```

* Try splitting:

  * Left column rectangle covers `(0,0)` and `(1,0)` → area = 2.
  * Right column rectangle covers `(0,2)` and `(1,2)` → area = 2.
  * Middle single cell `(1,1)` → area = 1.
* Total = `2 + 2 + 1 = 5`.

Output: **5**

---

### Example 2:

```ts
grid = [
  [1,0,1,0],
  [0,1,0,1]
]
```

* One rectangle covers `(0,0)` and `(0,2)` → area = 3.
* Second rectangle covers `(1,1)` → area = 1.
* Third rectangle covers `(1,3)` → area = 1.
* Total = `3 + 1 + 1 = 5`.

Output: **5**

---

