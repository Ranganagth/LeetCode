[3318. Find X-Sum of All K-Long Subarrays I](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/)

# Intuition

We need to compute a special sum — the **x-sum** — for every sliding window of size `k`.

The **x-sum** is determined by:

1. Counting how often each number appears in the window.
2. Picking the **x most frequent** numbers.

   * If frequencies are tied → the **larger number** has priority.
3. Summing **only those elements** that belong to the top `x` numbers.

We repeat this for each window of length `k` in `nums`.

---

# Approach

1. **Sliding Window (size k):**
   We'll move a window of size `k` from left to right across the array.

2. **Frequency Counting:**
   For each window:

   * Count the occurrences of all elements (using a `Map<number, number>`).
   * Extract `[num, freq]` pairs.

3. **Sort by frequency and value:**

   * Sort descending by frequency.
   * If two numbers have equal frequency → sort descending by number value.

4. **Select Top x numbers:**

   * Choose top `x` numbers after sorting.

5. **Compute x-sum:**

   * Sum up all occurrences of those `x` numbers within the subarray.

6. **Repeat for all windows.**

Since `n <= 50`, a direct O(n * k log k) approach is efficient enough.

---

# Complexity

| Aspect | Complexity                                                  |
| ------ | ----------------------------------------------------------- |
| Time   | O(n * k log k) — For each window, we sort the frequency map |
| Space  | O(k) — For frequency map and sorting                        |

---

# Code

```typescript
function findXSum(nums: number[], k: number, x: number): number[] {
    const n = nums.length;
    const result: number[] = [];

    for (let i = 0; i <= n - k; i++) {
        const window = nums.slice(i, i + k);
        const freqMap = new Map<number, number>();

        // Count frequency of numbers in the window
        for (const num of window) {
            freqMap.set(num, (freqMap.get(num) || 0) + 1);
        }

        // Convert to array and sort by (frequency desc, value desc)
        const sorted = Array.from(freqMap.entries()).sort((a, b) => {
            if (b[1] === a[1]) return b[0] - a[0]; // tie -> larger number first
            return b[1] - a[1]; // higher frequency first
        });

        // Get top x frequent numbers
        const topX = new Set(sorted.slice(0, x).map(([num]) => num));

        // Calculate x-sum
        let sum = 0;
        for (const num of window) {
            if (topX.has(num)) sum += num;
        }

        result.push(sum);
    }

    return result;
};

```

---

## Example Walkthrough

### Example 1

```
nums = [1,1,2,2,3,4,2,3]
k = 6, x = 2
```

**Step 1: First window [1,1,2,2,3,4]**

* Frequencies:

  ```
  1 → 2
  2 → 2
  3 → 1
  4 → 1
  ```
* Sorted: (by freq desc, value desc)

  ```
  [2,2], [1,2], [4,1], [3,1]
  ```
* Top x = 2 → `{2, 1}`
* Keep only 1s and 2s → [1,1,2,2]
* Sum = **6**

**Step 2: Second window [1,2,2,3,4,2]**

* Frequencies:

  ```
  1 → 1
  2 → 3
  3 → 1
  4 → 1
  ```
* Sorted: [2,3], [4,1], [3,1], [1,1]
* Top x = `{2,4}`
* Keep only 2s and 4 → [2,2,4,2]
* Sum = **10**

**Step 3: Third window [2,2,3,4,2,3]**

* Frequencies:

  ```
  2 → 3
  3 → 2
  4 → 1
  ```
* Sorted: [2,3], [3,2], [4,1]
* Top x = `{2,3}`
* Keep [2,2,3,2,3]
* Sum = **12**

Output = [6, 10, 12]


### Example 2

```
nums = [3,8,7,8,7,5]
k = 2, x = 2
```

Since `x == k`, each window’s x-sum is the full subarray sum.

* [3,8] → 11
* [8,7] → 15
* [7,8] → 15
* [8,7] → 15
* [7,5] → 12

Output = [11, 15, 15, 15, 12]

---

### Summary

| Concept             | Explanation                                                                                   |
| ------------------- | --------------------------------------------------------------------------------------------- |
| **Goal**            | Find sum of top-x frequent numbers (breaking ties by larger number) for each window of size k |
| **Method**          | Frequency map + sorting + sliding window                                                      |
| **Time Complexity** | O(n * k log k)                                                                                |
| **Code**            | Simple and clear implementation using Map and sorting                                         |
| **Examples**        | Match the problem’s expected results: [6,10,12] and [11,15,15,15,12]                          |
