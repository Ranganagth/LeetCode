[2273. Find Resultant Array After Removing Anagrams](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/)

# Intuition

We are repeatedly removing words when two **consecutive words** are anagrams.

However, the key insight is that **the order of removals does not matter** — the problem guarantees the same final result regardless of removal order.

This allows us to simulate the process **once from left to right** using a **stack**.

### Why a Stack Works

When we iterate from left to right:

* For each word `w`, compare it to the **top of the stack** (the most recent word that remains).
* If `w` and `stack[top]` are anagrams, remove the top (or skip pushing `w`).
* Otherwise, push `w` onto the stack.

At the end, the stack represents the final list of words after all possible operations.

---

# Approach

**Step 1:** Define anagram checking

Two words are anagrams if their **sorted characters are the same**:

```typescript
sorted(w1) === sorted(w2)
```

Since each word’s length ≤ 10, sorting each word is O(10 log 10) = O(1) constant time.

We can precompute the “signature” of each word:

```
signature = sorted letters of word
```

**Step 2:** Stack simulation

Iterate through all words:

* If stack is empty → push word.
* Else:

  * Compare the current word’s signature with the top of the stack’s signature.
  * If equal → pop the top (remove last word).
  * Else → push current word.

**Step 3:** Return stack as the final result.

---

# Complexity Analysis

| Operation          | Cost                          |
| ------------------ | ----------------------------- |
| Sorting each word  | O(L log L), L ≤ 10 → O(1)     |
| Loop through words | O(N)                          |
| Total Time         | **O(N)** practically          |
| Space              | **O(N)** (stack + signatures) |

---

# Code

```typescript
function removeAnagrams(words: string[]): string[] {
    const result: string[] = [];
    const getSignature = (w: string): string => [...w].sort().join('');
    for (const word of words) {
        if (result.length && getSignature(result[result.length - 1]) === getSignature(word)) {
            // Skip current word (delete it)
            continue;
        }
        result.push(word);
    }
    return result;
};

```

---

## Example Walkthrough


```
Input: ["a","b","c","d","e"]
```

No two adjacent words are anagrams → no removals.

Output: `["a","b","c","d","e"]`

---
