[3461. Check If Digits Are Equal in String After Operations I](https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/)

# Intuition

We are given a string `s` of digits.
We repeatedly replace the string with a new sequence where **each element is the sum of two consecutive digits modulo 10**, until only **two digits remain**.

Example:
`s = "3902"`
→ `(3+9)%10=2`, `(9+0)%10=9`, `(0+2)%10=2`
→ `"292"`
Repeat until only two digits remain.

Finally, if both digits are the same (e.g., `"11"`, `"00"`, `"77"`), return `true`; otherwise, `false`.

This is essentially a **pairwise modulo addition reduction process**, similar to computing a “triangle sum” or digital reduction pattern.

---

# Approach

1. Convert the string into an array of digits (`number[]`).
2. While the array has more than 2 digits:

   * Create a new array.
   * For each pair `(nums[i], nums[i+1])`, compute `(nums[i] + nums[i+1]) % 10`.
   * Replace `nums` with this new array.
3. When only 2 digits remain, check if they are equal.
4. Return `true` if equal, else `false`.

---

# Complexity Analysis

* **Time Complexity:**
  `O(n²)`
  Because each round reduces the array length by 1, and we perform ~`n + (n-1) + (n-2) + ... + 2` operations ≈ `O(n²)`.

* **Space Complexity:**
  `O(n)` for the intermediate arrays.

Given `n <= 100`, this is perfectly fine.

---

# Code 

```typescript
function hasSameDigits(s: string): boolean {
  // Convert string digits to numbers
  let nums = s.split('').map(Number);

  // Repeat until only two digits remain
  while (nums.length > 2) {
    const next: number[] = [];
    for (let i = 0; i < nums.length - 1; i++) {
      next.push((nums[i] + nums[i + 1]) % 10);
    }
    nums = next;
  }

  // Check final two digits
  return nums[0] === nums[1];
};

```

---

## Example Walkthrough

### Example 1

```
Input: s = "3902"
```

**Step 1:** Convert to array → `[3, 9, 0, 2]`

**Round 1:**

```
(3+9)%10 = 2
(9+0)%10 = 9
(0+2)%10 = 2
=> [2, 9, 2]
```

**Round 2:**

```
(2+9)%10 = 1
(9+2)%10 = 1
=> [1, 1]
```

Now we have `[1, 1]` → both digits same
**Output: true**

### Example 2

```
Input: s = "34789"
```

**Step 1:** `[3, 4, 7, 8, 9]`

**Round 1:**
(3+4)%10=7, (4+7)%10=1, (7+8)%10=5, (8+9)%10=7
→ `[7, 1, 5, 7]`

**Round 2:**
(7+1)%10=8, (1+5)%10=6, (5+7)%10=2
→ `[8, 6, 2]`

**Round 3:**
(8+6)%10=4, (6+2)%10=8
→ `[4, 8]`

`4 != 8`
**Output: false**

---

## Summary

* Intuitive pairwise modulo reduction
* Time: O(n²)
* Space: O(n)

---
