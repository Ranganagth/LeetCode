[1339. Maximum Product of Splitted Binary Tree](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/)

# Intuition

Cut exactly one edge. That split creates two subtree sums: `s` and `total − s`. The product is
`p = s * (total − s)`.
To maximize the product, evaluate it for every possible subtree sum. The only sums that matter are sums of subtrees rooted at each node.

---

# Approach

1. First DFS (post-order): compute the total sum of the tree and record each subtree sum.
2. Second pass over recorded sums: compute `s * (total − s)` and track the maximum.
3. Return the maximum modulo `1e9+7` (after computing the true maximum as a 64-bit number).

Key observation: every possible cut corresponds to removing the edge connecting a subtree to its parent, so evaluating every subtree sum covers every possible cut.

---

# Complexity

- **Time:** `O(n)`
- **Space:** `O(n)` (store subtree sums)

---

# Code

```ts
class TreeNode {
    val: number
    left: TreeNode | null
    right: TreeNode | null
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = val === undefined ? 0 : val
        this.left = left === undefined ? null : left
        this.right = right === undefined ? null : right
    }
}

function maxProduct(root: TreeNode | null): number {
    const MOD = 1_000_000_007;
    const sums: number[] = [];

    const dfs = (node: TreeNode | null): number => {
        if (!node) return 0;
        const left = dfs(node.left);
        const right = dfs(node.right);
        const sum = node.val + left + right;
        sums.push(sum);
        return sum;
    };

    const total = dfs(root);
    let best = 0n;

    for (const s of sums) {
        const a = BigInt(s);
        const b = BigInt(total - s);
        const prod = a * b;
        if (prod > best) best = prod;
    }

    return Number(best % BigInt(MOD));
};

```

---

# Example walkthrough

**root** = `[1,2,3,4,5,6]`

**Subtree sums (post-order):**

* node 4 → 4
* node 5 → 5
* node 2 → 11
* node 6 → 6
* node 3 → 9
* root → total = 20

**Evaluate products:**

* cut below node 4 → 4 * 16 = 64
* cut below node 5 → 5 * 15 = 75
* cut below node 2 → 11 * 9 = 99
* cut below node 6 → 6 * 14 = 84
* cut below node 3 → 9 * 11 = 99

**Maximum** = 110 (from splitting subtree sum 10 and 10 by removing edge under node 1’s left child).
**Return** `110`.

---
