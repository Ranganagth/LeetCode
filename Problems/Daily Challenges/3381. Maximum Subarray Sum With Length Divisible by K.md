[3381. Maximum Subarray Sum With Length Divisible by K](https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/)

# Intuition

A subarray `nums[l..r]` has length divisible by `k` iff
`(r - l + 1) % k == 0` ⇔ `(r + 1) % k == l % k`.

Define prefix sums `P[0] = 0`, `P[i] = nums[0] + ... + nums[i-1]` for `i >= 1`.
Then the subarray sum is `sum(l..r) = P[r+1] - P[l]`.
From the congruence above, `r+1` and `l` share the same remainder mod `k`.

So for each prefix index `i` (which represents `r+1`), to maximize `P[i] - P[l]` with `(i % k) === (l % k)`, we should subtract the **minimum** prefix `P[l]` seen so far for that remainder class. Maintain `minPrefix[rem]` = minimum `P[index]` seen so far with `index % k == rem`.

Initialize `minPrefix[0] = 0` (because `P[0] = 0` at index 0), others `+∞`. Then iterate `i = 1..n`:

* `rem = i % k`
* `candidate = P[i] - minPrefix[rem]` → potential max
* update `maxSum`
* update `minPrefix[rem] = min(minPrefix[rem], P[i])`

---

# Approach

1. Build running prefix `P` on the fly while iterating `i` from `1` to `n`.
2. Keep `minPrefix` array of size `k`, initialize `minPrefix[0] = 0`, others `Infinity`.
3. For each `i`:

   * compute rem = `i % k`
   * compute candidate `P - minPrefix[rem]` and update answer
   * update `minPrefix[rem]` with current prefix
4. Return the maximum found.

---

# Complexity

* Time: `O(n)` where `n = nums.length`
* Space: `O(k)` for `minPrefix` (plus O(1) extra)

---

# Code

```ts
function maxSumDivKSubarray(nums: number[], k: number): number {
    const n = nums.length;
    const minPrefix = new Array<number>(k).fill(Number.POSITIVE_INFINITY);
    minPrefix[0] = 0; // P[0] = 0 at index 0, remainder 0

    let prefix = 0; // will represent P[i] for current i (i from 1..n)
    let maxSum = Number.NEGATIVE_INFINITY;

    for (let i = 1; i <= n; i++) {
        prefix += nums[i - 1]; // P[i] = sum of nums[0..i-1]
        const rem = i % k;

        // If minPrefix[rem] is not Infinity, compute candidate
        const candidate = prefix - minPrefix[rem];
        if (candidate > maxSum) maxSum = candidate;

        // Update min prefix for this remainder
        if (prefix < minPrefix[rem]) minPrefix[rem] = prefix;
    }

    return maxSum;
};

```

---

# Example Walkthrough

`nums = [-1, -2, -3, -4, -5], k = 4`

Compute prefixes `P`:

* `P[0] = 0`
* `P[1] = -1`
* `P[2] = -3`
* `P[3] = -6`
* `P[4] = -10`
* `P[5] = -15`

Iterate i = 1..5:

* i=1 rem=1: candidate = `-1 - ∞ = -∞` (ignored since -∞ < current max which starts -∞ but handled consistently). Update minPrefix[1] = -1
* i=2 rem=2: candidate = `-3 - ∞` ignored. minPrefix[2] = -3
* i=3 rem=3: candidate = `-6 - ∞` ignored. minPrefix[3] = -6
* i=4 rem=0: candidate = `-10 - minPrefix[0](=0) = -10` → maxSum becomes `-10`. Update minPrefix[0] = -10
* i=5 rem=1: candidate = `-15 - minPrefix[1](-1) = -14` → maxSum stays `-10`. Update minPrefix[1] = -15

Answer returned: `-10` (the subarray `nums[0..3] = [-1,-2,-3,-4]`)


