[3607. Power Grid Maintenance](https://leetcode.com/problems/power-grid-maintenance/)

# Intuition

We are dealing with a **dynamic connectivity** problem — the power stations form *connected components (grids)*, and stations can go **offline** and later come **back online** (when we process the queries in reverse).

The challenge is that:

* Going offline does **not break** the grid connections.
* Each query of type `[1, x]` needs to find:

  * If `x` is online → answer is `x`.
  * If `x` is offline → find **the smallest online station id** in the same grid.

If we process the queries **forward**, this is difficult because once a station goes offline, we’d have to dynamically track the smallest online station in its grid (which can be expensive for large graphs).

However, if we process **queries in reverse order**, the problem becomes much simpler:

* Going offline (`[2, x]`) forward means **coming back online** when reversed.
* Thus, we start with all stations offline (based on final state) and **turn them back online** while maintaining connected components.
* Using **Disjoint Set Union (DSU)**, we can easily merge grids and track the **minimum online station ID** in each connected component.

---

# Approach

1. **Build connectivity using DSU**

   * Use a Disjoint Set Union (Union-Find) structure to find and join connected components efficiently.

2. **Preprocess Queries**

   * Traverse all queries to mark which stations go offline.
   * Initially, assume all stations that were turned off at least once are **offline** at the end.

3. **Build initial DSU for online stations**

   * Using connections, join stations only if both are currently **online**.
   * For each connected component, maintain the **minimum online station ID**.

4. **Process queries in reverse**

   * For `[1, x]`:

     * If `x` is online → answer is `x`.
     * Else → find the minimum online station in the same grid (or -1 if none).
   * For `[2, x]`:

     * When reversed, this means the station `x` **comes back online**.
     * Mark it online, merge it with its neighbors that are online, and update the **minimum** value in that component.

5. **Reverse the final results** (because we processed queries backward).

---

# Complexity Analysis

* **Union-Find operations:** `O(α(n))` per operation (almost constant)
* **Building DSU:** `O(n + connections)`
* **Processing queries:** `O(queries × α(n))`

Overall:
**O((n + queries) α(n)) ≈ O(n + queries)**
Works efficiently for up to `10^5` stations and `2×10^5` queries.

---

# Code

```typescript
class DSU {
    parent: number[];
    minOnline: number[];

    constructor(size: number) {
        this.parent = Array.from({ length: size + 1 }, (_, i) => i);
        this.minOnline = Array.from({ length: size + 1 }, (_, i) => i);
    }

    find(x: number): number {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }

    union(u: number, v: number): void {
        let pu = this.find(u);
        let pv = this.find(v);
        if (pu === pv) return;
        if (pu < pv) {
            this.parent[pv] = pu;
            this.minOnline[pu] = Math.min(this.minOnline[pu], this.minOnline[pv]);
        } else {
            this.parent[pu] = pv;
            this.minOnline[pv] = Math.min(this.minOnline[pv], this.minOnline[pu]);
        }
    }

    getMinOnline(x: number): number {
        return this.minOnline[this.find(x)];
    }
}

function processQueries(
    c: number,
    connections: number[][],
    queries: number[][]
): number[] {
    const adj: number[][] = Array.from({ length: c + 1 }, () => []);
    for (const [u, v] of connections) {
        adj[u].push(v);
        adj[v].push(u);
    }

    const offline = Array<boolean>(c + 1).fill(false);
    for (const [op, x] of queries) {
        if (op === 2) offline[x] = true;
    }

    const dsu = new DSU(c);
    const online = Array<boolean>(c + 1).fill(false);

    // Initially, mark online stations that never went offline
    for (let i = 1; i <= c; i++) {
        if (!offline[i]) online[i] = true;
    }

    // Join initially online stations
    for (let i = 1; i <= c; i++) {
        if (online[i]) {
            for (const nb of adj[i]) {
                if (online[nb]) dsu.union(i, nb);
            }
        }
    }

    const ans: number[] = [];

    // Process queries in reverse
    for (let i = queries.length - 1; i >= 0; i--) {
        const [op, x] = queries[i];
        if (op === 1) {
            if (online[x]) {
                ans.push(x);
            } else {
                const root = dsu.find(x);
                const minOnline = dsu.getMinOnline(root);
                ans.push(online[minOnline] ? minOnline : -1);
            }
        } else {
            // Bringing station x back online
            online[x] = true;
            for (const nb of adj[x]) {
                if (online[nb]) dsu.union(x, nb);
            }
        }
    }

    return ans.reverse();
};

```

---

## Example Walkthrough

### Input:

```
c = 5
connections = [[1,2],[2,3],[3,4],[4,5]]
queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]
```

### Step 1: Build graph

Grid:
1—2—3—4—5
All connected.

### Step 2: Mark offline stations

Queries `[2,1]` and `[2,2]` → Initially stations 1 and 2 are **offline**.

So at the end:
Online = {3, 4, 5}

### Step 3: Initialize DSU for currently online

Merge (3,4), (4,5) → All one component `{3,4,5}`, min = 3.

### Step 4: Process queries backward

| Query | Meaning (reverse)       | Action                            | Result                |
| ----- | ----------------------- | --------------------------------- | --------------------- |
| [1,2] | Maintenance check for 2 | Offline → find min in {3,4,5} → 3 | 3                     |
| [2,2] | Bring 2 online          | Merge with {3,4,5}                | 2–3–4–5 merged, min=2 |
| [1,1] | Maintenance check for 1 | Offline → min in {2,3,4,5} = 2    | 2                     |
| [2,1] | Bring 1 online          | Merge → 1–2–3–4–5, min=1          |                       |
| [1,3] | Maintenance check for 3 | Online → 3                        | 3                     |

Now reverse the results → `[3, 2, 3]`

**Final Output:** `[3, 2, 3]`

---

## Summary

| Step               | Technique          | Description                                |
| ------------------ | ------------------ | ------------------------------------------ |
| Build DSU          | Union-Find         | To represent connected power grids         |
| Reverse Queries    | Offline Simulation | Handle "offline" events in reverse         |
| Maintain minOnline | In DSU             | Keep smallest online station per component |
| Complexity         | O((n + q) α(n))    | Efficient for large inputs                 |
