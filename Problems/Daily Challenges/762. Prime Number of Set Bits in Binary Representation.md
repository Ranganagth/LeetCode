[762. Prime Number of Set Bits in Binary Representation](https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/)

# Intuition

For every number in the range `[left, right]`:

1. Convert the number into binary.
2. Count how many `1`s (set bits) it contains.
3. Check whether this count is a **prime number**.
4. Count how many numbers satisfy this condition.

Key observation:

```text
right ≤ 10^6
```

Binary representation of `10^6` needs at most:

```text
≈ 20 bits
```

Therefore:

```text
Maximum possible set bits = 20
```

Prime numbers ≤ 20 are:

```text
2, 3, 5, 7, 11, 13, 17, 19
```

Instead of repeatedly checking primality using expensive logic, simply store primes inside a lookup structure.

---

# Approach

### Step 1 — Prime Lookup

Create a fast lookup table (Set or boolean array):

```text
primeSet = {2,3,5,7,11,13,17,19}
```

Checking prime becomes:

```text
O(1)
```

### Step 2 — Count Set Bits Efficiently

Use **Brian Kernighan’s Algorithm**.

Key trick:

```text
n & (n - 1)
```

removes the lowest set bit.

Example:

```text
101100
101011
------
101000
```

Each iteration removes one `1`.

So:

```text
Loop runs = number of set bits.
```

Very fast.

### Step 3 — Iterate Range

For each number:

1. Count set bits.
2. Check if count exists in prime set.
3. Increase answer.

---

# Complexity

Let:

```text
N = right − left
```

Constraints:

```text
N ≤ 10^4
```

Set bit counting:

```text
O(number of set bits) ≈ O(20)
```

- **Time:**

```text
O(N × log(MaxNumber))
≈ O(10^4 × 20)
≈ very fast
```

- **Space:**

```text
O(1)
```

---

# Code

```typescript
function countPrimeSetBits(left: number, right: number): number {

    // primes possible within 20 bits
    const primes = new Set([
        2, 3, 5, 7, 11, 13, 17, 19
    ]);

    // count set bits using Brian Kernighan Algorithm
    function countBits(n: number): number {
        let count = 0;

        while (n > 0) {
            n &= (n - 1); // remove lowest set bit
            count++;
        }

        return count;
    }

    let ans = 0;

    for (let num = left; num <= right; num++) {

        const bits = countBits(num);

        if (primes.has(bits)) {
            ans++;
        }
    }

    return ans;
};

```

---

# Example Walkthrough

### Example 1

Input:

```text
left = 6
right = 10
```

---

### Number = 6

Binary:

```text
110
```

Set bits:

```text
2
```

Prime:

```text
YES
```

Count = 1

---

### Number = 7

Binary:

```text
111
```

Set bits:

```text
3
```

Prime:

```text
YES
```

Count = 2

---

### Number = 8

Binary:

```text
1000
```

Set bits:

```text
1
```

Prime:

```text
NO
```

Count unchanged.

---

### Number = 9

Binary:

```text
1001
```

Set bits:

```text
2
```

Prime:

```text
YES
```

Count = 3

---

### Number = 10

Binary:

```text
1010
```

Set bits:

```text
2
```

Prime:

```text
YES
```

Count = 4


Final Answer:

```text
4
```

---

## Why This Is Optimal

* No repeated prime computation.
* Fast bit counting.
* Constant extra memory.
* Fully satisfies constraints efficiently.
