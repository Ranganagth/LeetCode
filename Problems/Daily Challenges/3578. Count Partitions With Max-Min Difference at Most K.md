[3578. Count Partitions With Max-Min Difference at Most K](https://leetcode.com/problems/count-partitions-with-max-min-difference-at-most-k/)

**Goal:** count how many ways to split the array into contiguous segments such that **each segment’s max − min ≤ k**.

---

# Intuition

At index `i`, a segment ending at `i` is valid only if all elements in that segment satisfy:

```
max(segment) - min(segment) <= k
```

So for position `i`, we must find the **earliest left index `j` such that nums[j..i] is valid**. Every split between `j` and `i` (inclusive) forms valid DP transitions.

If:

```
dp[x] = number of valid ways to partition nums[0..x-1]
```

Then:

```
dp[i+1] = sum(dp[j], dp[j+1], ..., dp[i])  
where j is smallest index where nums[j..i] valid
```

Instead of summing repeatedly, maintain a **prefix sum array**:

```
prefix[i] = dp[0] + dp[1] + ... + dp[i]
```

Then the formula becomes:

```
dp[i+1] = prefix[i] − prefix[j−1]
```

---

# Maintaining the Window Validity

We must dynamically track max and min inside the sliding window `[j..i]`.

A balanced BST, multiset, or monotonic deque ensures:

```
max - min <= k
```

Whenever the condition breaks, increment `j` and remove expired elements.

---

# Time / Space Complexity

* Maintaining window (sorted): `O(n log n)` using AVL tree or ordered multiset.
* DP + prefix sum: `O(n)`
* Total: `O(n log n)`
* Space: `O(n)` + tree

---

# Code

```ts
import { AvlTree } from "@datastructures-js/binary-search-tree";

function countPartitions(nums: number[], k: number): number {
    const n = nums.length;
    const mod = 1e9 + 7;

    const dp = new Array<number>(n + 1).fill(0);
    const prefix = new Array<number>(n + 1).fill(0);

    const tree = new AvlTree<number>();
    const freq = new Map<number, number>();

    let j = 0;
    dp[0] = 1;
    prefix[0] = 1;

    for (let i = 0; i < n; i++) {
        const f = freq.get(nums[i]) || 0;
        freq.set(nums[i], f + 1);

        if (f === 0) tree.insert(nums[i]);

        while (tree.max().getValue() - tree.min().getValue() > k) {
            const leftFreq = freq.get(nums[j])!;
            freq.set(nums[j], leftFreq - 1);
            if (leftFreq === 1) tree.remove(nums[j]);
            j++;
        }

        dp[i + 1] = (prefix[i] - (j > 0 ? prefix[j - 1] : 0) + mod) % mod;
        prefix[i + 1] = (prefix[i] + dp[i + 1]) % mod;
    }

    return dp[n];
};

```

---

# Working Example

**Input:**

```
nums = [9,4,1,3,7], k = 4
```

**Processing:**

| i | Window                      | Valid range j..i       | dp[i+1]          | Explanation                                      |
| - | --------------------------- | ---------------------- | ---------------- | ------------------------------------------------ |
| 0 | [9]                         | 0..0                   | 1                | One segment `[9]`                                |
| 1 | [9,4]→invalid → shrink →[4] | 1..1                   | 1                | Only `[4]`, dp adds 1                            |
| 2 | [4,1]                       | 2..2 and `[4,1]` valid | 2                | Ways: `[1]`, `[4,1]`                             |
| 3 | [4,1,3]                     | valid window           | 4                | Ways double: endings `[3]`,`[1,3]`,`[4,1,3]` etc |
| 4 | extend, window stays valid  | 6                      | Matches expected |                                                  |

Result: **6**

---

## Key Insight

The solution combines:

* **Sliding window** → find valid segment bounds.
* **Balanced tree** → maintain dynamic min/max.
* **Prefix-sum DP** → compute number of ways efficiently.

The structure ensures all valid partitions are counted without recomputing sums.

---
