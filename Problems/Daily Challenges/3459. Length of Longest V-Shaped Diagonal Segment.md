[3459. Length of Longest V-Shaped Diagonal Segment](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/)

# Intuition

We need to find the **longest diagonal segment** starting with `1` and following the repeating pattern:
`1 → 2 → 0 → 2 → 0 → ...`

The segment can move diagonally in one of the 4 possible directions:

* Top-left → bottom-right
* Bottom-right → top-left
* Top-right → bottom-left
* Bottom-left → top-right

It can **optionally make one clockwise 90° turn** and then must continue in that new diagonal direction while still following the sequence.

This is essentially a **DFS search with memoization** problem on a grid with states defined by:

* Current cell `(x, y)`
* Current direction (0–3)
* Whether the turn is still available (boolean)
* Next target number in the sequence (2 or 0)

---

# Approach

1. Define the **four diagonal directions** as `DIRS = [[1,1],[1,-1],[-1,-1],[-1,1]]`.
2. Use DFS to explore the path:

   * If the next cell is valid and matches the target number, recurse deeper.
   * Otherwise stop.
3. Memoize states to avoid recomputation:

   * State index = `(x, y, direction, turnAvailable)` → store max length.
4. From each starting cell containing `1`, try walking in all 4 diagonal directions with turn allowed.
5. Update the result with the maximum length found.

---

# Complexity

* **Time complexity:**
  Each state `(x, y, direction, turnAvailable)` is computed at most once.
  Total states = `n * m * 4 * 2 = O(n * m)`
  Each DFS call is O(1) after memoization.
  → **O(n \* m)**
* **Space complexity:**

  * Memo table = `O(n * m * 8)`
  * DFS recursion depth = `O(n + m)` in worst case.
    → **O(n \* m)**

---

# Code

```typescript
// Correct solution for the given problem statement
function lenOfVDiagonal(grid: number[][]): number {
    const DIRS = [
        [1, 1],   // down-right
        [1, -1],  // down-left
        [-1, -1], // up-left
        [-1, 1],  // up-right
    ];

    const m = grid.length, n = grid[0].length;
    const memo: number[] = new Array(m * n * 8).fill(-1);

    function dfs(cx: number, cy: number, direction: number, turn: boolean, target: number): number {
        const nx = cx + DIRS[direction][0];
        const ny = cy + DIRS[direction][1];

        // Out of bounds or mismatch in expected value
        if (nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] !== target) {
            return 0;
        }

        const turnInt = turn ? 1 : 0;
        const index = nx * n * 8 + ny * 8 + direction * 2 + turnInt;
        if (memo[index] !== -1) {
            return memo[index];
        }

        // Continue straight
        let maxStep = dfs(nx, ny, direction, turn, 2 - target);

        // If turn available, try 90° clockwise rotation
        if (turn) {
            maxStep = Math.max(
                maxStep,
                dfs(nx, ny, (direction + 1) % 4, false, 2 - target)
            );
        }

        memo[index] = maxStep + 1;
        return memo[index];
    }

    let res = 0;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                for (let direction = 0; direction < 4; direction++) {
                    res = Math.max(res, dfs(i, j, direction, true, 2) + 1);
                }
            }
        }
    }
    return res;
};

```

---

# Example walkthrough

### Example 1

`grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]`

* Start at `(0,2)` with value `1`.
* Move diagonally down-right: `(1,3)=2`, `(2,4)=0`.
* At `(2,4)`, make a clockwise turn → new direction is down-left.
* Continue: `(3,3)=2`, `(4,2)=2`.
* Segment length = 5.

Output = **5**.

---
