[1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/)

# Intuition

A square’s sum must be computed repeatedly for many positions and sizes. Brute force recomputation is too slow.
Key reduction: if the sum of any `k × k` square can be queried in O(1), then we can **binary search on k** and validate feasibility efficiently.

This is a classic **2D prefix sum + binary search on answer** problem.

---

# Approach

1. **Build 2D prefix sum**

   * `prefix[i][j]` = sum of submatrix `(0,0)` to `(i-1,j-1)`
   * Enables O(1) sum query for any submatrix

2. **Check if a square of side k is valid**

   * For all possible top-left positions `(i,j)`
   * Compute square sum using prefix sums
   * If any square ≤ `threshold`, k is feasible

3. **Binary search on side length**

   * Search range: `0` to `min(m, n)`
   * Monotonic property: if size `k` is feasible, all smaller sizes are feasible

### Prefix Sum Formula

For square with top-left `(r,c)` and size `k`:

```
sum =
prefix[r+k][c+k]
- prefix[r][c+k]
- prefix[r+k][c]
+ prefix[r][c]
```

---

# Complexity

* Prefix sum construction: **O(m · n)**
* Feasibility check per k: **O(m · n)**
* Binary search: **O(log(min(m,n)))**

**Total:** `O(m · n · log(min(m,n)))`
**Space:** `O(m · n)`

---

# Code

```ts
function maxSideLength(mat: number[][], threshold: number): number {
    const m = mat.length;
    const n = mat[0].length;

    // Prefix sum array
    const prefix: number[][] = Array.from({ length: m + 1 }, () =>
        Array(n + 1).fill(0)
    );

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            prefix[i][j] =
                mat[i - 1][j - 1] +
                prefix[i - 1][j] +
                prefix[i][j - 1] -
                prefix[i - 1][j - 1];
        }
    }

    const canForm = (k: number): boolean => {
        for (let i = 0; i + k <= m; i++) {
            for (let j = 0; j + k <= n; j++) {
                const sum =
                    prefix[i + k][j + k] -
                    prefix[i][j + k] -
                    prefix[i + k][j] +
                    prefix[i][j];
                if (sum <= threshold) return true;
            }
        }
        return false;
    };

    let left = 0;
    let right = Math.min(m, n);

    while (left < right) {
        const mid = Math.floor((left + right + 1) / 2);
        if (canForm(mid)) left = mid;
        else right = mid - 1;
    }

    return left;
};

```

---

# Example Walkthrough

**Input**

```
mat =
[
 [1,1,3,2,4,3,2],
 [1,1,3,2,4,3,2],
 [1,1,3,2,4,3,2]
]
threshold = 4
```

* Binary search tries `k = 2`
* Square at `(0,0)`:

  ```
  1 1
  1 1  → sum = 4 ≤ threshold
  ```
* `k = 3` fails everywhere (minimum sum is > 4)
* Maximum valid side length = **2**

**Output**

```
2
```

---

### Key Insight

The constraint is not about location but **square size**.
Prefix sums turn spatial enumeration into a fast feasibility check, enabling binary search.
