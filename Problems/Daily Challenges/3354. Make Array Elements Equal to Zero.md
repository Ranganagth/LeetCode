[3354. Make Array Elements Equal to Zero](https://leetcode.com/problems/make-array-elements-equal-to-zero/)

# Intuition

We’re simulating a **bouncing traversal** along the array, starting from a **zero cell**, moving left or right.
Whenever we hit a **non-zero element**, we:

* Decrement it by 1.
* Reverse direction.
* Continue moving.

Whenever we hit a **zero**, we just move forward in the same direction.

The process ends when we move **out of bounds**.
A selection (start index and direction) is **valid** if, after the process, all numbers in `nums` become `0`.

## Key Observations

1. We can start only from positions where `nums[i] == 0`.
2. There are two possible directions for each zero: **left** and **right**.
3. The operation depends on the **path** we take and the **number of bounces** off non-zero cells.
4. Since each element can be decremented multiple times (up to 100), brute force simulation is fine within constraints (`n <= 100`, `nums[i] <= 100`).

---

# Approach

1. For each index `i` where `nums[i] == 0`:

   * Simulate the process twice:

     * Once moving **right** (direction = +1).
     * Once moving **left** (direction = -1).
2. During the simulation:

   * If `curr` moves out of `[0, n-1]`, stop.
   * If `nums[curr] == 0`: move one step in the same direction.
   * Else (non-zero):

     * Decrement `nums[curr]` by 1.
     * Reverse direction.
     * Move one step in the **new direction**.
3. After the loop ends, check if all elements in the array are `0`.
4. Count how many starting choices lead to all zeros.

We’ll make a **copy of the array** during each simulation, so the original `nums` remains unchanged.

---

# Complexity Analysis

* **Time Complexity:**
  O(k × n × m)
  where

  * k = number of zero positions (≤ n),
  * n = array length (≤ 100),
  * m = maximum number of decrements (≤ 100).
    In practice, ≤ 100 × 100 × 100 = 1,000,000 → feasible.

* **Space Complexity:**
  O(n) for simulation array copy.

---

# Code

```typescript
function countValidSelections(nums: number[]): number {
  const n = nums.length;
  let count = 0;

  // Helper to simulate the process
  const simulate = (start: number, dir: number): boolean => {
    const arr = [...nums]; // copy to preserve original
    let curr = start;

    while (curr >= 0 && curr < n) {
      if (arr[curr] === 0) {
        curr += dir;
      } else {
        arr[curr]--;
        dir *= -1; // reverse direction
        curr += dir;
      }
    }

    // Check if all are zero
    return arr.every(v => v === 0);
  };

  for (let i = 0; i < n; i++) {
    if (nums[i] === 0) {
      if (simulate(i, 1)) count++;  // right
      if (simulate(i, -1)) count++; // left
    }
  }

  return count;
};

```

---

## Example Walkthrough

### Input:

```text
nums = [1, 0, 2, 0, 3]
```

### Step 1: Possible start positions → indices with zero

`[1, 3]`

### Case 1 → Start at index 1, move left

* We move to index 0: decrement `1 → 0`, reverse to right
* Move to index 1 (zero) → right
* Move to index 2 → decrement `2 → 1`, reverse to left
* Back to index 1 → zero → move left → out of bounds
  → End with `[0, 0, 1, 0, 3]` (not all zeros) → invalid

### Case 2 → Start at index 1, move right

* Similar simulation leaves non-zero values → invalid

### Case 3 → Start at index 3, move left

After simulation, we end with `[0, 0, 0, 0, 0]` →  valid

### Case 4 → Start at index 3, move right

Also ends with all zeros → valid

**Total valid = 2**

**Output**

```text
2
```


## Example 2

### Input:

```text
nums = [2, 3, 4, 0, 4, 1, 0]
```

* Only starting indices: 3, 6.
* Simulation from both left/right directions → no case reduces all to zeros.

**Output: 0**

---
