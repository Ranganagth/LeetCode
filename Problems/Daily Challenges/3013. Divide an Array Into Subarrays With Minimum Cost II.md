[3013. Divide an Array Into Subarrays With Minimum Cost II](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/)

# Intuition

You must split `nums` into **k contiguous subarrays**.

* The **cost** of each subarray is its **first element**.
* The first subarray always starts at index `0`, so `nums[0]` is always included.
* Let the starting indices of the remaining subarrays be:

```
i1, i2, ..., i(k−1)
```

The total cost becomes:

```
nums[0] + nums[i1] + nums[i2] + ... + nums[i(k−1)]
```

### Constraint

You are given an additional restriction:

```
i(k−1) − i1 ≤ dist
```

This means:

* The first and last cuts (excluding index 0) must lie within a **window of length dist**

So the problem becomes:

> Choose `k−1` starting indices from `nums[1…n−1]` such that
>
> * They are increasing
> * The distance between the first and last chosen indices is ≤ `dist`
> * The **sum of the chosen values is minimized**

## Key Observation

Fix the **last cut position** `i(k−1) = r`.

Then:

* `i1` must be ≥ `r − dist`
* The remaining `k−2` cuts must be chosen from the range:

  ```
  (r − dist + 1) … (r − 1)
  ```

So for each possible `r`, the task is:

> From a sliding window, pick the **smallest `k−2` values**, add `nums[r]`, and minimize the sum.

This is a classic **sliding window + k-smallest-elements** problem.

---

# Approach

### Data Structure: Two balanced multisets

We maintain:

* **Set A (tree1)** → the smallest `k−2` elements (their sum is tracked)
* **Set B (tree2)** → all other elements in the window

This allows:

* O(log n) insert
* O(log n) delete
* O(1) query of the sum of smallest `k−2` elements

### Sliding Window Logic

1. Initially:

   * Insert elements `nums[1 … k−2]` into the structure

2. For each possible last cut `r` from `k−1` to `n−1`:

   * Ensure the window respects the `dist` constraint
   * Remove elements that fall out of the window
   * Add the new candidate element
   * Compute:

     ```
     cost = nums[r] + sum_of_smallest_(k−2)
     ```
   * Track the minimum

3. Add `nums[0]` at the end (first subarray cost)

## Why This Is Optimal

* All valid partitions are considered
* Each window efficiently maintains the minimal possible sum
* No brute force over combinations
* Time-efficient for `n ≤ 10^5`

---

# Complexity

* **Time:** `O(n log n)`
* **Space:** `O(k)`

---

# Code

```ts
import {
    AvlTree,
    BinarySearchTree,
    BinarySearchTreeNode,
    AvlTreeNode,
} from "@datastructures-js/binary-search-tree";

class Container {
    private k: number;
    private st1: Map<number, number>;
    private st2: Map<number, number>;
    private st1Size: number;
    private st2Size: number;
    private tree1: AvlTree<number>;
    private tree2: AvlTree<number>;
    private sm: number;

    constructor(k: number) {
        this.k = k;
        this.st1 = new Map<number, number>();
        this.st2 = new Map<number, number>();
        this.st1Size = 0;
        this.st2Size = 0;
        this.tree1 = new AvlTree<number>((a: number, b: number) => a - b);
        this.tree2 = new AvlTree<number>((a: number, b: number) => a - b);
        this.sm = 0;
    }

    add(x: number): void {
        if (this.st2Size > 0 && x >= this.tree2.min().getValue()) {
            this.tree2.insert(x);
            this.st2.set(x, (this.st2.get(x) || 0) + 1);
            this.st2Size++;
        } else {
            this.tree1.insert(x);
            this.st1.set(x, (this.st1.get(x) || 0) + 1);
            this.sm += x;
            this.st1Size++;
        }
        this.adjust();
    }

    erase(x: number): void {
        if (this.st1.has(x) && this.st1.get(x)! > 0) {
            this.st1.set(x, this.st1.get(x)! - 1);
            this.st1Size--;
            if (this.st1.get(x)! === 0) {
                this.st1.delete(x);
                this.tree1.remove(x);
            }
            this.sm -= x;
        } else if (this.st2.has(x) && this.st2.get(x)! > 0) {
            this.st2.set(x, this.st2.get(x)! - 1);
            this.st2Size--;
            if (this.st2.get(x)! === 0) {
                this.st2.delete(x);
                this.tree2.remove(x);
            }
        }
        this.adjust();
    }

    private adjust(): void {
        while (this.st1Size < this.k && this.st2Size > 0) {
            const x = this.tree2.min().getValue();
            this.st1Size++;
            this.st2Size--;
            this.st2.set(x, this.st2.get(x)! - 1);
            if (this.st2.get(x)! === 0) {
                this.tree2.remove(x);
                this.st2.delete(x);
            }
            this.st1.set(x, (this.st1.get(x) || 0) + 1);
            this.tree1.insert(x);
            this.sm += x;
        }

        while (this.st1Size > this.k) {
            const x = this.tree1.max().getValue();
            this.st1Size--;
            this.st2Size++;
            this.st1.set(x, this.st1.get(x)! - 1);
            if (this.st1.get(x)! === 0) {
                this.tree1.remove(x);
                this.st1.delete(x);
            }
            this.st2.set(x, (this.st2.get(x) || 0) + 1);
            this.tree2.insert(x);
            this.sm -= x;
        }
    }

    sum(): number {
        return this.sm;
    }
}

function minimumCost(nums: number[], k: number, dist: number): number {
    const n = nums.length;
    const cnt = new Container(k - 2);
    for (let i = 1; i < k - 1; i++) {
        cnt.add(nums[i]);
    }

    let ans = cnt.sum() + nums[k - 1];
    for (let i = k; i < n; i++) {
        const j = i - dist - 1;
        if (j > 0) {
            cnt.erase(nums[j]);
        }
        cnt.add(nums[i - 1]);
        ans = Math.min(ans, cnt.sum() + nums[i]);
    }

    return ans + nums[0];
};

```

---

# Example Walkthrough

### Example 1

```
nums = [1,3,2,6,4,2], k = 3, dist = 3
```

We need:

* `nums[0]`
* choose **2 more starting indices** within distance ≤ 3

Best choice:

```
cuts at indices 2 and 5
cost = nums[0] + nums[2] + nums[5]
     = 1 + 2 + 2 = 5
```

---

## Final Insight

This is a **sliding window + order statistics** problem.

The key leap is realizing:

> For each valid window, you only care about the **smallest `k−2` values**, not their order.

That insight turns an exponential partitioning problem into a clean `O(n log n)` solution.
