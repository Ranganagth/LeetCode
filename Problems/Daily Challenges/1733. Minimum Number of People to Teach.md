[1733. Minimum Number of People to Teach](https://leetcode.com/problems/minimum-number-of-people-to-teach/)

# Intuition

* We have `m` users, each knowing some subset of the `n` languages.
* Two users in a friendship must have **at least one common language** to communicate.
* If they don’t, we must **teach one language** (the same one for all chosen users) to make them able to communicate.

So the key questions are:

1. **Which friendships are broken?**

   * A friendship `[u, v]` is broken if `languages[u]` and `languages[v]` have no intersection.
2. **Which language should we teach?**

   * If we choose a language `L`, then for every broken friendship, at least one endpoint must learn `L`.
   * To minimize the teaching, we want to choose the language `L` that **is already known by the maximum number of users among those who appear in broken friendships**.

So the minimum users to teach =

```
(total distinct users in broken friendships) - (max number of them already knowing a chosen language)
```

---

# Approach

1. Build a set of users involved in **broken friendships**:

   * For each friendship `[u, v]`, check if `languages[u] ∩ languages[v]` is empty.
   * If yes, add both `u` and `v` to the `candidates` set.
2. If no broken friendships exist → return `0`.
3. For each language `L`:

   * Count how many users in `candidates` already know `L`.
4. Answer = `|candidates| - maxCount`.

---

# Complexity

* Let `m` = number of users, `n` = number of languages, `f` = number of friendships.
* Checking intersections: `O(f * avgLangPerUser)` (bounded by `O(f * n)` worst case).
* Counting per language: `O(m * avgLangPerUser)` (bounded by `O(m * n)`).
* Overall: **O(m \* n + f \* n)**, feasible since `m, n, f ≤ 500`.

---

# Code

```typescript
function minimumTeachings(
  n: number,
  languages: number[][],
  friendships: number[][]
): number {
  const m = languages.length;
  const userLangs: Set<number>[] = languages.map(langs => new Set(langs));

  const candidates = new Set<number>();

  // Step 1: Find broken friendships
  for (const [u, v] of friendships) {
    const uSet = userLangs[u - 1];
    const vSet = userLangs[v - 1];
    let canCommunicate = false;

    for (const lang of uSet) {
      if (vSet.has(lang)) {
        canCommunicate = true;
        break;
      }
    }
    if (!canCommunicate) {
      candidates.add(u - 1);
      candidates.add(v - 1);
    }
  }

  // Step 2: If no broken friendships
  if (candidates.size === 0) return 0;

  // Step 3: Count for each language
  let maxKnown = 0;
  for (let lang = 1; lang <= n; lang++) {
    let count = 0;
    for (const user of candidates) {
      if (userLangs[user].has(lang)) count++;
    }
    maxKnown = Math.max(maxKnown, count);
  }

  // Step 4: Result
  return candidates.size - maxKnown;
};

```

---

## Example Walkthrough

### Example 1

Input:

```
n = 2
languages = [[1],[2],[1,2]]
friendships = [[1,2],[1,3],[2,3]]
```

* Friendships:

  * (1,2): User1 knows `{1}`, User2 knows `{2}` → broken → add {1,2}.
  * (1,3): User1 `{1}`, User3 `{1,2}` → overlap → ok.
  * (2,3): User2 `{2}`, User3 `{1,2}` → overlap → ok.
* `candidates = {0, 1}` (users 1 and 2).
* Count:

  * Lang1: User1 knows it → 1, User2 does not → total 1.
  * Lang2: User2 knows it → 1, User1 does not → total 1.
* `maxKnown = 1`.
* Result = `2 - 1 = 1`.

Output: **1**

---

### Example 2

Input:

```
n = 3
languages = [[2],[1,3],[1,2],[3]]
friendships = [[1,4],[1,2],[3,4],[2,3]]
```

* Friendships:

  * (1,4): `{2}` vs `{3}` → broken → add {1,4}.
  * (1,2): `{2}` vs `{1,3}` → broken → add {1,2}.
  * (3,4): `{1,2}` vs `{3}` → broken → add {3,4}.
  * (2,3): `{1,3}` vs `{1,2}` → overlap `{1}` → ok.
* `candidates = {0,1,2,3}` (all users).
* Count:

  * Lang1: Users 2,3 → 2.
  * Lang2: Users 1,3 → 2.
  * Lang3: Users 2,4 → 2.
* `maxKnown = 2`.
* Result = `4 - 2 = 2`.

Output: **2**

---
