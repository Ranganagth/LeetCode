[761. Special Binary String](https://leetcode.com/problems/special-binary-string/)

# Intuition

A **special binary string** behaves exactly like a **balanced parentheses sequence** if:

```
1 → "("
0 → ")"
```

Rules become:

1. Equal number of `1`s and `0`s → balanced.
2. Every prefix has at least as many `1`s as `0`s → valid parentheses.

Example:

```
11011000
```

can be viewed as:

```
( ( ) ( ( ) ) )
```

Key Observation:

A special string can always be decomposed into:

```
1 + special substring + 0
```

Example:

```
11011000

= 1 (101100) 0
```

Inside it contains smaller special substrings.

Allowed operation:

```
Swap TWO consecutive special substrings.
```

Goal:

```
Make lexicographically largest string.
```

Lexicographically largest binary string:

```
More 1s earlier → larger.
```

Therefore:

```
Sort special substrings in descending lexicographic order.
```

---

# Core Idea

Recursively:

1. Split string into **top-level special substrings**.

Each substring looks like:

```
1 + inner_special + 0
```

Example:

```
11011000
```

Split:

```
11011000 → only one top-level block
```

Inside:

```
101100
```

Split again:

```
10 | 1100
```

Now these are independent special substrings.

---

## Strategy

For a string `s`:

### Step 1 — Partition into special substrings

Use balance counter:

```
+1 for '1'
-1 for '0'
```

Whenever balance becomes zero:

```
we found a special substring.
```

### Step 2 — Recursively optimize inner substring

For substring:

```
1 + middle + 0
```

Process:

```
largestSpecial(middle)
```

Then rebuild:

```
1 + processed_middle + 0
```

### Step 3 — Sort substrings descending

Because swapping consecutive substrings is allowed.

Example:

```
"10" , "1100"
```

Sort descending:

```
"1100" , "10"
```

### Step 4 — Join together

Return joined string.

---

## Approach Summary

```
Recursion + Divide and Conquer + Greedy Sorting
```

---

# Complexity

Let:

```
n = length of string
```

Worst case recursion depth:

```
O(n)
```

Sorting substrings repeatedly.

- **Time:** O(n² log n)
	(n ≤ 50 → easily safe)

- **Space:** O(n)

---

# Code

```typescript
function makeLargestSpecial(s: string): string {

    const res: string[] = [];

    let count = 0;
    let start = 0;

    for (let i = 0; i < s.length; i++) {

        // balance tracking
        if (s[i] === '1') count++;
        else count--;

        // found special substring
        if (count === 0) {

            // remove outer 1 and 0
            const inner =
                s.substring(start + 1, i);

            // recursively optimize inside
            const optimizedInner =
                makeLargestSpecial(inner);

            res.push(
                "1" + optimizedInner + "0"
            );

            start = i + 1;
        }
    }

    // lexicographically largest → descending sort
    res.sort((a, b) => b.localeCompare(a));

    return res.join("");
};

```

---

# Example Walkthrough

### Example 1

```
s = "11011000"
```

### Step 1 — Split

Balance tracking:

```
11011000
^^^^^^^^
whole string is one special block
```

Remove outer:

```
inner = "101100"
```

### Step 2 — Recursive Split

```
101100
```

Split:

```
10 | 1100
```

Two special substrings.

### Step 3 — Recursively optimize each

```
"10" → already optimal

"1100"
inner = "10"
→ already optimal
```

### Step 4 — Sort descending

Compare:

```
1100 > 10
```

Arrange:

```
1100 + 10
```

Result:

```
110010
```


### Step 5 — Add outer wrapper

Original outer:

```
1 + 110010 + 0
```

Result:

```
11100100
```

**Output:**

```
11100100
```

---

### Example 2

```
s = "10"
```

Single special substring.

No swaps possible.

**Output:**

```
10
```
