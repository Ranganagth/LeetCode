[679. 24 Game](https://leetcode.com/problems/24-game/)

# Intuition

We need to check whether four numbers can be combined using arithmetic operations (`+`, `-`, `*`, `/`) and parentheses to make `24`.

The tricky parts:
* Order matters (because `(a - b)` ≠ `(b - a)` and `(a / b)` ≠ `(b / a)`).
* Parentheses matter (different grouping gives different results).
* We must use **all four numbers** exactly once.
* Division is **real division**, so floating-point comparisons are involved.

This naturally suggests a **backtracking / recursive search**:
* At each step, pick two numbers from the list.
* Replace them with the result of applying one of the four operators.
* Continue until only one number remains.
* If that number is close enough to `24` (within floating-point tolerance), return true.

---

# Approach

1. **Recursive Backtracking**
   * Start with the array of numbers.
   * If the array length is 1, check if the number is approximately 24.
   * Otherwise, pick every pair `(a, b)` from the array.
   * Apply all operations (`a+b`, `a-b`, `b-a`, `a*b`, `a/b`, `b/a` if denominator ≠ 0).
   * Recursively call the function with the reduced array.
   * If any path leads to 24, return true.

2. **Floating Point Precision**
   * Since division is involved, we allow a tolerance `EPS = 1e-6`.

3. **Base Case**
   * When only one number is left, check if `|num - 24| < EPS`.

---

# Complexity

* There are only **4 numbers**, so the recursion depth is small.
* At each level, we pick pairs (O(n²)) and apply up to 6 operations.
* The branching factor reduces since the list shrinks.
* Overall complexity is roughly **O(4! × operators^3)** ≈ constant (fast enough).

---

# Code

```typescript
function judgePoint24(cards: number[]): boolean {
    const EPS = 1e-6;

    function dfs(nums: number[]): boolean {
        // Base case: only one number left
        if (nums.length === 1) {
            return Math.abs(nums[0] - 24) < EPS;
        }

        // Try all pairs of numbers
        for (let i = 0; i < nums.length; i++) {
            for (let j = 0; j < nums.length; j++) {
                if (i === j) continue;

                // Remaining numbers after picking i, j
                let next: number[] = [];
                for (let k = 0; k < nums.length; k++) {
                    if (k !== i && k !== j) {
                        next.push(nums[k]);
                    }
                }

                // Try all possible results of nums[i] and nums[j]
                for (let result of compute(nums[i], nums[j])) {
                    next.push(result);
                    if (dfs(next)) return true;
                    next.pop(); // backtrack
                }
            }
        }
        return false;
    }

    function compute(a: number, b: number): number[] {
        const results: number[] = [a + b, a - b, b - a, a * b];
        if (Math.abs(b) > EPS) results.push(a / b);
        if (Math.abs(a) > EPS) results.push(b / a);
        return results;
    }

    return dfs(cards);
};

```

---

## **Example Walkthrough**

### Example 1:
**Input:**
`cards = [4, 1, 8, 7]`

### Steps:
1. Pick `8` and `4`.
   Try `(8 - 4) = 4`.
   Remaining = `[1, 7, 4]`.

2. Pick `7` and `1`.
   Try `(7 - 1) = 6`.
   Remaining = `[4, 6]`.

3. Pick `6` and `4`.
   Try `(6 * 4) = 24`.
   Remaining = `[24]`.

4. Base case: `24 ≈ 24` → **return true**.

**Output:** `true`

### Example 2:
**Input:** `cards = [1, 2, 1, 2]`
No combination works → returns `false`.
**Output:** `false`

---

## Summary

The solution uses **recursive backtracking with floating-point handling**. It is efficient for 4 cards, and guaranteed to finish quickly.

---
