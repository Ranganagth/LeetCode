[3651. Minimum Cost Path with Teleportations](https://leetcode.com/problems/minimum-cost-path-with-teleportations/)

# Intuition

Without teleportation, this is a standard **minimum path sum** problem where you can only move **right or down**.

Teleportation complicates things because:

* You can jump **from any cell to any other cell** with **value ≤ current cell**
* Teleport cost is **0**
* Teleport can be used **at most `k` times**

Key insight:

> Teleportation lets you “reset” your position cost-wise to **any cheaper or equal-valued cell**, but only a limited number of times.

So the problem becomes:

* Alternate between **teleport relaxations** and **normal grid DP**
* Do this at most `k` times

This leads to a **layered dynamic programming** approach.

---

# Core Idea

We maintain:

```
costs[i][j] = minimum cost to reach (m-1, n-1) from cell (i, j)
```

We compute this value by:

1. Allowing **teleportation** (global relaxations)
2. Allowing **normal right/down moves** (grid DP)

Repeat this process **k + 1 times**.

## Why This Works

Teleportation:

* From a cell `(i,j)`, you can teleport to *any* cell `(x,y)` where
  `grid[x][y] ≤ grid[i][j]`
* This means all cells with **lower or equal values** can share the **minimum cost among them**

So:

* Sort all cells by `grid value`
* Propagate the minimum cost forward among eligible cells

Normal moves:

* Standard DP from bottom-right to top-left
* Use right and down transitions

Each teleport layer **globally improves** costs.

---

# Approach (Step-by-Step)

### Step 1: Flatten and Sort Cells

* Create a list of all `(i, j)` positions
* Sort them by `grid[i][j]`

This helps process teleportation efficiently.

### Step 2: Initialize Cost Matrix

* `costs[i][j] = ∞`
* Final cell `(m-1, n-1)` will later be set to `0`

### Step 3: Repeat for `t = 0 .. k`

Each iteration represents allowing **one more teleport**.

#### 3.1 Teleport Relaxation

* Sweep cells in increasing grid value order
* Track the **minimum cost seen so far**
* Assign that minimum cost to all cells with the same grid value

This simulates:

> From any higher-value cell, you can teleport to all lower-value cells at zero cost.

#### 3.2 Normal Grid DP

Traverse from bottom-right to top-left:

* From `(i,j)` you may go:

  * Down → `(i+1, j)`
  * Right → `(i, j+1)`
* Add cost of destination cell

### Step 4: Answer

* The answer is `costs[0][0]`

---

# Complexity

* **Time Complexity:**
$$  O(k \cdot m \cdot n)$$
  where `k ≤ 10`, `m,n ≤ 80`

* **Space Complexity:**
$$  O(m \cdot n)$$

This is optimal and well within constraints.

---

# Code

```ts
function minCost(grid: number[][], k: number): number {
    const m = grid.length;
    const n = grid[0].length;

    // Collect all grid positions
    const points: [number, number][] = [];
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            points.push([i, j]);
        }
    }

    // Sort positions by grid value
    points.sort((a, b) => grid[a[0]][a[1]] - grid[b[0]][b[1]]);

    // costs[i][j] = minimum cost to reach (m-1, n-1) from (i, j)
    const costs = Array.from({ length: m }, () =>
        Array(n).fill(Number.MAX_SAFE_INTEGER),
    );

    // Perform k+1 DP layers
    for (let t = 0; t <= k; t++) {
        // Teleportation relaxation
        let minCost = Number.MAX_SAFE_INTEGER;
        let j = 0;

        for (let i = 0; i < points.length; i++) {
            const [x, y] = points[i];
            minCost = Math.min(minCost, costs[x][y]);

            if (
                i + 1 < points.length &&
                grid[points[i][0]][points[i][1]] ===
                    grid[points[i + 1][0]][points[i + 1][1]]
            ) {
                continue;
            }

            for (let r = j; r <= i; r++) {
                const [px, py] = points[r];
                costs[px][py] = minCost;
            }
            j = i + 1;
        }

        // Normal grid DP (right and down)
        for (let i = m - 1; i >= 0; i--) {
            for (let j = n - 1; j >= 0; j--) {
                if (i === m - 1 && j === n - 1) {
                    costs[i][j] = 0;
                    continue;
                }
                if (i + 1 < m) {
                    costs[i][j] = Math.min(
                        costs[i][j],
                        costs[i + 1][j] + grid[i + 1][j],
                    );
                }
                if (j + 1 < n) {
                    costs[i][j] = Math.min(
                        costs[i][j],
                        costs[i][j + 1] + grid[i][j + 1],
                    );
                }
            }
        }
    }

    return costs[0][0];
};

```

---

# Example Walkthrough

### Example 1

```
grid =
[ [1,3,3],
  [2,5,4],
  [4,3,5] ]
k = 2
```

Best path:

```
(0,0) → (1,0) → (1,1)
Teleport → (2,2)
```

Cost:

```
2 + 5 = 7
```

Output:

```
7
```

---

## Final Insight

This problem is a **hybrid of shortest path and DP**, where teleportation acts as a **global relaxation operator**.
By alternating teleport relaxations and grid DP layers, we efficiently explore all optimal paths within teleport limits.
