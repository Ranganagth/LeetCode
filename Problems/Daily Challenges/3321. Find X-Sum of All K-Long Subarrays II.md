[3321. Find X-Sum of All K-Long Subarrays II](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/)

# Intuition

We need to compute the **x-sum** of every subarray of size `k` in `nums`.

For each subarray:

1. Count the frequency of every element.
2. Choose the **x most frequent** elements:

   * If frequencies tie → choose the **larger element value**.
3. Compute the sum of all **occurrences** of those `x` elements.

Naively, this would require recalculating frequencies and sorting for every window, costing **O(k log k)** per window → too slow for `n = 1e5`.

## Core Idea - Efficient Sliding Window

We maintain a **sliding window** of size `k`:

* When we **add** a number, its frequency increases.
* When we **remove** a number, its frequency decreases.
* At any time, we need to quickly know:

  * Which elements are currently among the top `x` most frequent.
  * The running total of their contribution to the **x-sum**.

To achieve this efficiently:

* We keep two balanced binary search trees (AVL Trees):

  * **large** → stores top `x` most frequent pairs `(freq, num)`.
  * **small** → stores all remaining `(freq, num)` pairs.
* A **running result sum** (BigInt) stores the total contribution of `large`.

Whenever a frequency changes:

* We **remove** the old `(freq, num)` pair.
* **Insert** the new `(freq, num)` pair.
* We dynamically rebalance between `large` and `small` so that:

  * `large` always has exactly the `x` most frequent elements.
* The running `result` sum is updated accordingly.

---

# Approach

### Data Structures

* `occ: Map<number, number>` → Tracks the frequency of each number.
* `large: AvlTree<[freq, num]>` → Contains top `x` elements.
* `small: AvlTree<[freq, num]>` → Contains the rest.
* `result: bigint` → Tracks current x-sum contribution.

### Comparison Rule

Pairs are ordered by:

1. Frequency ascending.
2. Value ascending (since AVL tree gives min() easily, we store smaller first, but compare accordingly when moving).

Thus, the **largest frequency/value** pairs are at the **end** of the tree.

### Insert logic

When inserting `(freq, num)`:

* If `large` has fewer than `x` elements, or if `(freq, num)` is larger than the smallest in `large`:

  * Insert into `large`, add its contribution to `result`.
  * If now `large` exceeds size `x`, move smallest from `large` → `small`, and subtract from `result`.
* Otherwise, insert into `small`.

### Remove logic

When removing `(freq, num)`:

* If it’s in `large`, remove and subtract its contribution.

  * Then move the **largest** from `small` → `large`, adding its contribution.
* Otherwise, remove from `small`.

### Sliding window

For every new element:

1. Add it via `insert()`.
2. If window exceeds size `k`, remove the oldest element via `remove()`.
3. When the window reaches size `k`, record the current `result`.

---

# Complexity

| Operation                | Time Complexity                     |
| ------------------------ | ----------------------------------- |
| `insert`, `remove` (AVL) | O(log n)                            |
| Each element update      | O(log n)                            |
| Total (n elements)       | **O(n log n)**                      |
| Space                    | **O(n)** for frequency maps + trees |

This is highly efficient even for `n = 1e5`.

---

# Code

```typescript
import { AvlTree } from "@datastructures-js/binary-search-tree";

type FrequencyPair = [number, number];

class Helper {
    private x: number;
    private result: bigint;
    private large: AvlTree<FrequencyPair>;
    private small: AvlTree<FrequencyPair>;
    private occ: Map<number, number>;

    constructor(x: number) {
        this.x = x;
        this.result = 0n;

        const comparator = (a: FrequencyPair, b: FrequencyPair): number => {
            if (a[0] !== b[0]) return a[0] - b[0];
            return a[1] - b[1];
        };

        this.large = new AvlTree<FrequencyPair>(comparator);
        this.small = new AvlTree<FrequencyPair>(comparator);
        this.occ = new Map<number, number>();
    }

    insert(num: number): void {
        const currentFreq = this.occ.get(num) || 0;
        if (currentFreq > 0) this.internalRemove([currentFreq, num]);
        const newFreq = currentFreq + 1;
        this.occ.set(num, newFreq);
        this.internalInsert([newFreq, num]);
    }

    remove(num: number): void {
        const currentFreq = this.occ.get(num);
        if (!currentFreq) return;
        this.internalRemove([currentFreq, num]);
        const newFreq = currentFreq - 1;
        if (newFreq > 0) {
            this.occ.set(num, newFreq);
            this.internalInsert([newFreq, num]);
        } else {
            this.occ.delete(num);
        }
    }

    get(): number {
        return Number(this.result);
    }

    private internalInsert(p: FrequencyPair): void {
        if (
            this.large.count() < this.x ||
            (this.large.min() && this.comparePairs(p, this.large.min()!.getValue()) > 0)
        ) {
            this.result += BigInt(p[0]) * BigInt(p[1]);
            this.large.insert(p);
            if (this.large.count() > this.x) {
                const smallest = this.large.min()!.getValue();
                this.result -= BigInt(smallest[0]) * BigInt(smallest[1]);
                this.large.remove(smallest);
                this.small.insert(smallest);
            }
        } else {
            this.small.insert(p);
        }
    }

    private internalRemove(p: FrequencyPair): void {
        if (this.large.has(p)) {
            this.result -= BigInt(p[0]) * BigInt(p[1]);
            this.large.remove(p);
            if (this.small.count() > 0) {
                const largestSmall = this.small.max()!.getValue();
                this.result += BigInt(largestSmall[0]) * BigInt(largestSmall[1]);
                this.small.remove(largestSmall);
                this.large.insert(largestSmall);
            }
        } else {
            this.small.remove(p);
        }
    }

    private comparePairs(a: FrequencyPair, b: FrequencyPair): number {
        if (a[0] !== b[0]) return a[0] - b[0];
        return a[1] - b[1];
    }
}

export function findXSum(nums: number[], k: number, x: number): number[] {
    const helper = new Helper(x);
    const ans: number[] = [];
    for (let i = 0; i < nums.length; i++) {
        helper.insert(nums[i]);
        if (i >= k) helper.remove(nums[i - k]);
        if (i >= k - 1) ans.push(helper.get());
    }
    return ans;
};

```

---

## Example Walkthrough

### Input:

```
nums = [1,1,2,2,3,4,2,3]
k = 6, x = 2
```

**Window 1 → [1,1,2,2,3,4]**

* Freq: {1:2, 2:2, 3:1, 4:1}
* Top 2: (2,2) and (2,1)
* Sum = 2*2 + 2*1 = **6**

**Window 2 → [1,2,2,3,4,2]**

* Freq: {1:1, 2:3, 3:1, 4:1}
* Top 2: (3,2), (1,4)
* Sum = 3*2 + 1*4 = **10**

**Window 3 → [2,2,3,4,2,3]**

* Freq: {2:3, 3:2, 4:1}
* Top 2: (3,2), (2,3)
* Sum = 3*2 + 2*3 = **12**

Output = `[6, 10, 12]`

---

## Summary

| Aspect             | Explanation                                                   |
| ------------------ | ------------------------------------------------------------- |
| **Concept**        | Maintain top-`x` frequent numbers dynamically using AVL trees |
| **Technique**      | Sliding window + frequency map + balanced tree rebalancing    |
| **Complexity**     | O(n log n)                                                    |
| **Space**          | O(n)                                                          |
| **Advantage**      | Efficient and scalable for large `n`                          |
| **Example Output** | `[6, 10, 12]`                                                 |

---
