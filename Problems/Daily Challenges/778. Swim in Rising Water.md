[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)

# Intuition

Imagine water rising slowly across the grid.

* You start at `(0, 0)` when water level = 0.
* You can only move into cells whose elevation ≤ current water level `t`.
* You need the **minimum `t`** such that a path exists from `(0,0)` → `(n-1,n-1)`.

This is **not** a shortest path by distance — it’s the path minimizing the **maximum elevation** encountered along the way.

So the key question becomes:

> "What is the smallest possible **maximum height** we must climb through to reach the destination?"

---

# Approach: Dijkstra’s Algorithm (Min-Heap BFS)

We’ll use a **priority queue (min-heap)** to always move through the **lowest elevation** cell we can currently reach.

### Steps:

1. Start from `(0,0)` with elevation `grid[0][0]`.
2. Use a **min-heap** that stores `[elevation, row, col]`.
3. Keep a **visited** matrix to avoid revisiting.
4. While heap not empty:

   * Pop the smallest elevation cell.
   * Update `maxElevation` = `max(maxElevation, cellElevation)`.
   * If this cell is the destination `(n-1, n-1)`, return `maxElevation`.
   * Otherwise, push all valid 4-direction neighbors that aren’t visited yet.
5. Each time we move, we ensure we always expand the **lowest elevation reachable** cell first — similar to Dijkstra’s greedy path expansion.

---

# Complexity

| Type      | Complexity                                                      |
| --------- | --------------------------------------------------------------- |
| **Time**  | O(n² log n²) ≈ O(n² log n) — each cell is pushed once into heap |
| **Space** | O(n²) — for visited + heap storage                              |

---

# Code

```typescript
function swimInWater(grid: number[][]): number {
    const n = grid.length;
    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];

    const visited = Array.from({ length: n }, () => Array(n).fill(false));

    // Min-heap using a priority queue
    const minHeap: [number, number, number][] = [];
    const push = (elev: number, r: number, c: number) => {
        minHeap.push([elev, r, c]);
        minHeap.sort((a, b) => a[0] - b[0]); // keep smallest elevation first
    };

    push(grid[0][0], 0, 0);
    visited[0][0] = true;
    let maxElevation = 0;

    while (minHeap.length > 0) {
        const [elev, r, c] = minHeap.shift()!;
        maxElevation = Math.max(maxElevation, elev);

        if (r === n - 1 && c === n - 1) return maxElevation;

        for (const [dr, dc] of directions) {
            const nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc]) {
                visited[nr][nc] = true;
                push(grid[nr][nc], nr, nc);
            }
        }
    }

    return -1; // should not reach here
}
```

*(Note: In a real TypeScript environment, you'd use a proper priority queue library — for simplicity, sorting is used here.)*

---

## Example Walkthrough

### Example 1:

```
grid = [
 [0, 2],
 [1, 3]
]
```

| Step                      | Water Level | Heap Contents                  | Visited Path | Action |
| ------------------------- | ----------- | ------------------------------ | ------------ | ------ |
| Start                     | t = 0       | [(0,0,0)]                      | (0,0)        | Begin  |
| Pop (0,0,0)               | maxElev = 0 | Add neighbors (1,0)=1, (0,1)=2 |              |        |
| Heap → [(1,1,0), (2,0,1)] |             |                                |              |        |
| Pop (1,1,0)               | maxElev = 1 | Add neighbor (1,1)=3           |              |        |
| Heap → [(2,0,1), (3,1,1)] |             |                                |              |        |
| Pop (2,0,1)               | maxElev = 2 | No new cells                   |              |        |
| Pop (3,1,1)               | maxElev = 3 | Reached destination            |              |        |

**Output = 3**

### Example 2:

```
grid = [
 [0,1,2,3,4],
 [24,23,22,21,5],
 [12,13,14,15,16],
 [11,17,18,19,20],
 [10,9,8,7,6]
]
```

* The optimal path “snakes around” from low heights to reach the destination.
* The maximum elevation encountered on that path is **16**, so **t = 16**.

**Output = 16**

---

## Key Insights

* This problem is **not** about distance, but **the minimum maximum elevation**.
* Dijkstra (or Min-Heap BFS) is the perfect fit since we always expand the least elevation first.
* The water level (`t`) effectively equals the **highest elevation along the chosen path**.

---

