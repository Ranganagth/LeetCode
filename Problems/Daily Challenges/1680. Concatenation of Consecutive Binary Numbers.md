[1680. Concatenation of Consecutive Binary Numbers](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/)

# Intuition

You must build a number formed by:

```
binary(1) + binary(2) + binary(3) + ... + binary(n)
```

Example:

```
n = 3

1 → 1
2 → 10
3 → 11

Concatenation:

"1" + "10" + "11"
= "11011"
```

Directly building the string is inefficient because:

* Binary string becomes extremely large.
* Conversion to decimal exceeds numeric limits.

Key observation:

Concatenation in binary equals **left shifting** the previous result.

Example:

```
current = "110"

append "11"

= shift left by length("11") = 2 bits

110 << 2 = 11000

then OR:

11000 | 11 = 11011
```

So:

```
newNumber =
(previous << number_of_bits_of_i) | i
```

Take modulo at every step.

---

# Approach

Maintain:

```
result = concatenated decimal value
```

For each number `i` from `1 → n`:

1. Find number of bits required to represent `i`.

Example:

```
1 → 1 bit
2 → 10 → 2 bits
4 → 100 → 3 bits
8 → 1000 → 4 bits
```

Observation:

Whenever `i` is a power of 2:

```
bit length increases by 1.
```

Power of 2 check:

```
(i & (i - 1)) === 0
```

### Efficient Bit Length Tracking

Maintain:

```
bitLength
```

Increase when:

```
i = 1,2,4,8,16...
```

### Update Formula

```
result =
((result << bitLength) | i) % MOD
```

Where:

```
MOD = 1e9 + 7
```

## Algorithm

```
result = 0
bitLength = 0

for i from 1 → n:

    if i is power of 2:
        bitLength++

    result =
        (result << bitLength | i) % MOD

return result
```

---

# Complexity

### Time Complexity

Loop runs:

```
n times
```

Each iteration:

```
O(1)
```

Total:

```
O(n)
```

Efficient for:

```
n ≤ 100000
```
### Space Complexity

```
O(1)
```

Only few variables used.

---

# Code

```typescript
function concatenatedBinary(n: number): number {

    const MOD = 1_000_000_007n;

    let result = 0n;
    let bitLength = 0n;

    for (let i = 1n; i <= BigInt(n); i++) {

        // power of 2 → bit length increases
        if ((i & (i - 1n)) === 0n) {
            bitLength++;
        }

        // shift and append
        result =
            ((result << bitLength) | i) % MOD;
    }

    return Number(result);
};

```

---

## Why BigInt?

Intermediate values become very large.

Example:

```
n = 100000
```

Binary concatenation grows exponentially.

JavaScript `number` loses precision beyond:

```
2^53 - 1
```

`BigInt` avoids overflow.

---

# Example Walkthrough

## Example 1

```
n = 1
```

Start:

```
result = 0
```

### i = 1

Power of 2:

```
bitLength = 1
```

Update:

```
result = (0 << 1) | 1

= 1
```

Output:

```
1
```

---

## Example 2

```
n = 3
```

### i = 1

Power of 2.

```
bitLength = 1

result = 1
(binary "1")
```

### i = 2

Power of 2.

```
bitLength = 2
```

Shift:

```
1 << 2 = 100
```

Append:

```
100 | 10 = 110
```

Decimal:

```
6
```

Binary:

```
"110"
```

### i = 3

Not power of 2.

```
bitLength = 2
```

Shift:

```
110 << 2 = 11000
```

Append:

```
11000 | 11 = 11011
```

Decimal:

```
27
```

Output:

```
27
```

---

## Example 3

```
n = 12
```

Concatenation:

```
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
```

Binary result:

```
1101110010111011110001001101010111100
```

Decimal:

```
118505380540
```

Modulo:

```
505379714
```
