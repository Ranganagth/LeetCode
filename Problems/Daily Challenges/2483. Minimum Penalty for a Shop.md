[2483. Minimum Penalty for a Shop](https://leetcode.com/problems/minimum-penalty-for-a-shop/)

# Intuition

Penalty splits naturally into two parts at any closing hour `j`:

* While **open** (`0 … j-1`): every `'N'` adds penalty.
* While **closed** (`j … n-1`): every `'Y'` adds penalty.

Precompute how many `'Y'` appear up to each index (prefix). Then we can evaluate penalty for every `j` in O(1):

```
penalty(j) =
   (# of 'N' in [0..j-1]) +
   (# of 'Y' in [j..n-1])
```

Minimize this over all `j`, choose the **earliest** with minimum value.

---

# Approach

1. Let `n = customers.length`.
2. Build prefix counts `prefY[i] = number of 'Y' in customers[0..i-1]`.
3. Total `totalY = prefY[n]`.
4. For each `j` from `0..n`:
   * customers open part has `openN = j - prefY[j]`.
   * customers closed part has `closedY = totalY - prefY[j]`.
   * `penalty = openN + closedY`.
     Track minimum penalty and earliest `j`.

---

# Complexity

* **Time:** `O(n)`
* **Space:** `O(1)` beyond input (if we reuse running counts instead of storing full prefix)

---

# Code

```ts
function bestClosingTime(customers: string): number {
    const n = customers.length;
    let totalY = 0;
    for (const c of customers) if (c === 'Y') totalY++;

    let prefY = 0;
    let best = Infinity;
    let bestHour = 0;

    for (let j = 0; j <= n; j++) {
        const openN = j - prefY;
        const closedY = totalY - prefY;
        const penalty = openN + closedY;

        if (penalty < best) {
            best = penalty;
            bestHour = j;
        }

        if (j < n && customers[j] === 'Y') prefY++;
    }

    return bestHour;
};

```

---

# Example walkthrough

`customers = "YYNY"`
**n** = 4, **totalY** = 3

**Iterate:**

* j=0: prefY=0 → openN=0, closedY=3 → penalty=3
* j=1: prefY=1 → openN=0, closedY=2 → penalty=2
* j=2: prefY=2 → openN=0, closedY=1 → penalty=1   ← best
* j=3: prefY=2 → openN=1, closedY=1 → penalty=2
* j=4: prefY=3 → openN=1, closedY=0 → penalty=1

Minimum penalty occurs at hours 2 and 4, earliest is **2**

---
