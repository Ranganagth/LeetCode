[1488. Avoid Flood in The City](https://leetcode.com/problems/avoid-flood-in-the-city/)

# Intuition

We have an array `rains`, where:

* `rains[i] > 0`: It rains on lake `rains[i]` (fills it).
* `rains[i] == 0`: It’s dry day — we can **choose any one lake** to dry.

If it rains again on a **full lake**, there’s a flood — which we must avoid.

So, our goal:

> Whenever a lake is about to rain again, we must ensure it’s dried **before** that happens.

---

## Core Idea

To avoid floods:

* We track **the last day each lake was filled**.
* We use **dry days** (zeros) strategically to **dry the lakes** that will be rained upon soonest.

We’ll need:

1. A map `fullLakes` → `{lake: lastRainDay}`
2. A list `dryDays` → indices of available dry days (`rains[i] == 0`).
3. For each new rain day:

   * If the lake is **already full**, we must find a **dry day** (from `dryDays`) that occurs **after the lastRainDay** and **before today**.
   * If such a dry day exists, assign that dry day to dry this lake.
   * Otherwise, **flood** (return `[]`).

This means:

* Every time a lake rains twice, it **must have been dried between those two rains**.

We can efficiently find such dry days using **binary search**.

---

# Approach

1. Initialize:

   * `ans` array with size `rains.length`, default all `-1`.
   * `fullLakes = new Map<number, number>()`
   * `dryDays: number[] = []`

2. Iterate `i` through `rains`:

   * If `rains[i] > 0`:

     * Let `lake = rains[i]`.
     * If `lake` already in `fullLakes`, find the smallest `dryDay` index **greater than** `fullLakes.get(lake)` using **binary search**.

       * If none found → impossible → return `[]`.
       * Otherwise, use that dry day → mark `ans[dryDay] = lake` and remove that dry day from list.
     * Update `fullLakes.set(lake, i)`.
     * Set `ans[i] = -1` (since it’s raining).
   * Else (`rains[i] == 0`):

     * Push `i` into `dryDays`.
     * Temporarily set `ans[i] = 1` (we can replace later if needed).

3. Return `ans`.

---

# Complexity

| Type      | Complexity                                     |
| --------- | ---------------------------------------------- |
| **Time**  | O(n log n) — binary search for each rain event |
| **Space** | O(n) — storing dry days and lake states        |

---

# Code

```typescript
function avoidFlood(rains: number[]): number[] {
    const n = rains.length;
    const ans = Array(n).fill(1);
    const fullLakes = new Map<number, number>();
    const dryDays: number[] = [];

    for (let i = 0; i < n; i++) {
        const lake = rains[i];

        if (lake > 0) {
            ans[i] = -1;

            if (fullLakes.has(lake)) {
                const lastRainDay = fullLakes.get(lake)!;
                const dryIdx = findDryDay(dryDays, lastRainDay);

                if (dryIdx === -1) return [];

                const dryDay = dryDays[dryIdx];
                ans[dryDay] = lake;
                dryDays.splice(dryIdx, 1); // remove used dry day
            }

            fullLakes.set(lake, i);
        } else {
            dryDays.push(i);
        }
    }

    return ans;
}

function findDryDay(dryDays: number[], lastRainDay: number): number {
    let l = 0, r = dryDays.length - 1;
    let res = -1;

    while (l <= r) {
        const mid = Math.floor((l + r) / 2);
        if (dryDays[mid] > lastRainDay) {
            res = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }

    return res;
};

```

---

## Example Walkthrough

### Example:

```
Input: rains = [1, 2, 0, 0, 2, 1]
```

| Day | rains[i] | Action                                                                | dryDays | fullLakes  | ans               |
| --- | -------- | --------------------------------------------------------------------- | ------- | ---------- | ----------------- |
| 0   | 1        | Rain on lake 1                                                        | []      | {1:0}      | [-1]              |
| 1   | 2        | Rain on lake 2                                                        | []      | {1:0, 2:1} | [-1,-1]           |
| 2   | 0        | Dry day available                                                     | [2]     | {1:0,2:1}  | [-1,-1,1]         |
| 3   | 0        | Dry day available                                                     | [2,3]   | {1:0,2:1}  | [-1,-1,1,1]       |
| 4   | 2        | Lake 2 already full → find dry day after 1 → found day 2 → dry lake 2 | [3]     | {1:0,2:4}  | [-1,-1,2,1,-1]    |
| 5   | 1        | Lake 1 already full → find dry day after 0 → found day 3 → dry lake 1 | []      | {1:5,2:4}  | [-1,-1,2,1,-1,-1] |

**Output:** `[-1, -1, 2, 1, -1, -1]`

Flood avoided successfully.

---

## **Key Insights**

* Greedy choice: always dry **the lake that will flood first**.
* Binary search helps efficiently locate the **earliest dry day** after last rain.
* Works even with large constraints (up to 1e5).

---
