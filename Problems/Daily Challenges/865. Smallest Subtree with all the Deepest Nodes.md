[865. Smallest Subtree with all the Deepest Nodes](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/)

# Intuition

All deepest nodes must lie in one subtree. The smallest subtree that contains all of them is exactly their **lowest common ancestor (LCA)**.
So the problem reduces to:
Find the LCA of all nodes that have the maximum depth.

Instead of first listing deepest nodes and then computing LCA, compute both **depth and candidate subtree root in one DFS**.

**Key observation:**

For any node:
* If left and right subtrees have the same maximum depth, this node is the LCA of deepest nodes below it.
* Otherwise, the deeper side alone contains all deepest nodes.

---

# Approach

Use a postorder DFS that returns:

* `depth`: maximum depth of the subtree rooted at this node
* `node`: the root of the smallest subtree containing all deepest nodes in this subtree

**Recursive rules:**

1. If node is null → depth = 0, node = null
2. Recurse left and right
3. Compare depths:

   * If leftDepth > rightDepth → propagate left result
   * If rightDepth > leftDepth → propagate right result
   * If equal → current node is the answer for this subtree

The final returned node is the required subtree root.

---

# Complexity

- **Time:** O(n)
- **Space:** O(h) recursion stack, h = tree height (O(n) worst case)

---

# Code

```ts
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = val ?? 0;
        this.left = left ?? null;
        this.right = right ?? null;
    }
}

function subtreeWithAllDeepest(root: TreeNode | null): TreeNode | null {
    function dfs(node: TreeNode | null): [number, TreeNode | null] {
        if (!node) return [0, null];

        const [ld, ln] = dfs(node.left);
        const [rd, rn] = dfs(node.right);

        if (ld > rd) return [ld + 1, ln];
        if (rd > ld) return [rd + 1, rn];

        return [ld + 1, node];
    }

    return dfs(root)[1];
};

```

---

# Example Walkthrough

## Example 1

```
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4
```

Deepest nodes: 7 and 4

* At node 2: leftDepth = rightDepth → return node 2
* Node 5 and node 3 also cover deepest nodes, but they are higher
* Smallest subtree covering all deepest nodes is rooted at 2

**Output:** `[2,7,4]`

## Example 2

```
0
 \
  1
   \
    2
```

Deepest node is 2
DFS propagates node 2 upward
Smallest subtree is node 2 itself

**Output:** `[2]`

> This solution directly computes the LCA of deepest leaves in one pass without extra storage.
