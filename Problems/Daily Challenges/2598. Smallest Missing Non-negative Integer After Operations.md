[2598. Smallest Missing Non-negative Integer After Operations](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/)

# Intuition

You are allowed to **add or subtract any multiple of `value`** from each element.

That means for each number `nums[i]`, you can transform it into any number that has the **same remainder modulo `value`**.

Example:
If `value = 5`,
then any number `x` with remainder `2` mod `5` can become `..., -8, -3, 2, 7, 12, 17, ...`

So effectively, each element `nums[i]` **belongs to a residue class** modulo `value`.
And we can move numbers freely within that residue class.

---

# Goal

We want to make the MEX (Minimum Excluded Number) as large as possible.

Let’s think about what MEX means:

* MEX = smallest non-negative integer **not present** in the array.

If we can make all numbers `0, 1, 2, ..., m-1` appear, then MEX = `m`.

So, we need to check how many integers (starting from 0) we can form using the available residues.

## Key Insight

Every integer `x` has a residue:

```
x mod value = r   (0 ≤ r < value)
```

To create a sequence of consecutive numbers starting from 0,
we must be able to "assign" each `x` to some residue `r` that appears enough times.

If we can form each number `x = value * q + r`,
we need to ensure that **for residue r**, there are at least `(q + 1)` occurrences available.

---

# Approach

1. **Count how many elements have each remainder modulo `value`:**

   ```typescript
   remainderCount[r] = how many nums[i] % value == r
   ```

2. **Iterate through natural numbers (0, 1, 2, 3, ...)**:

   * For each number `x`, check remainder `r = x % value`.
   * If we still have some available numbers with that remainder, we can “use” one (decrement count).
   * Otherwise, we can’t represent this number → `MEX = x`.

3. **Stop** when a remainder runs out of available numbers.

---

# Time and Space Complexity

* **Time:** `O(n + MEX)` ≈ `O(n)` because MEX ≤ `n`
* **Space:** `O(value)` to store remainder frequencies

---

# Code

```typescript
function findSmallestInteger(nums: number[], value: number): number {
  const freq = new Map<number, number>();

  // Step 1: count frequency of each remainder mod value
  for (const num of nums) {
    const mod = ((num % value) + value) % value; // handle negatives properly
    freq.set(mod, (freq.get(mod) ?? 0) + 1);
  }

  // Step 2: build possible sequence starting from 0
  let mex = 0;
  while (true) {
    const remainder = mex % value;
    const count = freq.get(remainder) ?? 0;
    if (count === 0) break; // can't form this number
    freq.set(remainder, count - 1); // use one occurrence
    mex++;
  }

  return mex;
};

```

---

## Example Walkthrough

### Example 1:

```
nums = [1, -10, 7, 13, 6, 8], value = 5
```

#### Step 1: Compute remainders (mod 5)

| num | remainder |
| --- | --------- |
| 1   | 1         |
| -10 | 0         |
| 7   | 2         |
| 13  | 3         |
| 6   | 1         |
| 8   | 3         |

Frequencies:

```
0 → 1
1 → 2
2 → 1
3 → 2
4 → 0
```

#### Step 2: Build numbers 0,1,2,3,4,...

| Number (mex) | remainder | freq before | can form? | freq after |
| ------------ | --------- | ----------- | --------- | ---------- |
| 0            | 0         | 1           | yes       | 0          |
| 1            | 1         | 2           | yes       | 1          |
| 2            | 2         | 1           | yes       | 0          |
| 3            | 3         | 2           | yes       | 1          |
| 4            | 4         | 0           | no        | —          |

→ Can’t form 4 → **MEX = 4**

Output: `4`

---

### Example 2:

```
nums = [1, -10, 7, 13, 6, 8], value = 7
```

#### Step 1: Remainders (mod 7)

| num | remainder |                               |
| --- | --------- | ----------------------------- |
| 1   | 1         |                               |
| -10 | 4         | (since -10 % 7 = -3 → +7 = 4) |
| 7   | 0         |                               |
| 13  | 6         |                               |
| 6   | 6         |                               |
| 8   | 1         |                               |

Frequencies:

```
0 → 1
1 → 2
2 → 0
3 → 0
4 → 1
5 → 0
6 → 2
```

#### Step 2: Try to build MEX

| Number (mex) | remainder | freq before | can form? | freq after |
| ------------ | --------- | ----------- | --------- | ---------- |
| 0            | 0         | 1           | yes       | 0          |
| 1            | 1         | 2           | yes       | 1          |
| 2            | 2         | 0           | no        | —          |

→ MEX = 2 

**Final Answers**

| Example | Input                       | Output |
| ------- | --------------------------- | ------ |
| 1       | `[1,-10,7,13,6,8], value=5` | `4`    |
| 2       | `[1,-10,7,13,6,8], value=7` | `2`    |

---

## Summary

* Each number belongs to a residue class modulo `value`.
* You can form consecutive integers starting from 0 as long as you have enough counts for each residue.
* Use and decrement frequency per remainder.
* Stop when one remainder runs out → that’s the **maximum possible MEX**.
