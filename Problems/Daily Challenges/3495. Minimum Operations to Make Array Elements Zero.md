[3495. Minimum Operations to Make Array Elements Zero](https://leetcode.com/problems/minimum-operations-to-make-array-elements-zero/)

# Intuition

We are allowed to repeatedly pick **two numbers** from the array and replace each with `floor(a/4)` and `floor(b/4)`.
So each operation simultaneously reduces **two numbers** by dividing them by 4 (floor).

The key question: *How many times must a number `x` be divided by 4 until it becomes zero?*

### Observation 1

For any integer `x`, define:

$$
f(x) = \text{minimum steps to reduce } x \text{ to } 0 \text{ via } x \mapsto \lfloor x/4 \rfloor.
$$

Example:

* `f(1)=1` (`1 -> 0`).
* `f(2)=1` (`2 -> 0`).
* `f(3)=1` (`3 -> 0`).
* `f(4)=2` (`4 -> 1 -> 0`).
* `f(16)=3` (`16 -> 4 -> 1 -> 0`).

So in general:

$$
f(x) = \lfloor \log_4(x) \rfloor + 1
$$

Proof: Each step divides by 4, so the number of steps is the number of times you can divide until it reaches 0.
### Observation 2

For an array of numbers, the total number of "individual reductions" needed is:

$$
S = \sum f(x).
$$

But each **operation** reduces two numbers simultaneously, so each operation contributes **2 unit reductions**.

Therefore, the **minimum number of operations** is:

$$
\text{operations} = \left\lceil \frac{S}{2} \right\rceil
$$

---
# Approach

For each query `[l, r]`:

1. Compute the total sum:
   $$
   S = \sum_{x=l}^{r} f(x).
   $$
2. The answer for this query = `ceil(S/2)`.
3. Return the sum of answers across all queries.


### Challenge

Directly summing `f(x)` for all numbers in `[l, r]` is impossible (`r` up to $10^9$). We need a **mathematical shortcut**.
### Observation 3

`f(x)` is **piecewise constant**:

* For `x ∈ [1,3]`, `f(x)=1`.
* For `x ∈ [4,15]`, `f(x)=2`.
* For `x ∈ [16,63]`, `f(x)=3`.
* For `x ∈ [64,255]`, `f(x)=4`.
* In general:
  For `x ∈ [4^(k-1), 4^k - 1]`, we have `f(x) = k`.

So we can precompute prefix sums:

$$
F(n) = \sum_{x=1}^{n} f(x).
$$

Then for any interval `[l,r]`:

$$
\sum_{x=l}^r f(x) = F(r) - F(l-1).
$$

### How to Compute `F(n)`

Break into blocks of powers of 4:

* For `k = 1`: numbers in `[1, 3]`, count = 3, each contributes 1.
* For `k = 2`: numbers in `[4, 15]`, count = 12, each contributes 2.
* For `k = 3`: numbers in `[16, 63]`, count = 48, each contributes 3.
* In general:

  * Range size = `4^k - 4^(k-1) = 3*4^(k-1)`.
  * Contribution = `k * range size`.

So to compute `F(n)`:

1. Initialize sum = 0.
2. For `k = 1,2,...` until `4^k - 1 ≥ n`:

   * If `n ≥ 4^k - 1`, add full block contribution.
   * Otherwise, add partial contribution `(n - 4^(k-1) + 1) * k`.

---

# Complexity

* Each query can be answered in **O(log₄ n)**, i.e., about 16 steps (since $4^{16} > 10^9$).
* With up to `10^5` queries, this is efficient.

---

# Code

```typescript
function sumF(n: number): bigint {
    if (n <= 0) return 0n;

    let res = 0n;
    let base = 1n; // 4^(k-1)
    let k = 1n;

    while (true) {
        let next = base * 4n; // 4^k
        let blockEnd = next - 1n;
        if (blockEnd <= BigInt(n)) {
            // full block
            let count = (next - base); // count of numbers in this block
            res += count * k;
            base = next;
            k++;
        } else {
            // partial block
            let count = BigInt(n) - base + 1n;
            res += count * k;
            break;
        }
    }
    return res;
}

function minOperationsQueries(queries: number[][]): number {
    let total = 0n;

    for (let [l, r] of queries) {
        let sum = sumF(r) - sumF(l - 1);
        let ops = (sum + 1n) / 2n; // ceil(sum/2)
        total += ops;
    }

    return Number(total);
};


// Example usage:
console.log(minOperationsQueries([[1,2],[2,4]])); // 3
console.log(minOperationsQueries([[2,6]]));       // 4
```

---

## Example Walkthrough

### Example 1

`queries = [[1,2],[2,4]]`

* Query `[1,2]`:
  f(1)=1, f(2)=1 → sum=2 → ops=ceil(2/2)=1.
* Query `[2,4]`:
  f(2)=1, f(3)=1, f(4)=2 → sum=4 → ops=ceil(4/2)=2.
  Total = 1+2 = 3. 

### Example 2

`queries = [[2,6]]`

f(2)=1, f(3)=1, f(4)=2, f(5)=2, f(6)=2 → sum=8 → ops=ceil(8/2)=4. 

---
