[3652. Best Time to Buy and Sell Stock using Strategy](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-using-strategy/)

# Intuition

Profit is linear:
$$\text{profit} = \sum_i (\text{strategy}[i] \times \text{prices}[i])$$

A modification **overwrites exactly one window of length `k`**:

* First `k/2` → `0` (contribute `0`)
* Last `k/2` → `1` (contribute `+prices[i]`)

Everything outside the window stays unchanged.

So for any window `[l, r]` of length `k`, the total profit becomes:

```
original_profit
- original_contribution_of_window
+ modified_contribution_of_window
```

Thus, the task is to find the window of length `k` that **maximizes the gain** from replacement.

This becomes a sliding window optimization.

---

## Reformulation

Let:

* `orig[i] = strategy[i] * prices[i]`
* `baseProfit = sum(orig)`

For a window `[l, l+k-1]`:

1. **Original window contribution**
$$W_{orig} = \sum_{i=l}^{l+k-1} orig[i]$$

2. **Modified window contribution**

Only the last `k/2` positions contribute:
$$W_{new} = \sum_{i=l+k/2}^{l+k-1} prices[i]$$

3. **Net gain**
$$gain = W_{new} - W_{orig}$$

Answer = `baseProfit + max(0, max_gain_over_all_windows)`

---

# Approach

1. Compute `baseProfit`.
2. Precompute prefix sums:

   * `prefixOrig` for `orig`
   * `prefixPrice` for `prices`
3. Slide a window of size `k`:

   * Compute `W_orig` in O(1)
   * Compute `W_new` using prices prefix
   * Track maximum gain
4. Add the best gain to `baseProfit`.

## Correctness Reasoning

* Every valid strategy is either:

  * unchanged
  * or exactly one window modified
* Profit difference is fully localized to the modified window
* Sliding window guarantees checking **all possible valid modifications**
* Taking max with 0 preserves the option of no modification

---

# Complexity

* **Time:** `O(n)`
* **Space:** `O(n)` (can be optimized to `O(1)`)

---

# Code

```ts
function maxProfit(
    prices: number[],
    strategy: number[],
    k: number
): number {
    const n = prices.length;

    const orig: number[] = new Array(n);
    let baseProfit = 0;

    for (let i = 0; i < n; i++) {
        orig[i] = strategy[i] * prices[i];
        baseProfit += orig[i];
    }

    // Prefix sums
    const prefOrig = new Array(n + 1).fill(0);
    const prefPrice = new Array(n + 1).fill(0);

    for (let i = 0; i < n; i++) {
        prefOrig[i + 1] = prefOrig[i] + orig[i];
        prefPrice[i + 1] = prefPrice[i] + prices[i];
    }

    let bestGain = 0;
    const half = k / 2;

    for (let l = 0; l + k <= n; l++) {
        const r = l + k;

        // original window sum
        const origSum = prefOrig[r] - prefOrig[l];

        // new window sum (only second half contributes)
        const newSum =
            prefPrice[r] - prefPrice[l + half];

        bestGain = Math.max(bestGain, newSum - origSum);
    }

    return baseProfit + bestGain;
};

```

---

# Example Walkthrough

Example 1

```
prices   = [4,2,8]
strategy = [-1,0,1]
k = 2
```

Base profit:

```
(-1×4) + (0×2) + (1×8) = 4
```

Window `[0,1]`:

* Original: `-4 + 0 = -4`
* Modified: `[0,1] → [0,1]` ⇒ `0 + 2 = 2`
* Gain = `2 - (-4) = 6`

Final profit:

```
4 + 6 = 10
```

Correct.

---

## Key Insight

Because the modification is fixed-form and linear, the entire problem collapses into **maximizing a sliding-window delta**. No DP, no greedy heuristics—just prefix sums and window evaluation.
