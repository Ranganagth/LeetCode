[3507. Minimum Pair Removal to Sort Array I](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/)

# Intuition

You are **forced** to perform a very specific operation each time:

* Find the **adjacent pair with the minimum sum**
* If ties exist, pick the **leftmost**
* Replace that pair with their sum

There is **no choice or optimization path** — the process is deterministic.
So the task reduces to **simulation** until the array becomes non-decreasing.

Because `n ≤ 50`, a direct simulation is efficient and safe.

## Key Observations

* Each operation **reduces array length by 1**
* Maximum operations ≤ `n - 1`
* Checking whether an array is non-decreasing costs `O(n)`
* Finding the minimum adjacent sum costs `O(n)`

Total work is small.

---

# Approach

1. Define a helper to check if the array is non-decreasing
2. While the array is **not** non-decreasing:

   * Scan all adjacent pairs
   * Find the minimum sum (tie → leftmost)
   * Replace that pair with their sum
   * Increment operation count
3. Return the operation count

## Correctness

* Since the operation is mandatory and deterministic, simulation guarantees the minimum number of steps
* We stop immediately once the array becomes non-decreasing

---

# Complexity

* **Time:** `O(n³)` worst-case
  (`n` operations × `n` scan × `n` check)
  With `n ≤ 50`, this is trivial
* **Space:** `O(n)`

---

# Code

```ts
function minimumPairRemoval(nums: number[]): number {
    const isNonDecreasing = (arr: number[]): boolean => {
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) return false;
        }
        return true;
    };

    let ops = 0;

    while (!isNonDecreasing(nums)) {
        let minSum = Infinity;
        let idx = 0;

        // find leftmost adjacent pair with minimum sum
        for (let i = 0; i < nums.length - 1; i++) {
            const s = nums[i] + nums[i + 1];
            if (s < minSum) {
                minSum = s;
                idx = i;
            }
        }

        // replace the pair with their sum
        nums.splice(idx, 2, minSum);
        ops++;
    }

    return ops;
};

```

---

# Example Walkthrough

### Example 1

```
nums = [5,2,3,1]
```

**Step 1**

* Adjacent sums: (5,2)=7, (2,3)=5, (3,1)=4 ← min
* Replace (3,1) → 4
* nums = [5,2,4]

**Step 2**

* Adjacent sums: (5,2)=7, (2,4)=6 ← min
* Replace (2,4) → 6
* nums = [5,6]

Array is non-decreasing → stop

**Answer:** `2`

### Example 2

```
nums = [1,2,2]
```

Already non-decreasing
**Answer:** `0`

---

## Final Insight

This problem is **not greedy**, **not DP**, **not optimization**.

It is a **pure deterministic simulation** problem — follow the rules exactly and stop at the first valid state.
