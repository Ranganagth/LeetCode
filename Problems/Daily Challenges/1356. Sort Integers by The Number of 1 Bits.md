[1356. Sort Integers by The Number of 1 Bits](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/)

# Intuition

Each number has a **binary representation**.

Example:

```
5 → 101 → two 1s
6 → 110 → two 1s
8 → 1000 → one 1
```

Sorting rule:

1. Sort by **number of set bits (1s)**.
2. If two numbers have the same count → sort by **numeric value**.

This becomes a **custom sorting problem**.

Key observation:

```
Primary key   → bit count
Secondary key → number itself
```

---

# Approach

### Step 1 - Count number of set bits

Efficient method:

Use **Brian Kernighan’s Algorithm**:

```
while (x > 0):
   x = x & (x - 1)
```

Each iteration removes the lowest set bit.

Example:

```
x = 6 = 110

110 & 101 = 100
100 & 011 = 000

count = 2
```

Runs only as many times as there are `1`s.

### Step 2 - Sort using Custom Comparator

Sort using:

```
(bitCount(a) - bitCount(b))
```

If equal:

```
a - b
```

## Algorithm

```
function bitCount(n):
    count = 0

    while n > 0:
        n = n & (n - 1)
        count++

    return count

sort array using comparator:

    if bitcount different:
        smaller bitcount first

    else:
        smaller number first
```

---

# Complexity

Let:

```
N = arr.length
```

**Bit Counting**

Max bits ≤ 14 (since arr[i] ≤ 10000).

Worst:

```
O(N log MAX)
≈ O(N)
```

**Sorting**

```
O(N log N)
```

Dominant complexity.

**Space Complexity**

```
O(1)
```

(in-place sort ignoring output).

---

# Code

```typescript
function sortByBits(arr: number[]): number {

    // Brian Kernighan bit count
    function bitCount(x: number): number {
        let count = 0;

        while (x > 0) {
            x &= (x - 1); // remove lowest set bit
            count++;
        }

        return count;
    }

    arr.sort((a, b) => {

        const bitsA = bitCount(a);
        const bitsB = bitCount(b);

        // primary sort → bit count
        if (bitsA !== bitsB) {
            return bitsA - bitsB;
        }

        // secondary sort → numeric value
        return a - b;
    });

    return arr;
}
```

---

## Further Optimization (Optional - Faster Comparator)

Avoid recomputing bitcount repeatedly.

Precompute once.

```typescript
function sortByBits(arr: number[]): number {

    const bitMap = new Map<number, number>();

    function bitCount(x: number): number {

        if (bitMap.has(x)) return bitMap.get(x)!;

        let n = x;
        let count = 0;

        while (n > 0) {
            n &= (n - 1);
            count++;
        }

        bitMap.set(x, count);

        return count;
    }

    arr.sort((a, b) => {

        const diff = bitCount(a) - bitCount(b);

        return diff !== 0 ? diff : a - b;
    });

    return arr;
};

```

---

# Example Walkthrough

## Example 1

Input:

```
arr =
[0,1,2,3,4,5,6,7,8]
```

Binary + Bit Count:

```
0 → 0       → 0 bits

1 → 1       → 1
2 → 10      → 1
4 → 100     → 1
8 → 1000    → 1

3 → 11      → 2
5 → 101     → 2
6 → 110     → 2

7 → 111     → 3
```

Grouped:

```
0 bits:

[0]

1 bit:

[1,2,4,8]

2 bits:

[3,5,6]

3 bits:

[7]
```

Sorted result:

```
[0,1,2,4,8,3,5,6,7]
```

---

## Example 2

Input:

```
[1024,512,256,128,64,32,16,8,4,2,1]
```

All powers of two:

```
100000...
```

Each has:

```
1 set bit.
```

Tie breaker:

```
numeric ascending order.
```

Output:

```
[1,2,4,8,16,32,64,128,256,512,1024]
```
