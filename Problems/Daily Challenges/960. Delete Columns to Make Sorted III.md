[960. Delete Columns to Make Sorted III](https://leetcode.com/problems/delete-columns-to-make-sorted-iii/)

# Intuition

Each row must become **non-decreasing left to right** after deleting some columns.
Rows are independent. Deletions apply globally, but the constraint is per row.

For any single row, this reduces to:

* Keep a longest subsequence that is non-decreasing.
* Delete the rest.

Across all rows, a column can be kept **only if it is kept for every row**.
So we must keep a common set of columns that forms a non-decreasing sequence in **every row**.

Equivalent reformulation:

* Choose a subsequence of column indices.
* For every row, characters at those indices are non-decreasing.
* Maximize number of kept columns.
* Answer = total columns − kept columns.

This is a **Longest Non-Decreasing Subsequence across all rows simultaneously**, which becomes a DP over columns.

---

# Approach

Let `m` be number of columns.

Define:

* `dp[j]` = maximum number of columns we can keep ending at column `j`.

Transition:

* We can extend from column `i` to `j` (`i < j`) **only if**
  for every row `r`: `strs[r][i] <= strs[r][j]`.

Algorithm:

1. Initialize `dp[j] = 1` for all `j`.
2. For every pair `(i, j)` with `i < j`:

   * Check all rows:

     * If any `strs[r][i] > strs[r][j]`, transition is invalid.
   * Otherwise:

     * `dp[j] = max(dp[j], dp[i] + 1)`
3. Let `maxKeep = max(dp)`.
4. Answer = `m - maxKeep`.

This is optimal. Greedy fails because local order per row does not guarantee global compatibility.

---

# Complexity

* **Time:** `O(m² * n)`
  * `m ≤ 100`, `n ≤ 100` → safe.

* **Space:** `O(m)`

---

# Code

```ts
function minDeletionSize(strs: string[]): number {
    const n = strs.length;
    const m = strs[0].length;

    const dp: number[] = new Array(m).fill(1);

    for (let j = 0; j < m; j++) {
        for (let i = 0; i < j; i++) {
            let valid = true;
            for (let r = 0; r < n; r++) {
                if (strs[r][i] > strs[r][j]) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                dp[j] = Math.max(dp[j], dp[i] + 1);
            }
        }
    }

    const maxKeep = Math.max(...dp);
    return m - maxKeep;
};

```

---

# Example Walkthrough

**Example 1**

```
strs = ["babca","bbazb"]
columns: 0 1 2 3 4
          b a b c a
          b b a z b
```

Valid transitions:

* Column 2 → 3 works for all rows (`b ≤ c`, `a ≤ z`)
* Column 3 cannot go to 4 (`c > a`)

Longest valid subsequence length = 2 (`[2,3]`)

Total columns = 5
Deletions = `5 - 2 = 3`

---

**Example 2**

```
strs = ["edcba"]
```

Strictly decreasing.
LNDS length = 1
Deletions = `5 - 1 = 4`

---

## Core Insight

This is not a greedy deletion problem.
It is a **global subsequence maximization under multi-row monotonic constraints**.
