[2327. Number of People Aware of a Secret](https://leetcode.com/problems/number-of-people-aware-of-a-secret/)

# Intuition

* On day 1, only 1 person knows the secret.
* Each person:

  * Can start **sharing** the secret only after `delay` days.
  * **Forgets** the secret exactly after `forget` days.
* We need to count, at the end of day `n`, how many people still know the secret (not forgotten yet).

This is tricky because:

* People become "active sharers" only after a delay.
* They "drop out" after forgetting.
* So we need to carefully track how many new people are added each day and how many stop knowing.

---

# Approach

We use **dynamic programming (DP)** where:

* `dp[i]` = number of people who **learn the secret** on day `i`.

### Transitions:

1. **Base case:**

   * On day 1, only 1 person learns:
     `dp[1] = 1`.

2. **New learners (sharing effect):**

   * A person who learns on day `j` will start sharing from day `j + delay` until day `j + forget - 1`.
   * So on day `i`, new learners come from **all sharers** in that valid window.
   * Formula:

     ```
     dp[i] = sum(dp[j]) for all j where (i - forget < j <= i - delay)
     ```
   * This means: only those who learned the secret "long enough ago but haven’t forgotten yet" can contribute to today’s new learners.

3. **Answer (final count):**

   * At the end of day `n`, the number of people who still know the secret are those who learned it in the last `(forget - 1)` days.
   * Formula:

     ```
     result = sum(dp[j]) for j in [n - forget + 1, n]
     ```

---

# Complexity

* **Time:** `O(n * forget)` (can be optimized with prefix sums).
* **Space:** `O(n)` for `dp`.

---

# Code

```typescript
function peopleAwareOfSecret(n: number, delay: number, forget: number): number {
    const MOD = 1_000_000_007;
    const dp = new Array(n + 1).fill(0);

    dp[1] = 1; // Day 1: one person knows the secret

    for (let day = 2; day <= n; day++) {
        for (let prev = Math.max(1, day - forget + 1); prev <= day - delay; prev++) {
            dp[day] = (dp[day] + dp[prev]) % MOD;
        }
    }

    // Count people who still remember at day n
    let result = 0;
    for (let day = n - forget + 1; day <= n; day++) {
        if (day >= 1) {
            result = (result + dp[day]) % MOD;
        }
    }

    return result;
}
```

---

# Example Walkthrough

### Example 1

Input: `n = 6, delay = 2, forget = 4`

* Day 1: `dp[1] = 1` → Person A
* Day 2: No one can share yet → `dp[2] = 0`
* Day 3: A starts sharing → `dp[3] = dp[1] = 1` → Person B
* Day 4: A still shares → `dp[4] = dp[1] = 1` → Person C
* Day 5: B starts sharing, A forgets → `dp[5] = dp[2] = 0` → Only B contributes → 1 new (Person D)
* Day 6: B + C share → `dp[6] = dp[3] + dp[2] = 1 + 0 = 1` + also `dp[4] = 1` → 2 new (E, F)

At the end:

* People still remembering:
  Days \[6-4+1 = 3] to 6 → `dp[3] + dp[4] + dp[5] + dp[6] = 1 + 1 + 1 + 2 = 5`.

Output: **5**

---
