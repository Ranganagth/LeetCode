[3379. Transformed Array](https://leetcode.com/problems/transformed-array/)

# Intuition

Each index is handled **independently**.
From index `i`, the value `nums[i]` tells you **how far and in which direction** to move in a **circular array**:

* Positive → move right
* Negative → move left
* Zero → stay in place

Because the array is circular, indices wrap around using **modulo arithmetic**.
The key is to compute the destination index correctly and read the value there.

---

# Approach

Let `n = nums.length`.

For each index `i`:

1. If `nums[i] === 0`
   → `result[i] = 0`

2. Otherwise:

   * Compute movement: `steps = nums[i]`
   * Destination index:

     ```ts
     newIndex = (i + steps) % n
     ```
   * Since JavaScript modulo can be negative, fix it:

     ```ts
     if (newIndex < 0) newIndex += n
     ```
   * Set:

     ```ts
     result[i] = nums[newIndex]
     ```

Each index is processed once → simple and optimal.

---

# Complexity

* **Time:** `O(n)`
* **Space:** `O(n)` (for the result array)

---

# Code

```ts
function constructTransformedArray(nums: number[]): number[] {
    const n = nums.length;
    const result = new Array<number>(n);

    for (let i = 0; i < n; i++) {
        if (nums[i] === 0) {
            result[i] = 0;
        } else {
            let newIndex = (i + nums[i]) % n;
            if (newIndex < 0) newIndex += n; // handle negative wrap
            result[i] = nums[newIndex];
        }
    }

    return result;
};

```

---

# Example Walkthrough

### Example 1

**Input**

```
nums = [3, -2, 1, 1]
```

| i | nums[i] | Move    | Destination      | Value |
| - | ------- | ------- | ---------------- | ----- |
| 0 | 3       | right 3 | (0+3)%4 = 3      | 1     |
| 1 | -2      | left 2  | (1-2)%4 = -1 → 3 | 1     |
| 2 | 1       | right 1 | 3                | 1     |
| 3 | 1       | right 1 | 0                | 3     |

**Output**

```
[1, 1, 1, 3]
```


### Example 2

**Input**

```
nums = [-1, 4, -1]
```

| i | nums[i] | Destination      | Value |
| - | ------- | ---------------- | ----- |
| 0 | -1      | (0-1)%3 = -1 → 2 | -1    |
| 1 | 4       | (1+4)%3 = 2      | -1    |
| 2 | -1      | (2-1)%3 = 1      | 4     |

**Output**

```
[-1, -1, 4]
```

---

## Final Insight

This problem is purely about **correct circular indexing**.
Once modulo and negative handling are done properly, the solution is straightforward and optimal.
