[3010. Divide an Array Into Subarrays With Minimum Cost I](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)

# Intuition

You must split the array into **exactly 3 contiguous, non-empty subarrays**.

The **cost** of each subarray is simply its **first element**, not its sum.

So once you decide where the cuts are, the total cost is just:

```
nums[start of 1st] + nums[start of 2nd] + nums[start of 3rd]
```

Since the array is contiguous and starts at index `0`, this becomes:

```
nums[0] + nums[i] + nums[j]
```

where:

* `i` = start index of the 2nd subarray
* `j` = start index of the 3rd subarray
* `0 < i < j < n`

The problem reduces to choosing `i` and `j` that minimize this sum.

---

# Approach

### Brute-force all valid splits

Since `n ≤ 50`, we can safely try all possible ways to place the two cuts.

Algorithm:

1. Fix the first subarray to start at index `0`
2. Try all `i` from `1` to `n - 2` (start of second subarray)
3. For each `i`, try all `j` from `i + 1` to `n - 1` (start of third subarray)
4. Compute:

   ```
   cost = nums[0] + nums[i] + nums[j]
   ```
5. Track the minimum cost

## Why this works

* All subarrays are **contiguous**
* All subarrays are **non-empty**
* Cost depends **only on the first element**, so no prefix sums are needed
* Exhaustive search is fast enough due to small constraints

---

# Complexity

* **Time:** `O(n²)`
* **Space:** `O(1)`

---

# Code

```ts
function minimumCost(nums: number[]): number {
    const n = nums.length;
    let ans = Number.MAX_SAFE_INTEGER;

    for (let i = 1; i <= n - 2; i++) {
        for (let j = i + 1; j <= n - 1; j++) {
            ans = Math.min(ans, nums[0] + nums[i] + nums[j]);
        }
    }

    return ans;
};

```

---

# Example Walkthrough

### Example 1

```
nums = [1, 2, 3, 12]
```

Possible splits:

| Subarrays        | Cost            |
| ---------------- | --------------- |
| [1], [2], [3,12] | 1 + 2 + 3 = 6   |
| [1], [2,3], [12] | 1 + 2 + 12 = 15 |
| [1,2], [3], [12] | 1 + 3 + 12 = 16 |

**Minimum = 6**


### Example 2

```
nums = [5, 4, 3]
```

Only valid split:

```
[5], [4], [3] → 5 + 4 + 3 = 12
```

### Example 3

```
nums = [10, 3, 1, 1]
```

Best split:

```
[10,3], [1], [1] → 10 + 1 + 1 = 12
```

---

## Key Insight

Because the **cost ignores the length and sum of subarrays**, the problem is not about partition sums — it’s simply about choosing **two optimal starting points**.

Once that’s clear, the solution becomes straightforward and efficient.
