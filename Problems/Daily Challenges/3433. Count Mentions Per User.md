[3433. Count Mentions Per User](https://leetcode.com/problems/count-mentions-per-user/)

# Intuition

Each user has an “online window.” OFFLINE events temporarily flip the state. A user who goes offline at time t stays offline until t+60. State changes must be processed before any MESSAGE at the same time.

**Message types:**
idX → mention user X
ALL → mention all users (even offline)
HERE → mention only online users at that moment

### Key rule

> A user's state change (OFFLINE or auto-online) must be processed **before any message event that occurs at the same timestamp**.

**But also:**

**Events are NOT guaranteed to be sorted by timestamp.**  
You must sort them by timestamp, and when two events have the same timestamp:
- OFFLINE events first
- MESSAGE events second

Only then process.

---

# Approach

You must:
1. Sort events by timestamp
	If timestamp is the same:
	- OFFLINE before MESSAGE
    
 2. Before handling each event, auto-reactivate users whose offline duration ended.
 3. Then process the current event.

This matches problem semantics.

---

# Complexity

Users ≤ 100
Events ≤ 100
Total work is O(users × events) ≤ 10,000 → trivial.

---

# Code

```ts
function countMentions(numberOfUsers: number, events: string[][]): number[] {
    const online = new Array<boolean>(numberOfUsers).fill(true);
    const reactivate = new Array<number>(numberOfUsers).fill(0);
    const mentions = new Array<number>(numberOfUsers).fill(0);

    // Sort by timestamp ASC
    // If tie: OFFLINE before MESSAGE
    events.sort((a, b) => {
        const t1 = Number(a[1]), t2 = Number(b[1]);
        if (t1 !== t2) return t1 - t2;
        if (a[0] === "OFFLINE" && b[0] === "MESSAGE") return -1;
        if (a[0] === "MESSAGE" && b[0] === "OFFLINE") return 1;
        return 0;
    });

    for (const event of events) {
        const type = event[0];
        const time = Number(event[1]);
        const arg = event[2];

        // Auto-reactivate users
        for (let u = 0; u < numberOfUsers; u++) {
            if (!online[u] && reactivate[u] <= time) {
                online[u] = true;
            }
        }

        if (type === "OFFLINE") {
            const id = Number(arg);
            online[id] = false;
            reactivate[id] = time + 60;
        } else {
            // MESSAGE
            const tokens = arg.split(" ");

            if (tokens.includes("ALL")) {
                for (let u = 0; u < numberOfUsers; u++) mentions[u]++;
            } else if (tokens.includes("HERE")) {
                for (let u = 0; u < numberOfUsers; u++) {
                    if (online[u]) mentions[u]++;
                }
            } else {
                for (const t of tokens) {
                    if (t.startsWith("id")) {
                        const id = Number(t.slice(2));
                        mentions[id]++;
                    }
                }
            }
        }
    }

    return mentions;
};

```

---

# Example Walkthrough

**Input:**

`3 users events = [  ["MESSAGE","2","HERE"],  ["OFFLINE","2","1"],  ["OFFLINE","1","0"],  ["MESSAGE","61","HERE"] ]`

### Step 1: Sort events by timestamp

Sorted (with OFFLINE before MESSAGE at same timestamp):

1. ["OFFLINE","1","0"]
2. ["OFFLINE","2","1"]
3. ["MESSAGE","2","HERE"]
4. ["MESSAGE","61","HERE"]

### Step 2: Process

Initial: all online → [T, T, T]

---

### Event 1: OFFLINE @1, user 0

user0 offline → until 61

online: [F, T, T]  
mentions: [0,0,0]

### Event 2: OFFLINE @2, user 1

user1 offline → until 62

online: [F, F, T]

### Event 3: MESSAGE @2, HERE

Only user2 is online

mentions → [0,0,1]


### Event 4: MESSAGE @61, HERE

Before event, auto-restore:

- user0 returns at 61 → online now    
- user1 returns at 62 → still offline

online before message: [T, F, T]

HERE → users online: 0 and 2

mentions → [1,0,2]

### Final Answer

`[1,0,2]`