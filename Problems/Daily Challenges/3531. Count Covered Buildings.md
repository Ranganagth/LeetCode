[3531. Count Covered Buildings](https://leetcode.com/problems/count-covered-buildings/)

## Understanding the Problem

A building **(x, y)** is *covered* only if there exists:

* another building in the **same row** to the left
* another building in the **same row** to the right
* another building in the **same column** above
* another building in the **same column** below

This reduces to a **row/column membership check** problem.

---

# Intuition

For building (x, y):

* “left exists” ↔ some building in row x with column < y
* “right exists” ↔ some building in row x with column > y
* “above exists” ↔ some building in column y with row < x
* “below exists” ↔ some building in column y with row > x

Thus for each row and each column, just track:

* minimum and maximum index
* or more precisely:
  each building must NOT be the min or max in its row or column.

Because:

* If it is the **leftmost** in its row → no left
* If it is the **rightmost** in its row → no right
* If it is the **topmost** in its column → no above
* If it is the **bottommost** in its column → no below

So building (x,y) is covered iff:

```
rowMin[x] < y < rowMax[x]
colMin[y] < x < colMax[y]
```

---

# Approach

1. Create maps:

   * rowMin[x], rowMax[x]
   * colMin[y], colMax[y]

2. Single pass: fill mins and maxes.

3. Second pass: for each building:

   * check if it is inside the range in both its row and column.

4. Count all that satisfy the condition.

---

# Complexity

* Building count = m (≤ 100,000)
* Two passes over buildings: **O(m)**
* Map lookups: O(1) average

Total: **O(m)**
Memory: **O(m)**

---

# Code

```ts
function countCoveredBuildings(n: number, buildings: number[][]): number {
    const rowMin = new Map<number, number>();
    const rowMax = new Map<number, number>();
    const colMin = new Map<number, number>();
    const colMax = new Map<number, number>();

    // First pass: compute mins and maxes
    for (const [x, y] of buildings) {
        rowMin.set(x, Math.min(rowMin.get(x) ?? y, y));
        rowMax.set(x, Math.max(rowMax.get(x) ?? y, y));
        colMin.set(y, Math.min(colMin.get(y) ?? x, x));
        colMax.set(y, Math.max(colMax.get(y) ?? x, x));
    }

    // Second pass: count covered buildings
    let count = 0;
    for (const [x, y] of buildings) {
        if (
            rowMin.get(x)! < y && y < rowMax.get(x)! &&
            colMin.get(y)! < x && x < colMax.get(y)!
        ) {
            count++;
        }
    }

    return count;
};

```

---

# Example Walkthrough

## Example 1

```
n = 3
buildings = [
  [1,2],
  [2,2],
  [3,2],
  [2,1],
  [2,3]
]
```

### Row/column ranges:

* Row 1: min=2, max=2
* Row 2: min=1, max=3
* Row 3: min=2, max=2
* Col 1: min=2, max=2
* Col 2: min=1, max=3
* Col 3: min=2, max=2

Check building (2,2):

* rowMin[2]=1 < 2 < 3=rowMax[2] → has left & right
* colMin[2]=1 < 2 < 3=colMax[2] → has above & below

Covered → count = 1


## Example 2

```
n = 3
buildings = [[1,1],[1,2],[2,1],[2,2]]
```

Every building is at an edge of either the row or column → none is strictly inside range → answer = 0


## Example 3

```
n = 5
buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]
```

Row 3 has min=2 and max=5 → building (3,3) has both left & right
Column 3 has min=1 and max=5 → building (3,3) has both above & below

Only (3,3) is covered → answer = 1

---
